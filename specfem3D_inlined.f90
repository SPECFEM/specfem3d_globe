!=====================================================================
!
!          S p e c f e m 3 D  G l o b e  V e r s i o n  3 . 3
!          --------------------------------------------------
!
!                 Dimitri Komatitsch and Jeroen Tromp
!    Seismological Laboratory - California Institute of Technology
!        (c) California Institute of Technology August 2003
!
!    A signed non-commercial agreement is required to use this program.
!   Please check http://www.gps.caltech.edu/research/jtromp for details.
!           Free for non-commercial academic research ONLY.
!      This program is distributed WITHOUT ANY WARRANTY whatsoever.
!      Do not redistribute this program without written permission.
!
!=====================================================================
!
! Copyright August 2003, by the California Institute of Technology.
! ALL RIGHTS RESERVED. United States Government Sponsorship Acknowledged.
!
! Any commercial use must be negotiated with the Office of Technology
! Transfer at the California Institute of Technology. This software may be
! subject to U.S. export control laws and regulations. By accepting
! this software, the user agrees to comply with all applicable U.S. export laws
! and regulations, including the International Traffic and Arms Regulations,
! 22 C.F.R. 120-130 and the Export Administration Regulations,
! 15 C.F.R. 730-744. User has the responsibility to obtain export licenses,
! or other export authority as may be required before exporting such
! information to foreign countries or providing access to foreign nationals.
! In no event shall the California Institute of Technology be liable to any
! party for direct, indirect, special, incidental or consequential damages,
! including lost profits, arising out of the use of this software and its
! documentation, even if the California Institute of Technology has been
! advised of the possibility of such damage.
!
! The California Institute of Technology specifically disclaims any
! warranties, including the implied warranties or merchantability and fitness
! for a particular purpose. The software and documentation provided hereunder
! is on an "as is" basis, and the California Institute of Technology has no
! obligations to provide maintenance, support, updates, enhancements or
! modifications.
!

  program specfem3D

  implicit none

! standard include of the MPI library
  include 'mpif.h'

  include "constants.h"
  include "precision.h"

! include values created by the mesher
  include "OUTPUT_FILES/values_from_mesher.h"

!=======================================================================!
!                                                                       !
!   specfem3D is a 3-D spectral-element solver for the Earth.           !
!   It uses a mesh generated by program meshfem3D                       !
!                                                                       !
!=======================================================================!
!
! If you use this code for your own research, please send an email
! to Jeroen Tromp <jtromp@gps.caltech.edu> for information, and cite:
!
! @ARTICLE{KoRiTr02,
! author={D. Komatitsch and J. Ritsema and J. Tromp},
! year=2002,
! title={The Spectral-Element Method, {B}eowulf Computing, and Global Seismology},
! journal={Science},
! volume=298,
! pages={1737-1742}}
!
! @ARTICLE{KoTr02a,
! author={D. Komatitsch and J. Tromp},
! year=2002,
! title={Spectral-Element Simulations of Global Seismic Wave Propagation{-I. V}alidation},
! journal={Geophys. J. Int.},
! volume=149,
! pages={390-412}}
!
! @ARTICLE{KoTr02b,
! author={D. Komatitsch and J. Tromp},
! year=2002,
! title={Spectral-Element Simulations of Global Seismic Wave Propagation{-II. 3-D} Models, Oceans, Rotation, and Self-Gravitation},
! journal={Geophys. J. Int.},
! volume=150,
! pages={303-318}}
!
! @ARTICLE{KoTr99,
! author={D. Komatitsch and J. Tromp},
! year=1999,
! title={Introduction to the spectral-element method for 3-{D} seismic wave propagation},
! journal={Geophys. J. Int.},
! volume=139,
! pages={806-822}}
!
! If you use 3-D model S20RTS, please cite
!
! @ARTICLE{RiVa00,
! author={J. Ritsema and H. J. {Van Heijst}},
! year=2000,
! title={Seismic imaging of structural heterogeneity in {E}arth's mantle: Evidence for large-scale mantle flow},
! journal={Science Progress},
! volume=83,
! pages={243-259}}
!
! Evolution of the code:
! ---------------------
!
! v. 3.4 Dimitri Komatitsch and Jeroen Tromp, Caltech, August 2003:
!      merged global and regional codes, no iterations in fluid, better movies
! v. 3.3 Dimitri Komatitsch, Caltech, September 2002:
!      flexible mesh doubling in outer core, inlined code, OpenDX support
! v. 3.2 Jeroen Tromp, Caltech, July 2002:
!      multiple sources and flexible PREM reading
! v. 3.1 Dimitri Komatitsch, Caltech, June 2002:
!      vectorized loops in solver and merged central cube
! v. 3.0 Dimitri Komatitsch and Jeroen Tromp, Caltech, May 2002:
!   ported to SGI and Compaq, double precision solver, more general anisotropy
! v. 2.3 Dimitri Komatitsch and Jeroen Tromp, Caltech, August 2001:
!                       gravity, rotation, oceans and 3-D models
! v. 2.2 Dimitri Komatitsch and Jeroen Tromp, Caltech, March 2001:
!                       final MPI package
! v. 2.0 Dimitri Komatitsch, Harvard, January 2000: MPI code for the globe
! v. 1.0 Dimitri Komatitsch, Mexico, June 1999: first MPI code for a chunk
! Jeroen Tromp, Harvard, July 1998: first chunk solver using OpenMP on Sun
! Dimitri Komatitsch, IPG Paris, December 1996: first 3-D solver for the CM5
!
! From Dahlen and Tromp (1998):
! ----------------------------
!
! Gravity is approximated by solving eq (3.259) without the Phi_E' term
! The ellipsoidal reference model is that of section 14.1
! The transversely isotropic expression for PREM is that of eq (8.190)
!
! the potential in the outer core is called displ_outer_core for simplicity
!

! memory variables and standard linear solids for attenuation
  double precision, dimension(N_SLS) :: tau_mu_dble,tau_sigma_dble,beta_dble
  double precision factor_scale_dble,one_minus_sum_beta_dble
  real(kind=CUSTOM_REAL), dimension(NUM_REGIONS_ATTENUATION,N_SLS) :: tau_mu,tau_sigma,beta
  real(kind=CUSTOM_REAL), dimension(NUM_REGIONS_ATTENUATION) :: factor_scale,one_minus_sum_beta

  real(kind=CUSTOM_REAL) mul

  real(kind=CUSTOM_REAL), dimension(NUM_REGIONS_ATTENUATION,N_SLS) :: tauinv,alphaval,betaval,gammaval,factor_common
  integer iregion_attenuation
  double precision dist,scale_factor,scale_factor_minus_one

  real(kind=CUSTOM_REAL), dimension(5,NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE_ATTENUAT,N_SLS) :: R_memory_crust_mantle
  real(kind=CUSTOM_REAL), dimension(5,NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE_ATTENUAT) :: epsilondev_crust_mantle

  real(kind=CUSTOM_REAL), dimension(5,NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE_ATTENUATION,N_SLS) :: R_memory_inner_core
  real(kind=CUSTOM_REAL), dimension(5,NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE_ATTENUATION) :: epsilondev_inner_core

! for matching with central cube in inner core

  integer nb_msgs_theor_in_cube
  integer receiver_cube_from_slices,iproc_xi_loop
  integer nspec2D_xmin_inner_core,nspec2D_xmax_inner_core,nspec2D_ymin_inner_core,nspec2D_ymax_inner_core
  integer ipoin,idimension
  integer npoin2D_cube_from_slices
  integer isender,ireceiver,imsg

  double precision x_target,y_target,z_target
  double precision x_current,y_current,z_current

  integer, dimension(:), allocatable :: sender_from_slices_to_cube
  integer, dimension(:,:), allocatable :: ibool_central_cube
  double precision, dimension(:,:), allocatable :: buffer_slices
  double precision, dimension(:,:,:), allocatable :: buffer_all_cube_from_slices

  real(kind=CUSTOM_REAL), dimension(NGLOB_INNER_CORE) :: array_central_cube

! to save movie frames
  real(kind=CUSTOM_REAL), dimension(:), allocatable :: &
      store_val_x,store_val_y,store_val_z, &
      store_val_ux,store_val_uy,store_val_uz
  real(kind=CUSTOM_REAL), dimension(:,:), allocatable :: &
      store_val_x_all,store_val_y_all,store_val_z_all, &
      store_val_ux_all,store_val_uy_all,store_val_uz_all

! use integer array to store values
  integer ibathy_topo(NX_BATHY,NY_BATHY)

! MPI status of messages to be received
  integer msg_status(MPI_STATUS_SIZE)

! for crust/oceans coupling
  integer, dimension(:), allocatable :: ibelm_xmin_crust_mantle,ibelm_xmax_crust_mantle, &
    ibelm_ymin_crust_mantle,ibelm_ymax_crust_mantle,ibelm_bottom_crust_mantle,ibelm_top_crust_mantle
  logical, dimension(NGLOBMAX_CRUST_MANTLE) :: updated_dof_ocean_load
  real(kind=CUSTOM_REAL), dimension(:,:,:), allocatable :: jacobian2D_bottom_crust_mantle,jacobian2D_top_crust_mantle, &
    jacobian2D_xmin_crust_mantle,jacobian2D_xmax_crust_mantle, &
    jacobian2D_ymin_crust_mantle,jacobian2D_ymax_crust_mantle
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: normal_xmin_crust_mantle, &
    normal_xmax_crust_mantle,normal_ymin_crust_mantle,normal_ymax_crust_mantle, &
    normal_bottom_crust_mantle,normal_top_crust_mantle

! Stacey
  integer jk,ik
  integer, dimension(:,:), allocatable :: stacey_outer_core_xmin_j,stacey_outer_core_xmin_k, &
    stacey_outer_core_xmax_j,stacey_outer_core_xmax_k,stacey_outer_core_ymin_i, &
    stacey_outer_core_ymin_k,stacey_outer_core_ymax_i,stacey_outer_core_ymax_k, &
    stacey_bottom_outer_core_i,stacey_bottom_outer_core_j, &
    stacey_crust_mantle_xmin_j,stacey_crust_mantle_xmin_k,stacey_crust_mantle_xmax_j, &
    stacey_crust_mantle_xmax_k,stacey_crust_mantle_ymin_i,stacey_crust_mantle_ymin_k, &
    stacey_crust_mantle_ymax_i,stacey_crust_mantle_ymax_k
  integer, dimension(:), allocatable :: stacey_outer_core_xmin_jk,stacey_outer_core_xmax_jk, &
    stacey_outer_core_ymin_ik,stacey_outer_core_ymax_ik,stacey_crust_mantle_xmin_jk, &
    stacey_crust_mantle_xmax_jk,stacey_crust_mantle_ymin_ik,stacey_crust_mantle_ymax_ik
  real(kind=CUSTOM_REAL) sn,tx,ty,tz
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE) :: rho_vp_crust_mantle,rho_vs_crust_mantle
  integer nspec2D_xmin_crust_mantle,nspec2D_xmax_crust_mantle,nspec2D_ymin_crust_mantle,nspec2D_ymax_crust_mantle
  integer, dimension(:,:), allocatable :: nimin_crust_mantle, &
    nimax_crust_mantle,njmin_crust_mantle,njmax_crust_mantle, &
    nkmin_xi_crust_mantle,nkmin_eta_crust_mantle

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE) :: vp_outer_core
  integer nspec2D_xmin_outer_core,nspec2D_xmax_outer_core,nspec2D_ymin_outer_core,nspec2D_ymax_outer_core
  integer, dimension(:,:), allocatable :: nimin_outer_core, &
    nimax_outer_core,njmin_outer_core,njmax_outer_core, &
    nkmin_xi_outer_core,nkmin_eta_outer_core

! arrays to couple with the fluid regions by pointwise matching
  integer, dimension(:), allocatable :: ibelm_xmin_outer_core, &
    ibelm_xmax_outer_core,ibelm_ymin_outer_core,ibelm_ymax_outer_core, &
    ibelm_bottom_outer_core,ibelm_top_outer_core
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: normal_xmin_outer_core, &
    normal_xmax_outer_core,normal_ymin_outer_core,normal_ymax_outer_core, &
    normal_bottom_outer_core,normal_top_outer_core
  real(kind=CUSTOM_REAL), dimension(:,:,:), allocatable :: jacobian2D_bottom_outer_core,jacobian2D_top_outer_core, &
    jacobian2D_xmin_outer_core,jacobian2D_xmax_outer_core, &
    jacobian2D_ymin_outer_core,jacobian2D_ymax_outer_core

  integer, dimension(:), allocatable :: ibelm_xmin_inner_core, &
    ibelm_xmax_inner_core,ibelm_ymin_inner_core,ibelm_ymax_inner_core, &
    ibelm_bottom_inner_core,ibelm_top_inner_core

! for matching between fluid and solid regions
  integer ispec2D,k_corresp,ispec_selected
  real(kind=CUSTOM_REAL) vx,vy,vz,nx,ny,nz,vn,weight,pressure

! for ellipticity
  integer nspl
  double precision rspl(NR),espl(NR),espl2(NR)
  double precision ell_d80_dble
  real(kind=CUSTOM_REAL) cost,p20,theta,ell_d80

! for conversion from x y z to r theta phi
  real(kind=CUSTOM_REAL) rval,thetaval,phival

! ---- arrays to assemble between chunks

! communication pattern for faces between chunks
  integer, dimension(:), allocatable :: iprocfrom_faces,iprocto_faces,imsg_type

! communication pattern for corners between chunks
  integer, dimension(:), allocatable :: iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners

! indirect addressing for each message for faces and corners of the chunks
! a given slice can belong to at most one corner and at most two faces
  integer NPOIN2DMAX_XY
  integer, dimension(:,:), allocatable :: iboolfaces_crust_mantle
  integer, dimension(:,:), allocatable :: iboolfaces_outer_core
  integer, dimension(:,:), allocatable :: iboolfaces_inner_core

! buffers for send and receive between faces of the slices and the chunks
  real(kind=CUSTOM_REAL), dimension(:,:), allocatable :: buffer_send_faces,buffer_received_faces

! -------- arrays specific to each region here -----------

! ----------------- crust, mantle and oceans ---------------------

! mesh parameters
  integer, dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE) :: ibool_crust_mantle

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE) :: &
        xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle,&
        etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
        gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,jacobian_crust_mantle
  real(kind=CUSTOM_REAL), dimension(NGLOBMAX_CRUST_MANTLE) :: &
        xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle

! arrays for isotropic elements stored only where needed to save space
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_ISO_MANTLE) :: &
        kappavstore_crust_mantle,muvstore_crust_mantle

! arrays for anisotropic elements stored only where needed to save space
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_TISO_MANTLE) :: &
        kappahstore_crust_mantle,muhstore_crust_mantle,eta_anisostore_crust_mantle

! arrays for full anisotropy only when needed
  integer nspec_iso,nspec_tiso,nspec_ani
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE) :: &
        c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle, &
        c14store_crust_mantle,c15store_crust_mantle,c16store_crust_mantle, &
        c22store_crust_mantle,c23store_crust_mantle,c24store_crust_mantle, &
        c25store_crust_mantle,c26store_crust_mantle,c33store_crust_mantle, &
        c34store_crust_mantle,c35store_crust_mantle,c36store_crust_mantle, &
        c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
        c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle

! local to global mapping
  integer, dimension(NSPECMAX_CRUST_MANTLE) :: idoubling_crust_mantle

! mass matrix
  real(kind=CUSTOM_REAL), dimension(NGLOBMAX_CRUST_MANTLE) :: rmass_crust_mantle

! displacement, velocity, acceleration
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLOBMAX_CRUST_MANTLE) :: &
     displ_crust_mantle,veloc_crust_mantle,accel_crust_mantle

! additional mass matrix for ocean load
! ocean load mass matrix is always allocated statically even if no oceans
  real(kind=CUSTOM_REAL), dimension(NGLOBMAX_CRUST_MANTLE) :: rmass_ocean_load
  real(kind=CUSTOM_REAL) additional_term,force_normal_comp

! ----------------- outer core ---------------------

! mesh parameters
  integer, dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE) :: ibool_outer_core

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE) :: &
        xix_outer_core,xiy_outer_core,xiz_outer_core,&
        etax_outer_core,etay_outer_core,etaz_outer_core, &
        gammax_outer_core,gammay_outer_core,gammaz_outer_core,jacobian_outer_core
  real(kind=CUSTOM_REAL), dimension(NGLOBMAX_OUTER_CORE) :: &
        xstore_outer_core,ystore_outer_core,zstore_outer_core

! local to global mapping
  integer, dimension(NSPECMAX_OUTER_CORE) :: idoubling_outer_core

! mass matrix
  real(kind=CUSTOM_REAL), dimension(NGLOBMAX_OUTER_CORE) :: rmass_outer_core

! velocity potential
  real(kind=CUSTOM_REAL), dimension(NGLOBMAX_OUTER_CORE) :: displ_outer_core, &
    veloc_outer_core,accel_outer_core

! ----------------- inner core ---------------------

! mesh parameters
  integer, dimension(NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE) :: ibool_inner_core

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE) :: &
        xix_inner_core,xiy_inner_core,xiz_inner_core,&
        etax_inner_core,etay_inner_core,etaz_inner_core, &
        gammax_inner_core,gammay_inner_core,gammaz_inner_core,jacobian_inner_core, &
        kappavstore_inner_core,muvstore_inner_core
  real(kind=CUSTOM_REAL), dimension(NGLOB_INNER_CORE) :: &
        xstore_inner_core,ystore_inner_core,zstore_inner_core

! arrays for inner-core anisotropy only when needed
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_IC) :: &
        c11store_inner_core,c33store_inner_core,c12store_inner_core, &
        c13store_inner_core,c44store_inner_core

! local to global mapping
  integer, dimension(NSPEC_INNER_CORE) :: idoubling_inner_core

! mass matrix
  real(kind=CUSTOM_REAL), dimension(NGLOB_INNER_CORE) :: rmass_inner_core

! displacement, velocity, acceleration
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLOB_INNER_CORE) :: &
     displ_inner_core,veloc_inner_core,accel_inner_core

! --------

  integer npoin2D_faces_crust_mantle(NUMFACES_SHARED)
  integer npoin2D_faces_outer_core(NUMFACES_SHARED)
  integer npoin2D_faces_inner_core(NUMFACES_SHARED)

! parameters for the source
  integer it,isource
  integer, dimension(:), allocatable :: islice_selected_source,ispec_selected_source
  integer yr,jda,ho,mi
  real(kind=CUSTOM_REAL) stf_used
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: sourcearray
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:), allocatable :: sourcearrays
  double precision sec,stf
  double precision, dimension(:), allocatable :: Mxx,Myy,Mzz,Mxy,Mxz,Myz
  double precision, dimension(:), allocatable :: xi_source,eta_source,gamma_source
  double precision, dimension(:), allocatable :: t_cmt,hdur
  double precision, dimension(:), allocatable :: theta_source,phi_source
  double precision, external :: comp_source_time_function

! Newmark time scheme parameters and non-dimensionalization
  real(kind=CUSTOM_REAL) time,deltat,deltatover2,deltatsqover2
  double precision scale_t,scale_displ,scale_veloc

! receiver information
  integer nrec,nrec_local,nrec_tot_found
  integer irec_local
  integer, allocatable, dimension(:) :: islice_selected_rec,ispec_selected_rec,number_receiver_global
  double precision, allocatable, dimension(:) :: xi_receiver,eta_receiver,gamma_receiver

! Lagrange interpolants for receivers for inlined version
  double precision, allocatable, dimension(:,:,:,:) :: hlagrange
  double precision hlagrange_val

! timing information for the stations
  double precision, allocatable, dimension(:,:,:) :: nu
  character(len=8), allocatable, dimension(:) :: station_name,network_name

! seismograms
  integer it_begin,it_end
  double precision uxd,uyd,uzd
  real(kind=CUSTOM_REAL), dimension(:,:,:), allocatable :: seismograms

! non-dimensionalized rotation rate of the Earth times two
  real(kind=CUSTOM_REAL) two_omega_earth

! for the Euler scheme for rotation
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE_ROTATION) :: &
    A_array_rotation,B_array_rotation

  integer i,j,k,ispec,irec,iglob,iglob_mantle,iglob_inner_core

! number of faces between chunks
  integer NUM_FACES,NUMMSGS_FACES

! number of corners between chunks
  integer NCORNERSCHUNKS

! indirect addressing for each corner of the chunks
  integer, dimension(:,:), allocatable :: iboolcorner_crust_mantle,iboolcorner_outer_core,iboolcorner_inner_core

! buffers for send and receive between corners of the chunks
  real(kind=CUSTOM_REAL), dimension(:,:), allocatable :: buffer_send_chunk_corners,buffer_received_chunk_corners

! Gauss-Lobatto-Legendre points of integration and weights
  double precision, dimension(NGLLX) :: xigll,wxgll
  double precision, dimension(NGLLY) :: yigll,wygll
  double precision, dimension(NGLLZ) :: zigll,wzgll

! product of weights for gravity term
  double precision, dimension(NGLLX,NGLLY,NGLLZ) :: wgll_cube
  double precision, dimension(NDIM,NGLLX,NGLLY,NGLLZ) :: wgllwgll_yz_no_i,wgllwgll_xz_no_j,wgllwgll_xy_no_k

! array with derivatives of Lagrange polynomials and precalculated products
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLX) :: hprime_xx,hprimewgll_xx
  real(kind=CUSTOM_REAL), dimension(NGLLY,NGLLY) :: hprime_yy,hprimewgll_yy
  real(kind=CUSTOM_REAL), dimension(NGLLZ,NGLLZ) :: hprime_zz,hprimewgll_zz
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY) :: wgllwgll_xy
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLZ) :: wgllwgll_xz
  real(kind=CUSTOM_REAL), dimension(NGLLY,NGLLZ) :: wgllwgll_yz

! Lagrange interpolators at receivers
  double precision, dimension(:), allocatable :: hxir,hetar,hgammar,hpxir,hpetar,hpgammar
  double precision, dimension(:,:), allocatable :: hxir_store,hetar_store,hgammar_store

! 2-D addressing and buffers for summation between slices
  integer, dimension(:), allocatable :: iboolleft_xi_crust_mantle, &
    iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle
  integer, dimension(:), allocatable :: iboolleft_xi_outer_core, &
    iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core
  integer, dimension(:), allocatable :: iboolleft_xi_inner_core, &
    iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core

! for addressing of the slices
  integer, dimension(:,:,:), allocatable :: addressing
  integer, dimension(:), allocatable :: ichunk_slice,iproc_xi_slice,iproc_eta_slice

! indirect arrays for inlined version
  integer ij,ijd,ijk
  integer, dimension(NGLLSQUARE) :: index_fluid_i,index_fluid_k
  integer, dimension(NGLLSQUARE_NDIM) :: index_i,index_k,index_dim

! proc numbers for MPI
  integer myrank,sizeprocs,ier

! number of spectral elements and total number of global points
  integer nspec_crust_mantle,nglob_crust_mantle,nglob_crust_mantle_ndim
  integer nspec_outer_core,nglob_outer_core

  integer npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle
  integer npoin2D_xi_outer_core,npoin2D_eta_outer_core
  integer npoin2D_xi_inner_core,npoin2D_eta_inner_core

  integer ichunk,iproc_xi,iproc_eta,iproc,iproc_read
  integer NPROC_ONE_DIRECTION

! maximum of the norm of the displacement and of the potential in the fluid
  real(kind=CUSTOM_REAL) Usolidnorm,Usolidnorm_all,Ufluidnorm,Ufluidnorm_all

! timer MPI
  integer ihours,iminutes,iseconds,int_tCPU
  double precision time_start,tCPU

! parameters read from parameter file
  integer MIN_ATTENUATION_PERIOD,MAX_ATTENUATION_PERIOD,NER_CRUST,NER_220_MOHO,NER_400_220, &
             NER_600_400,NER_670_600,NER_771_670,NER_TOPDDOUBLEPRIME_771, &
             NER_CMB_TOPDDOUBLEPRIME,NER_ICB_CMB,NER_TOP_CENTRAL_CUBE_ICB, &
             NEX_ETA,NEX_XI,NER_DOUBLING_OUTER_CORE, &
             NPROC_ETA,NPROC_XI,NSEIS,NSTEP

  double precision DT

  logical TRANSVERSE_ISOTROPY,ANISOTROPIC_MANTLE,ANISOTROPIC_INNER_CORE,CRUSTAL,ELLIPTICITY, &
             GRAVITY,ONE_CRUST,ROTATION, &
             THREE_D,TOPOGRAPHY,ATTENUATION,OCEANS, &
             MOVIE_SURFACE,MOVIE_VOLUME
  integer NSOURCES,NMOVIE,NER_ICB_BOTTOMDBL,NER_TOPDBL_CMB
  double precision RATIO_BOTTOM_DBL_OC,RATIO_TOP_DBL_OC,HDUR_MIN_MOVIES

  character(len=150) LOCAL_PATH,clean_LOCAL_PATH,final_LOCAL_PATH,prname

! parameters deduced from parameters read from file
  integer NPROC,NPROCTOT,NEX_PER_PROC_XI,NEX_PER_PROC_ETA
  integer NER,NER_CMB_670,NER_670_400,NER_CENTRAL_CUBE_CMB

! this for all the regions
  integer, dimension(MAX_NUM_REGIONS) :: NSPEC_AB,NSPEC_AC,NSPEC_BC, &
               NSPEC2D_A_XI,NSPEC2D_B_XI,NSPEC2D_C_XI, &
               NSPEC2D_A_ETA,NSPEC2D_B_ETA,NSPEC2D_C_ETA, &
               NSPEC2DMAX_XMIN_XMAX,NSPEC2DMAX_YMIN_YMAX, &
               NSPEC2D_BOTTOM,NSPEC2D_TOP, &
               NSPEC1D_RADIAL,NPOIN1D_RADIAL, &
               NPOIN2DMAX_XMIN_XMAX,NPOIN2DMAX_YMIN_YMAX, &
               NGLOB_AB,NGLOB_AC,NGLOB_BC

! lookup table every km for gravity
  integer int_radius,nspl_gravity,idoubling
  real(kind=CUSTOM_REAL) minus_g_cmb,minus_g_icb
  double precision radius,radius_km,g,dg,rho,vp,vs,Qkappa,Qmu
  double precision g_cmb_dble,g_icb_dble
  double precision, dimension(NRAD_GRAVITY) :: minus_gravity_table, &
    minus_deriv_gravity_table,density_table,minus_rho_g_over_kappa_fluid
  double precision rspl_gravity(NR),gspl(NR),gspl2(NR)

! flags to read kappa and mu and anisotropy arrays in regions where needed
  logical READ_KAPPA_MU,READ_TISO

! dummy value to be used instead of arrays that do not need to be read
  real(kind=CUSTOM_REAL) dummyval

! names of the data files for all the processors in MPI
  character(len=150) outputname

! ************** PROGRAM STARTS HERE **************

! initialize the MPI communicator and start the NPROCTOT MPI processes.
! sizeprocs returns number of processes started
! (should be equal to NPROCTOT if no inner core, NPROCTOT+1 if inner core).
! myrank is the rank of each process, between 0 and sizeprocs-1.
! as usual in MPI, process 0 is in charge of coordinating everything
! and also takes care of the main output
  call MPI_INIT(ier)
  call MPI_COMM_SIZE(MPI_COMM_WORLD,sizeprocs,ier)
  call MPI_COMM_RANK(MPI_COMM_WORLD,myrank,ier)

! read the parameter file
  call read_parameter_file(MIN_ATTENUATION_PERIOD,MAX_ATTENUATION_PERIOD,NER_CRUST,NER_220_MOHO,NER_400_220, &
        NER_600_400,NER_670_600,NER_771_670,NER_TOPDDOUBLEPRIME_771, &
        NER_CMB_TOPDDOUBLEPRIME,NER_ICB_CMB,NER_TOP_CENTRAL_CUBE_ICB,NER_DOUBLING_OUTER_CORE, &
        NEX_ETA,NEX_XI,NPROC_ETA,NPROC_XI,NSEIS,NSTEP, &
        DT,TRANSVERSE_ISOTROPY,ANISOTROPIC_MANTLE,ANISOTROPIC_INNER_CORE,CRUSTAL,OCEANS,ELLIPTICITY, &
        GRAVITY,ONE_CRUST,ATTENUATION, &
        ROTATION,THREE_D,TOPOGRAPHY,LOCAL_PATH,NSOURCES, &
        MOVIE_SURFACE,MOVIE_VOLUME,NMOVIE,HDUR_MIN_MOVIES, &
        NER_ICB_BOTTOMDBL,NER_TOPDBL_CMB,RATIO_BOTTOM_DBL_OC,RATIO_TOP_DBL_OC)

! compute other parameters based upon values read
  call compute_parameters(NER_CRUST,NER_220_MOHO,NER_400_220, &
      NER_600_400,NER_670_600,NER_771_670,NER_TOPDDOUBLEPRIME_771, &
      NER_CMB_TOPDDOUBLEPRIME,NER_ICB_CMB,NER_TOP_CENTRAL_CUBE_ICB, &
      NER,NER_CMB_670,NER_670_400,NER_CENTRAL_CUBE_CMB, &
      NEX_XI,NEX_ETA,NPROC_XI,NPROC_ETA, &
      NPROC,NPROCTOT,NEX_PER_PROC_XI,NEX_PER_PROC_ETA, &
      NSPEC_AB,NSPEC_AC,NSPEC_BC, &
      NSPEC2D_A_XI,NSPEC2D_B_XI,NSPEC2D_C_XI, &
      NSPEC2D_A_ETA,NSPEC2D_B_ETA,NSPEC2D_C_ETA, &
      NSPEC2DMAX_XMIN_XMAX,NSPEC2DMAX_YMIN_YMAX,NSPEC2D_BOTTOM,NSPEC2D_TOP, &
      NSPEC1D_RADIAL,NPOIN1D_RADIAL, &
      NPOIN2DMAX_XMIN_XMAX,NPOIN2DMAX_YMIN_YMAX, &
      NGLOB_AB,NGLOB_AC,NGLOB_BC,NER_ICB_BOTTOMDBL,NER_TOPDBL_CMB)

! open main output file, only written to by process 0
  if(myrank == 0 .and. IMAIN /= ISTANDARD_OUTPUT) &
    open(unit=IMAIN,file='OUTPUT_FILES/output_solver.txt',status='unknown')

  if(myrank == 0) then

  write(IMAIN,*)
  write(IMAIN,*) '******************************'
  write(IMAIN,*) '**** Specfem3D MPI Solver ****'
  write(IMAIN,*) '******************************'
  write(IMAIN,*)
  write(IMAIN,*)

  if(FIX_UNDERFLOW_PROBLEM) write(IMAIN,*) 'Fixing slow underflow trapping problem using small initial field'

  write(IMAIN,*)
  write(IMAIN,*) 'There are ',sizeprocs,' MPI processes'
  write(IMAIN,*) 'Processes are numbered from 0 to ',sizeprocs-1
  write(IMAIN,*)

  write(IMAIN,*) 'There are ',NEX_XI,' elements along xi in each chunk'
  write(IMAIN,*) 'There are ',NEX_ETA,' elements along eta in each chunk'
  write(IMAIN,*)
  write(IMAIN,*) 'There are ',NPROC_XI,' slices along xi in each chunk'
  write(IMAIN,*) 'There are ',NPROC_ETA,' slices along eta in each chunk'
  write(IMAIN,*) 'There is a total of ',NPROC,' slices in each chunk'
  write(IMAIN,*) 'There are ',NCHUNKS,' chunks'
  write(IMAIN,*) 'There is a total of ',NPROCTOT,' slices in all the chunks'

  write(IMAIN,*)
  write(IMAIN,*) 'NDIM = ',NDIM
  write(IMAIN,*)
  write(IMAIN,*) 'NGLLX = ',NGLLX
  write(IMAIN,*) 'NGLLY = ',NGLLY
  write(IMAIN,*) 'NGLLZ = ',NGLLZ
  write(IMAIN,*)

! write information about precision used for floating-point operations
  if(CUSTOM_REAL == SIZE_REAL) then
    write(IMAIN,*) 'using single precision for the calculations'
  else
    write(IMAIN,*) 'using double precision for the calculations'
  endif
  write(IMAIN,*)
  write(IMAIN,*) 'smallest and largest possible floating-point numbers are: ',tiny(1._CUSTOM_REAL),huge(1._CUSTOM_REAL)
  write(IMAIN,*)

  endif

! check that the code is running with the requested nb of processes
  if(sizeprocs /= NPROCTOT) call exit_MPI(myrank,'wrong number of MPI processes')

! check that the inlined code can run
  if(NGLLX /= 5) call exit_MPI(myrank,'inlined code can only run with NGLL = 5')

! check that the code has been compiled with the right values
  if(NSPEC_AB(IREGION_CRUST_MANTLE) /= NSPEC_CRUST_MANTLE_AB .or. &
     NSPEC_AC(IREGION_CRUST_MANTLE) /= NSPEC_CRUST_MANTLE_AC .or. &
     NSPEC_BC(IREGION_CRUST_MANTLE) /= NSPEC_CRUST_MANTLE_BC .or. &
     NSPEC_AB(IREGION_OUTER_CORE) /= nspec_outer_core_AB .or. &
     NSPEC_AC(IREGION_OUTER_CORE) /= nspec_outer_core_AC .or. &
     NSPEC_BC(IREGION_OUTER_CORE) /= nspec_outer_core_BC .or. &
     NSPEC_AB(IREGION_INNER_CORE) /= NSPEC_INNER_CORE) &
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver')

! dynamic allocation of arrays

! indirect addressing for each corner of the chunks
! maximum size is found in the mantle which has the largest number of points
  allocate(iboolcorner_crust_mantle(NPOIN1D_RADIAL(IREGION_CRUST_MANTLE),NUMCORNERS_SHARED))
  allocate(iboolcorner_outer_core(NPOIN1D_RADIAL(IREGION_OUTER_CORE),NUMCORNERS_SHARED))
  allocate(iboolcorner_inner_core(NPOIN1D_RADIAL(IREGION_INNER_CORE),NUMCORNERS_SHARED))

! buffers for send and receive between corners of the chunks
  allocate(buffer_send_chunk_corners(NDIM,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE)))
  allocate(buffer_received_chunk_corners(NDIM,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE)))

! 2-D addressing and buffers for summation between slices, and point codes
! use number of elements found in the mantle since it is the largest region

! crust and mantle
  allocate(iboolleft_xi_crust_mantle(NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(iboolright_xi_crust_mantle(NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(iboolleft_eta_crust_mantle(NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(iboolright_eta_crust_mantle(NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))

! outer core
  allocate(iboolleft_xi_outer_core(NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(iboolright_xi_outer_core(NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(iboolleft_eta_outer_core(NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(iboolright_eta_outer_core(NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))

! inner core
  allocate(iboolleft_xi_inner_core(NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE)))
  allocate(iboolright_xi_inner_core(NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE)))
  allocate(iboolleft_eta_inner_core(NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE)))
  allocate(iboolright_eta_inner_core(NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE)))

! for addressing of the slices
  allocate(addressing(NCHUNKS,0:NPROC_XI-1,0:NPROC_ETA-1))
  allocate(ichunk_slice(0:NPROCTOT-1))
  allocate(iproc_xi_slice(0:NPROCTOT-1))
  allocate(iproc_eta_slice(0:NPROCTOT-1))

! open file with global slice number addressing
  open(unit=IIN,file='OUTPUT_FILES/addressing.txt',status='old')
  do iproc = 0,NPROCTOT-1
    read(IIN,*) iproc_read,ichunk,iproc_xi,iproc_eta
    if(iproc_read /= iproc) call exit_MPI(myrank,'incorrect slice number read')
    addressing(ichunk,iproc_xi,iproc_eta) = iproc
    ichunk_slice(iproc) = ichunk
    iproc_xi_slice(iproc) = iproc_xi
    iproc_eta_slice(iproc) = iproc_eta
  enddo
  close(IIN)

! determine chunk number and local slice coordinates using addressing
  ichunk = ichunk_slice(myrank)
  iproc_xi = iproc_xi_slice(myrank)
  iproc_eta = iproc_eta_slice(myrank)

! check chunk number and assign theoretical number of elements
  if(ichunk == CHUNK_AB .or. ichunk == CHUNK_AB_ANTIPODE) then
    nspec_crust_mantle = NSPEC_AB(IREGION_CRUST_MANTLE)
    nglob_crust_mantle = NGLOB_AB(IREGION_CRUST_MANTLE)
    nspec_outer_core = NSPEC_AB(IREGION_OUTER_CORE)
    nglob_outer_core = NGLOB_AB(IREGION_OUTER_CORE)
  else if(ichunk == CHUNK_AC .or. ichunk == CHUNK_AC_ANTIPODE) then
    nspec_crust_mantle = NSPEC_AC(IREGION_CRUST_MANTLE)
    nglob_crust_mantle = NGLOB_AC(IREGION_CRUST_MANTLE)
    nspec_outer_core = NSPEC_AC(IREGION_OUTER_CORE)
    nglob_outer_core = NGLOB_AC(IREGION_OUTER_CORE)
  else if(ichunk == CHUNK_BC .or. ichunk == CHUNK_BC_ANTIPODE) then
    nspec_crust_mantle = NSPEC_BC(IREGION_CRUST_MANTLE)
    nglob_crust_mantle = NGLOB_BC(IREGION_CRUST_MANTLE)
    nspec_outer_core = NSPEC_BC(IREGION_OUTER_CORE)
    nglob_outer_core = NGLOB_BC(IREGION_OUTER_CORE)
  else
    call exit_MPI(myrank,'incorrect chunk number')
  endif

! make ellipticity
  if(ELLIPTICITY) then
    call make_ellipticity(nspl,rspl,espl,espl2,ONE_CRUST)

! compute ellipticity at d80 once and for all for attenuation
    radius = R80/R_EARTH
    call splint(rspl,espl,espl2,nspl,radius,ell_d80_dble)

! distinguish whether single or double precision for reals
    if(CUSTOM_REAL == SIZE_REAL) then
      ell_d80 = sngl(ell_d80_dble)
    else
      ell_d80 = ell_d80_dble
    endif

  endif

! define maximum size for message buffers
! use number of elements found in the mantle since it is the largest region
  NPOIN2DMAX_XY = max(NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE))

! allocate arrays for message buffers with maximum size

  allocate(iboolfaces_crust_mantle(NPOIN2DMAX_XY,NUMFACES_SHARED))
  allocate(iboolfaces_outer_core(NPOIN2DMAX_XY,NUMFACES_SHARED))
  allocate(iboolfaces_inner_core(NPOIN2DMAX_XY,NUMFACES_SHARED))

  allocate(buffer_send_faces(NDIM,NPOIN2DMAX_XY))
  allocate(buffer_received_faces(NDIM,NPOIN2DMAX_XY))

! number of corners shared between chunks
  if(NCHUNKS == 1 .or. NCHUNKS == 3) then
    NCORNERSCHUNKS = 1
  else if(NCHUNKS == 6) then
    NCORNERSCHUNKS = 8
  else
    call exit_MPI(myrank,'number of chunks must be either 1, 3 or 6')
  endif

! number of faces shared between chunks
  if(NCHUNKS == 1 .or. NCHUNKS == 3) then
    NUM_FACES = 1
  else if(NCHUNKS == 6) then
    NUM_FACES = 4
  else
    call exit_MPI(myrank,'can only use 1, 3 or 6 chunks')
  endif

! if more than one chunk then same number of processors in each direction
  NPROC_ONE_DIRECTION = NPROC_XI

! total number of messages corresponding to these common faces
  NUMMSGS_FACES = NPROC_ONE_DIRECTION*NUM_FACES*3

! allocate array for messages for faces
  allocate(iprocfrom_faces(NUMMSGS_FACES))
  allocate(iprocto_faces(NUMMSGS_FACES))
  allocate(imsg_type(NUMMSGS_FACES))

! allocate array for messages for corners
  allocate(iproc_master_corners(NCORNERSCHUNKS))
  allocate(iproc_slave1_corners(NCORNERSCHUNKS))
  allocate(iproc_slave2_corners(NCORNERSCHUNKS))

! start reading the databases

! read arrays created by the mesher

! crust and mantle

  if(ANISOTROPIC_MANTLE) then
    READ_KAPPA_MU = .false.
    READ_TISO = .false.
    nspec_iso = 1
    nspec_tiso = 1
    nspec_ani = nspec_crust_mantle
  else
    nspec_iso = nspec_crust_mantle
    if(TRANSVERSE_ISOTROPY) then
      nspec_tiso = NSPECMAX_TISO_MANTLE
    else
      nspec_tiso = 1
    endif
    nspec_ani = 1
    READ_KAPPA_MU = .true.
    READ_TISO = .true.
  endif
  call read_arrays_solver(IREGION_CRUST_MANTLE,myrank, &
            rho_vp_crust_mantle,rho_vs_crust_mantle, &
            xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
            xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle, &
            etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
            gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,jacobian_crust_mantle, &
            kappavstore_crust_mantle,muvstore_crust_mantle, &
            kappahstore_crust_mantle,muhstore_crust_mantle,eta_anisostore_crust_mantle, &
            nspec_iso,nspec_tiso,nspec_ani, &
            c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle, &
            c14store_crust_mantle,c15store_crust_mantle,c16store_crust_mantle, &
            c22store_crust_mantle,c23store_crust_mantle,c24store_crust_mantle, &
            c25store_crust_mantle,c26store_crust_mantle,c33store_crust_mantle, &
            c34store_crust_mantle,c35store_crust_mantle,c36store_crust_mantle, &
            c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
            c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
            ibool_crust_mantle,idoubling_crust_mantle,rmass_crust_mantle,rmass_ocean_load, &
            nspec_crust_mantle,nglob_crust_mantle, &
            READ_KAPPA_MU,READ_TISO, &
            TRANSVERSE_ISOTROPY,ANISOTROPIC_MANTLE,ANISOTROPIC_INNER_CORE,OCEANS,LOCAL_PATH)

! outer core (no anisotropy nor S velocity)
! rmass_ocean_load is not modified in routine
  READ_KAPPA_MU = .false.
  READ_TISO = .false.
  nspec_iso = 1
  nspec_tiso = 1
  nspec_ani = 1
  call read_arrays_solver(IREGION_OUTER_CORE,myrank, &
            vp_outer_core,dummyval, &
            xstore_outer_core,ystore_outer_core,zstore_outer_core, &
            xix_outer_core,xiy_outer_core,xiz_outer_core, &
            etax_outer_core,etay_outer_core,etaz_outer_core, &
            gammax_outer_core,gammay_outer_core,gammaz_outer_core,jacobian_outer_core, &
            dummyval,dummyval, &
            dummyval,dummyval,dummyval, &
            nspec_iso,nspec_tiso,nspec_ani, &
            dummyval,dummyval,dummyval,dummyval,dummyval,dummyval,dummyval, &
            dummyval,dummyval,dummyval,dummyval,dummyval,dummyval,dummyval, &
            dummyval,dummyval,dummyval,dummyval,dummyval,dummyval,dummyval, &
            ibool_outer_core,idoubling_outer_core,rmass_outer_core,rmass_ocean_load, &
            nspec_outer_core,nglob_outer_core, &
            READ_KAPPA_MU,READ_TISO, &
            TRANSVERSE_ISOTROPY,ANISOTROPIC_MANTLE,ANISOTROPIC_INNER_CORE,OCEANS,LOCAL_PATH)

! inner core (no anisotropy)
! rmass_ocean_load is not modified in routine
  READ_KAPPA_MU = .true.
  READ_TISO = .false.
  nspec_iso = NSPEC_INNER_CORE
  nspec_tiso = 1
  if(ANISOTROPIC_INNER_CORE) then
    nspec_ani = NSPEC_INNER_CORE
  else
    nspec_ani = 1
  endif
  call read_arrays_solver(IREGION_INNER_CORE,myrank, &
            dummyval,dummyval, &
            xstore_inner_core,ystore_inner_core,zstore_inner_core, &
            xix_inner_core,xiy_inner_core,xiz_inner_core, &
            etax_inner_core,etay_inner_core,etaz_inner_core, &
            gammax_inner_core,gammay_inner_core,gammaz_inner_core,jacobian_inner_core, &
            kappavstore_inner_core,muvstore_inner_core, &
            dummyval,dummyval,dummyval, &
            nspec_iso,nspec_tiso,nspec_ani, &
            c11store_inner_core,c12store_inner_core,c13store_inner_core,dummyval,dummyval,dummyval,dummyval, &
            dummyval,dummyval,dummyval,dummyval,c33store_inner_core,dummyval,dummyval, &
            dummyval,c44store_inner_core,dummyval,dummyval,dummyval,dummyval,dummyval, &
            ibool_inner_core,idoubling_inner_core,rmass_inner_core,rmass_ocean_load, &
            NSPEC_INNER_CORE,NGLOB_INNER_CORE, &
            READ_KAPPA_MU,READ_TISO, &
            TRANSVERSE_ISOTROPY,ANISOTROPIC_MANTLE,ANISOTROPIC_INNER_CORE,OCEANS,LOCAL_PATH)

! check that the number of points in this slice is correct

  if(minval(ibool_crust_mantle(:,:,:,1:nspec_crust_mantle)) /= 1 .or. &
    maxval(ibool_crust_mantle(:,:,:,1:nspec_crust_mantle)) /= nglob_crust_mantle) &
      call exit_MPI(myrank,'incorrect global numbering: iboolmax does not equal nglob in crust and mantle')

  if(minval(ibool_outer_core(:,:,:,1:nspec_outer_core)) /= 1 .or. &
     maxval(ibool_outer_core(:,:,:,1:nspec_outer_core)) /= nglob_outer_core) &
    call exit_MPI(myrank,'incorrect global numbering: iboolmax does not equal nglob in outer core')

  if(minval(ibool_inner_core(:,:,:,:)) /= 1 .or. maxval(ibool_inner_core(:,:,:,:)) /= NGLOB_INNER_CORE) &
    call exit_MPI(myrank,'incorrect global numbering: iboolmax does not equal nglob in inner core')

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

! set up GLL points, weights and derivation matrices
  call define_derivation_matrices(xigll,yigll,zigll,wxgll,wygll,wzgll, &
         hprime_xx,hprime_yy,hprime_zz, &
         hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
         wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube)

! expand 2D weights for inlined version
  do k=1,NGLLZ
    do j=1,NGLLY
      do i=1,NGLLX
        do idimension=1,NDIM
          wgllwgll_yz_no_i(idimension,i,j,k) = wgllwgll_yz(j,k)
          wgllwgll_xz_no_j(idimension,i,j,k) = wgllwgll_xz(i,k)
          wgllwgll_xy_no_k(idimension,i,j,k) = wgllwgll_xy(i,j)
        enddo
      enddo
    enddo
  enddo

! read topography and bathymetry file
  if(TOPOGRAPHY .or. OCEANS) call read_topo_bathy_file(ibathy_topo)

! allocate arrays for source
  allocate(sourcearray(NDIM,NGLLX,NGLLY,NGLLZ))
  allocate(sourcearrays(NSOURCES,NDIM,NGLLX,NGLLY,NGLLZ))
  allocate(islice_selected_source(NSOURCES))
  allocate(ispec_selected_source(NSOURCES))
  allocate(Mxx(NSOURCES))
  allocate(Myy(NSOURCES))
  allocate(Mzz(NSOURCES))
  allocate(Mxy(NSOURCES))
  allocate(Mxz(NSOURCES))
  allocate(Myz(NSOURCES))
  allocate(xi_source(NSOURCES))
  allocate(eta_source(NSOURCES))
  allocate(gamma_source(NSOURCES))
  allocate(t_cmt(NSOURCES))
  allocate(hdur(NSOURCES))
  allocate(theta_source(NSOURCES))
  allocate(phi_source(NSOURCES))

! locate sources in the mesh
  call locate_source(NSOURCES,myrank,nspec_crust_mantle, &
            nglob_crust_mantle,idoubling_crust_mantle,ibool_crust_mantle, &
            xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
            xigll,yigll,zigll,NPROCTOT,ELLIPTICITY,TOPOGRAPHY, &
            sec,t_cmt,yr,jda,ho,mi,theta_source,phi_source, &
            NSTEP,DT,hdur,Mxx,Myy,Mzz,Mxy,Mxz,Myz, &
            islice_selected_source,ispec_selected_source, &
            xi_source,eta_source,gamma_source, &
            rspl,espl,espl2,nspl,ibathy_topo,NEX_XI)

  if(t_cmt(1) /= 0.) call exit_MPI(myrank,'t_cmt for the first source should be zero')
  do isource = 2,NSOURCES
    if(t_cmt(isource) < 0.) call exit_MPI(myrank,'t_cmt should not be less than zero')
  enddo

  open(unit=IIN,file='DATA/STATIONS',status='old')
  read(IIN,*) nrec
  close(IIN)

  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'Total number of receivers = ',nrec
    write(IMAIN,*)
  endif

  if(nrec < 1) call exit_MPI(myrank,'need at least one receiver')

! allocate memory for receiver arrays
  allocate(islice_selected_rec(nrec))
  allocate(ispec_selected_rec(nrec))
  allocate(xi_receiver(nrec))
  allocate(eta_receiver(nrec))
  allocate(gamma_receiver(nrec))
  allocate(station_name(nrec))
  allocate(network_name(nrec))
  allocate(nu(NDIM,NDIM,nrec))

! locate receivers in the crust in the mesh
  call locate_receivers(myrank,DT,NSTEP,nspec_crust_mantle, &
            nglob_crust_mantle,idoubling_crust_mantle,ibool_crust_mantle, &
            xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
            xigll,yigll,nrec,islice_selected_rec,ispec_selected_rec, &
            xi_receiver,eta_receiver,gamma_receiver,station_name,network_name,nu, &
            yr,jda,ho,mi,sec,NPROCTOT,ELLIPTICITY,TOPOGRAPHY, &
            theta_source(1),phi_source(1),rspl,espl,espl2,nspl,ibathy_topo)

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

! read 2-D addressing for summation between slices with MPI

! mantle and crust
  call read_arrays_buffers_solver(IREGION_CRUST_MANTLE,myrank,iboolleft_xi_crust_mantle, &
     iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
     npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
     iprocfrom_faces,iprocto_faces,imsg_type, &
     iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
     iboolfaces_crust_mantle,npoin2D_faces_crust_mantle, &
     iboolcorner_crust_mantle, &
     NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE), &
     NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_XY,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE), &
     NUMMSGS_FACES,NCORNERSCHUNKS,NPROCTOT,NPROC_XI,NPROC_ETA,LOCAL_PATH)

! outer core
  call read_arrays_buffers_solver(IREGION_OUTER_CORE,myrank, &
     iboolleft_xi_outer_core,iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core, &
     npoin2D_xi_outer_core,npoin2D_eta_outer_core, &
     iprocfrom_faces,iprocto_faces,imsg_type, &
     iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
     iboolfaces_outer_core,npoin2D_faces_outer_core, &
     iboolcorner_outer_core, &
     NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE), &
     NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE),NPOIN2DMAX_XY,NPOIN1D_RADIAL(IREGION_OUTER_CORE), &
     NUMMSGS_FACES,NCORNERSCHUNKS,NPROCTOT,NPROC_XI,NPROC_ETA,LOCAL_PATH)

! inner core
  call read_arrays_buffers_solver(IREGION_INNER_CORE,myrank, &
     iboolleft_xi_inner_core,iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core, &
     npoin2D_xi_inner_core,npoin2D_eta_inner_core, &
     iprocfrom_faces,iprocto_faces,imsg_type, &
     iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
     iboolfaces_inner_core,npoin2D_faces_inner_core, &
     iboolcorner_inner_core, &
     NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE), &
     NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE),NPOIN2DMAX_XY,NPOIN1D_RADIAL(IREGION_INNER_CORE), &
     NUMMSGS_FACES,NCORNERSCHUNKS,NPROCTOT,NPROC_XI,NPROC_ETA,LOCAL_PATH)

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

  if(myrank == 0) then
    write(IMAIN,*) '**************************************************'
    write(IMAIN,*) 'There are ',NEX_XI,' elements along xi in each chunk'
    write(IMAIN,*) 'There are ',NEX_ETA,' elements along eta in each chunk'
    write(IMAIN,*)
    write(IMAIN,*) 'There are ',NPROC_XI,' slices along xi in each chunk'
    write(IMAIN,*) 'There are ',NPROC_ETA,' slices along eta in each chunk'
    write(IMAIN,*) 'There is a total of ',NPROC,' slices in each chunk'
    write(IMAIN,*) '**************************************************'
    write(IMAIN,*)
  endif

! allocate 1-D Lagrange interpolators and derivatives
  allocate(hxir(NGLLX))
  allocate(hpxir(NGLLX))
  allocate(hetar(NGLLY))
  allocate(hpetar(NGLLY))
  allocate(hgammar(NGLLZ))
  allocate(hpgammar(NGLLZ))

! to couple mantle with outer core

! create name of database
  call create_name_database(prname,myrank,IREGION_CRUST_MANTLE,LOCAL_PATH)

! dynamic allocation of arrays

! boundary parameters locator
  allocate(ibelm_xmin_crust_mantle(NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(ibelm_xmax_crust_mantle(NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(ibelm_ymin_crust_mantle(NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(ibelm_ymax_crust_mantle(NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(ibelm_bottom_crust_mantle(NSPEC2D_BOTTOM(IREGION_CRUST_MANTLE)))
  allocate(ibelm_top_crust_mantle(NSPEC2D_TOP(IREGION_CRUST_MANTLE)))

  allocate(jacobian2D_xmin_crust_mantle(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(jacobian2D_xmax_crust_mantle(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(jacobian2D_ymin_crust_mantle(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(jacobian2D_ymax_crust_mantle(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(jacobian2D_bottom_crust_mantle(NGLLX,NGLLY,NSPEC2D_BOTTOM(IREGION_CRUST_MANTLE)))
  allocate(jacobian2D_top_crust_mantle(NGLLX,NGLLY,NSPEC2D_TOP(IREGION_CRUST_MANTLE)))

! normals
  allocate(normal_xmin_crust_mantle(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(normal_xmax_crust_mantle(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(normal_ymin_crust_mantle(NDIM,NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(normal_ymax_crust_mantle(NDIM,NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(normal_bottom_crust_mantle(NDIM,NGLLX,NGLLY,NSPEC2D_BOTTOM(IREGION_CRUST_MANTLE)))
  allocate(normal_top_crust_mantle(NDIM,NGLLX,NGLLY,NSPEC2D_TOP(IREGION_CRUST_MANTLE)))

! Stacey
  allocate(nimin_crust_mantle(2,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(nimax_crust_mantle(2,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(njmin_crust_mantle(2,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(njmax_crust_mantle(2,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(nkmin_xi_crust_mantle(2,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(nkmin_eta_crust_mantle(2,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))

! boundary parameters
  open(unit=27,file=prname(1:len_trim(prname))//'ibelm.bin',status='old',form='unformatted')
  read(27) ibelm_xmin_crust_mantle
  read(27) ibelm_xmax_crust_mantle
  read(27) ibelm_ymin_crust_mantle
  read(27) ibelm_ymax_crust_mantle
  read(27) ibelm_bottom_crust_mantle
  read(27) ibelm_top_crust_mantle
  close(27)

  open(unit=27,file=prname(1:len_trim(prname))//'normal.bin',status='old',form='unformatted')
  read(27) normal_xmin_crust_mantle
  read(27) normal_xmax_crust_mantle
  read(27) normal_ymin_crust_mantle
  read(27) normal_ymax_crust_mantle
  read(27) normal_bottom_crust_mantle
  read(27) normal_top_crust_mantle
  close(27)

  open(unit=27,file=prname(1:len_trim(prname))//'jacobian2D.bin',status='old',form='unformatted')
  read(27) jacobian2D_xmin_crust_mantle
  read(27) jacobian2D_xmax_crust_mantle
  read(27) jacobian2D_ymin_crust_mantle
  read(27) jacobian2D_ymax_crust_mantle
  read(27) jacobian2D_bottom_crust_mantle
  read(27) jacobian2D_top_crust_mantle
  close(27)

! Stacey put back
  open(unit=27,file=prname(1:len_trim(prname))//'nspec2D.bin',status='unknown',form='unformatted')
  read(27) nspec2D_xmin_crust_mantle
  read(27) nspec2D_xmax_crust_mantle
  read(27) nspec2D_ymin_crust_mantle
  read(27) nspec2D_ymax_crust_mantle
  close(27)

! read arrays for Stacey conditions

  if(STACEY_ABS_CONDITIONS) then
      open(unit=27,file=prname(1:len_trim(prname))//'nimin.bin',status='unknown',form='unformatted')
      read(27) nimin_crust_mantle
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nimax.bin',status='unknown',form='unformatted')
      read(27) nimax_crust_mantle
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'njmin.bin',status='unknown',form='unformatted')
      read(27) njmin_crust_mantle
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'njmax.bin',status='unknown',form='unformatted')
      read(27) njmax_crust_mantle
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nkmin_xi.bin',status='unknown',form='unformatted')
      read(27) nkmin_xi_crust_mantle
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nkmin_eta.bin',status='unknown',form='unformatted')
      read(27) nkmin_eta_crust_mantle
      close(27)
  endif

! read parameters to couple fluid and solid regions

!
!---- outer core
!

! create name of database
  call create_name_database(prname,myrank,IREGION_OUTER_CORE,LOCAL_PATH)

! dynamic allocation of arrays

! boundary parameters locator
  allocate(ibelm_xmin_outer_core(NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(ibelm_xmax_outer_core(NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(ibelm_ymin_outer_core(NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(ibelm_ymax_outer_core(NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(ibelm_bottom_outer_core(NSPEC2D_BOTTOM(IREGION_OUTER_CORE)))
  allocate(ibelm_top_outer_core(NSPEC2D_TOP(IREGION_OUTER_CORE)))

! normals
  allocate(normal_xmin_outer_core(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(normal_xmax_outer_core(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(normal_ymin_outer_core(NDIM,NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(normal_ymax_outer_core(NDIM,NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(normal_bottom_outer_core(NDIM,NGLLX,NGLLY,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)))
  allocate(normal_top_outer_core(NDIM,NGLLX,NGLLY,NSPEC2D_TOP(IREGION_OUTER_CORE)))

! jacobian on 2D edges
  allocate(jacobian2D_xmin_outer_core(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(jacobian2D_xmax_outer_core(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(jacobian2D_ymin_outer_core(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(jacobian2D_ymax_outer_core(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(jacobian2D_bottom_outer_core(NGLLX,NGLLY,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)))
  allocate(jacobian2D_top_outer_core(NGLLX,NGLLY,NSPEC2D_TOP(IREGION_OUTER_CORE)))

! Stacey
  allocate(nimin_outer_core(2,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(nimax_outer_core(2,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(njmin_outer_core(2,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(njmax_outer_core(2,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(nkmin_xi_outer_core(2,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(nkmin_eta_outer_core(2,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))

! boundary parameters
  open(unit=27,file=prname(1:len_trim(prname))//'ibelm.bin',status='old',form='unformatted')
  read(27) ibelm_xmin_outer_core
  read(27) ibelm_xmax_outer_core
  read(27) ibelm_ymin_outer_core
  read(27) ibelm_ymax_outer_core
  read(27) ibelm_bottom_outer_core
  read(27) ibelm_top_outer_core
  close(27)

  open(unit=27,file=prname(1:len_trim(prname))//'normal.bin',status='old',form='unformatted')
  read(27) normal_xmin_outer_core
  read(27) normal_xmax_outer_core
  read(27) normal_ymin_outer_core
  read(27) normal_ymax_outer_core
  read(27) normal_bottom_outer_core
  read(27) normal_top_outer_core
  close(27)

  open(unit=27,file=prname(1:len_trim(prname))//'jacobian2D.bin',status='old',form='unformatted')
  read(27) jacobian2D_xmin_outer_core
  read(27) jacobian2D_xmax_outer_core
  read(27) jacobian2D_ymin_outer_core
  read(27) jacobian2D_ymax_outer_core
  read(27) jacobian2D_bottom_outer_core
  read(27) jacobian2D_top_outer_core
  close(27)

! Stacey put back
  open(unit=27,file=prname(1:len_trim(prname))//'nspec2D.bin',status='unknown',form='unformatted')
  read(27) nspec2D_xmin_outer_core
  read(27) nspec2D_xmax_outer_core
  read(27) nspec2D_ymin_outer_core
  read(27) nspec2D_ymax_outer_core
  close(27)

! read arrays for Stacey conditions

  if(STACEY_ABS_CONDITIONS) then
      open(unit=27,file=prname(1:len_trim(prname))//'nimin.bin',status='unknown',form='unformatted')
      read(27) nimin_outer_core
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nimax.bin',status='unknown',form='unformatted')
      read(27) nimax_outer_core
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'njmin.bin',status='unknown',form='unformatted')
      read(27) njmin_outer_core
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'njmax.bin',status='unknown',form='unformatted')
      read(27) njmax_outer_core
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nkmin_xi.bin',status='unknown',form='unformatted')
      read(27) nkmin_xi_outer_core
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nkmin_eta.bin',status='unknown',form='unformatted')
      read(27) nkmin_eta_outer_core
      close(27)
  endif

!
!---- inner core
!

! create name of database
  call create_name_database(prname,myrank,IREGION_INNER_CORE,LOCAL_PATH)

! dynamic allocation of arrays

! boundary parameters locator
  allocate(ibelm_xmin_inner_core(NSPEC2DMAX_XMIN_XMAX(IREGION_INNER_CORE)))
  allocate(ibelm_xmax_inner_core(NSPEC2DMAX_XMIN_XMAX(IREGION_INNER_CORE)))
  allocate(ibelm_ymin_inner_core(NSPEC2DMAX_YMIN_YMAX(IREGION_INNER_CORE)))
  allocate(ibelm_ymax_inner_core(NSPEC2DMAX_YMIN_YMAX(IREGION_INNER_CORE)))
  allocate(ibelm_bottom_inner_core(NSPEC2D_BOTTOM(IREGION_INNER_CORE)))
  allocate(ibelm_top_inner_core(NSPEC2D_TOP(IREGION_INNER_CORE)))

! boundary parameters
  open(unit=27,file=prname(1:len_trim(prname))//'ibelm.bin',status='old',form='unformatted')
  read(27) ibelm_xmin_inner_core
  read(27) ibelm_xmax_inner_core
  read(27) ibelm_ymin_inner_core
  read(27) ibelm_ymax_inner_core
  read(27) ibelm_bottom_inner_core
  read(27) ibelm_top_inner_core
  close(27)

! read info for vertical edges for central cube matching in inner core
  open(unit=27,file=prname(1:len_trim(prname))//'nspec2D.bin',status='old',form='unformatted')
  read(27) nspec2D_xmin_inner_core
  read(27) nspec2D_xmax_inner_core
  read(27) nspec2D_ymin_inner_core
  read(27) nspec2D_ymax_inner_core
  close(27)

  do isource = 1,NSOURCES

!   check that the source slice number is okay
    if(islice_selected_source(isource) < 0 .or. islice_selected_source(isource) > NPROCTOT-1) &
      call exit_MPI(myrank,'something is wrong with the source slice number')

!   compute source arrays in source slice
    if(myrank == islice_selected_source(isource)) then
      call compute_arrays_source(ispec_selected_source(isource), &
             xi_source(isource),eta_source(isource),gamma_source(isource),sourcearray, &
             Mxx(isource),Myy(isource),Mzz(isource),Mxy(isource),Mxz(isource),Myz(isource), &
             xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle, &
             etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
             gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle, &
             xigll,yigll,zigll,nspec_crust_mantle)
      sourcearrays(isource,:,:,:,:) = sourcearray(:,:,:,:)
    endif

  enddo

  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'Total number of samples for seismograms = ',NSTEP
    write(IMAIN,*)
  endif

!--- select local receivers

! count number of receivers located in this slice
  nrec_local = 0

  do irec = 1,nrec

! check that the receiver slice number is okay
  if(islice_selected_rec(irec) < 0 .or. islice_selected_rec(irec) > NPROCTOT-1) &
    call exit_MPI(myrank,'something is wrong with the receiver slice number')

! write info about that receiver
  if(myrank == islice_selected_rec(irec)) then

    nrec_local = nrec_local + 1

  endif

  enddo

! allocate seismogram array
  allocate(seismograms(NDIM,nrec_local,NSTEP))

! allocate Lagrange interpolators for receivers
  allocate(hxir_store(nrec_local,NGLLX))
  allocate(hetar_store(nrec_local,NGLLY))
  allocate(hgammar_store(nrec_local,NGLLZ))
  allocate(hlagrange(nrec_local,NGLLX,NGLLY,NGLLZ))

! define local to global receiver numbering mapping
  allocate(number_receiver_global(nrec_local))
  irec_local = 0
  do irec = 1,nrec
    if(myrank == islice_selected_rec(irec)) then
      irec_local = irec_local + 1
      number_receiver_global(irec_local) = irec
    endif
  enddo

! define and store Lagrange interpolators at all the receivers
  do irec_local = 1,nrec_local
    irec = number_receiver_global(irec_local)
    call lagrange_any(xi_receiver(irec),NGLLX,xigll,hxir,hpxir)
    call lagrange_any(eta_receiver(irec),NGLLY,yigll,hetar,hpetar)
    call lagrange_any(gamma_receiver(irec),NGLLZ,zigll,hgammar,hpgammar)
    hxir_store(irec_local,:) = hxir(:)
    hetar_store(irec_local,:) = hetar(:)
    hgammar_store(irec_local,:) = hgammar(:)
  enddo

! check that the sum of the number of receivers in each slice is nrec
  call MPI_REDUCE(nrec_local,nrec_tot_found,1,MPI_INTEGER,MPI_SUM,0, &
                          MPI_COMM_WORLD,ier)
  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'found a total of ',nrec_tot_found,' receivers in all the slices'
    if(nrec_tot_found /= nrec) then
      call exit_MPI(myrank,'problem when dispatching the receivers')
    else
      write(IMAIN,*) 'this total is okay'
    endif
  endif

! initialize seismograms
  seismograms(:,:,:) = 0._CUSTOM_REAL

  if(myrank == 0) then

  write(IMAIN,*)
  write(IMAIN,*) 'Reference radius of the Earth used is ',R_EARTH_KM,' km'
  write(IMAIN,*)

  if(NSOURCES > 1) write(IMAIN,*) 'Using ',NSOURCES,' point sources'

  write(IMAIN,*)
  if(ELLIPTICITY) then
    write(IMAIN,*) 'incorporating ellipticity'
  else
    write(IMAIN,*) 'no ellipticity'
  endif

  write(IMAIN,*)
  if(TOPOGRAPHY) then
    write(IMAIN,*) 'incorporating surface topography'
  else
    write(IMAIN,*) 'no surface topography'
  endif

  write(IMAIN,*)
  if(THREE_D) then
    write(IMAIN,*) 'incorporating 3-D lateral variations'
  else
    write(IMAIN,*) 'no 3-D lateral variations'
  endif

  write(IMAIN,*)
  if(CRUSTAL) then
    write(IMAIN,*) 'incorporating crustal variations'
  else
    write(IMAIN,*) 'no crustal variations'
  endif

  write(IMAIN,*)
  if(ONE_CRUST) then
    write(IMAIN,*) 'using one layer only in PREM crust'
  else
    write(IMAIN,*) 'using real PREM crust with two layers'
  endif

  write(IMAIN,*)
  if(GRAVITY) then
    write(IMAIN,*) 'incorporating self-gravitation (Cowling approximation)'
  else
    write(IMAIN,*) 'no self-gravitation'
  endif

  write(IMAIN,*)
  if(ROTATION) then
    write(IMAIN,*) 'incorporating rotation'
  else
    write(IMAIN,*) 'no rotation'
  endif

  write(IMAIN,*)
  if(TRANSVERSE_ISOTROPY) then
    write(IMAIN,*) 'incorporating transverse isotropy'
  else
    write(IMAIN,*) 'no transverse isotropy'
  endif

  write(IMAIN,*)
  if(ATTENUATION) then
    write(IMAIN,*) 'incorporating attenuation using ',N_SLS,' standard linear solids'
  else
    write(IMAIN,*) 'no attenuation'
  endif

  write(IMAIN,*)
  if(OCEANS) then
    write(IMAIN,*) 'incorporating the oceans using equivalent load'
  else
    write(IMAIN,*) 'no oceans'
  endif

  write(IMAIN,*)
  if(ANISOTROPIC_INNER_CORE) then
    write(IMAIN,*) 'incorporating anisotropic inner core'
  else
    write(IMAIN,*) 'no inner-core anisotropy'
  endif

  write(IMAIN,*)
  if(ANISOTROPIC_MANTLE) then
    write(IMAIN,*) 'incorporating anisotropic mantle'
  else
    write(IMAIN,*) 'no general mantle anisotropy'
  endif
  write(IMAIN,*)
  write(IMAIN,*)

  endif

! synchronize all the processes before assembling the mass matrix
! to make sure all the nodes have finished to read their databases
  call MPI_BARRIER(MPI_COMM_WORLD,ier)

! the mass matrix needs to be assembled with MPI here once and for all

! ocean load
  call assemble_MPI_scalar(myrank,rmass_ocean_load,nglob_crust_mantle, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_crust_mantle,iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
            npoin2D_faces_crust_mantle,npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
            iboolfaces_crust_mantle,iboolcorner_crust_mantle, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
            buffer_send_faces,buffer_received_faces, &
            buffer_send_chunk_corners,buffer_received_chunk_corners, &
            NUMMSGS_FACES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_XY)

! crust and mantle
  call assemble_MPI_scalar(myrank,rmass_crust_mantle,nglob_crust_mantle, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_crust_mantle,iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
            npoin2D_faces_crust_mantle,npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
            iboolfaces_crust_mantle,iboolcorner_crust_mantle, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
            buffer_send_faces,buffer_received_faces, &
            buffer_send_chunk_corners,buffer_received_chunk_corners, &
            NUMMSGS_FACES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_XY)

! outer core
  call assemble_MPI_scalar(myrank,rmass_outer_core,nglob_outer_core, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_outer_core,iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core, &
            npoin2D_faces_outer_core,npoin2D_xi_outer_core,npoin2D_eta_outer_core, &
            iboolfaces_outer_core,iboolcorner_outer_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
            buffer_send_faces,buffer_received_faces, &
            buffer_send_chunk_corners,buffer_received_chunk_corners, &
            NUMMSGS_FACES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_OUTER_CORE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE),NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE),NPOIN2DMAX_XY)

! inner core
  call assemble_MPI_scalar(myrank,rmass_inner_core,NGLOB_INNER_CORE, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_inner_core,iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core, &
            npoin2D_faces_inner_core,npoin2D_xi_inner_core,npoin2D_eta_inner_core, &
            iboolfaces_inner_core,iboolcorner_inner_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
            buffer_send_faces,buffer_received_faces, &
            buffer_send_chunk_corners,buffer_received_chunk_corners, &
            NUMMSGS_FACES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_INNER_CORE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE),NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE),NPOIN2DMAX_XY)

  if(myrank == 0) write(IMAIN,*) 'end assembling MPI mass matrix'

!
!--- create buffers to assemble with central cube
!

  if(INCLUDE_CENTRAL_CUBE) then

!--- number of messages to expect in cube
!--- take into account vertical sides and bottom side

! only for slices in central cube
  if(ichunk == CHUNK_AB) then
    if(NPROC_XI == 1) then
! five sides if only one processor in cube
      nb_msgs_theor_in_cube = 5
    else
! case of corner
      if((iproc_xi == 0 .or. iproc_xi == NPROC_XI-1).and. &
         (iproc_eta == 0 .or. iproc_eta == NPROC_ETA-1)) then
        nb_msgs_theor_in_cube = 2*NPROC_XI + 1
! case of edge
      else if(iproc_xi == 0 .or. iproc_xi == NPROC_XI-1 .or. &
              iproc_eta == 0 .or. iproc_eta == NPROC_ETA-1) then
        nb_msgs_theor_in_cube = NPROC_XI + 1
      else
! bottom element only
        nb_msgs_theor_in_cube = 1
      endif
    endif
  else
! not in chunk AB
    nb_msgs_theor_in_cube = 0
  endif

!--- processor to send information to in cube from slices

! only for slices that are not in central cube
  if(ichunk /= CHUNK_AB) then

! four vertical sides first
    if(ichunk == CHUNK_AC) then
      receiver_cube_from_slices = addressing(CHUNK_AB,0,iproc_eta)

    else if(ichunk == CHUNK_BC) then
      receiver_cube_from_slices = addressing(CHUNK_AB,iproc_eta,NPROC_ETA-1)

    else if(ichunk == CHUNK_AC_ANTIPODE) then
      receiver_cube_from_slices = addressing(CHUNK_AB,NPROC_XI-1,iproc_eta)

    else if(ichunk == CHUNK_BC_ANTIPODE) then
      receiver_cube_from_slices = addressing(CHUNK_AB,NPROC_XI-1-iproc_eta,0)

! bottom of cube, direct correspondence but with inverted xi axis
    else if(ichunk == CHUNK_AB_ANTIPODE) then
      receiver_cube_from_slices = addressing(CHUNK_AB,NPROC_XI-1-iproc_xi,iproc_eta)

    endif

  else
! dummy value in cube
    receiver_cube_from_slices = -1
  endif


!--- list of processors to receive information from in cube

! only for slices in central cube
  if(ichunk == CHUNK_AB) then

    allocate(sender_from_slices_to_cube(nb_msgs_theor_in_cube))

! initialize index of sender
    imsg = 0

! define sender for bottom edge
! bottom of cube, direct correspondence but with inverted xi axis
    imsg = imsg + 1
    sender_from_slices_to_cube(imsg) = addressing(CHUNK_AB_ANTIPODE,NPROC_XI-1-iproc_xi,iproc_eta)

! define sender for xi = xi_min edge
    if(iproc_xi == 0) then
      do iproc_xi_loop = 0,NPROC_XI-1
        imsg = imsg + 1
        sender_from_slices_to_cube(imsg) = addressing(CHUNK_AC,iproc_xi_loop,iproc_eta)
      enddo
    endif

! define sender for xi = xi_max edge
    if(iproc_xi == NPROC_XI-1) then
      do iproc_xi_loop = 0,NPROC_XI-1
        imsg = imsg + 1
        sender_from_slices_to_cube(imsg) = addressing(CHUNK_AC_ANTIPODE,iproc_xi_loop,iproc_eta)
      enddo
    endif

! define sender for eta = eta_min edge
    if(iproc_eta == 0) then
      do iproc_xi_loop = 0,NPROC_XI-1
        imsg = imsg + 1
        sender_from_slices_to_cube(imsg) = addressing(CHUNK_BC_ANTIPODE,iproc_xi_loop,NPROC_ETA-1-iproc_xi)
      enddo
    endif

! define sender for eta = eta_max edge
    if(iproc_eta == NPROC_ETA-1) then
      do iproc_xi_loop = 0,NPROC_XI-1
        imsg = imsg + 1
        sender_from_slices_to_cube(imsg) = addressing(CHUNK_BC,iproc_xi_loop,iproc_xi)
      enddo
    endif

! check that total number of faces found is correct
   if(imsg /= nb_msgs_theor_in_cube) call exit_MPI(myrank,'wrong number of faces found for central cube')

  else

! dummy value in slices
    allocate(sender_from_slices_to_cube(1))
    sender_from_slices_to_cube(1) = -1

  endif

! number of points to send or receive (bottom of slices)
  npoin2D_cube_from_slices = NSPEC2D_BOTTOM(IREGION_INNER_CORE) * NGLLX * NGLLY

! allocate buffers for cube and slices
  allocate(buffer_all_cube_from_slices(nb_msgs_theor_in_cube,npoin2D_cube_from_slices,NDIM))
  allocate(buffer_slices(npoin2D_cube_from_slices,NDIM))
  allocate(ibool_central_cube(nb_msgs_theor_in_cube,npoin2D_cube_from_slices))

! on chunk AB, receive all the messages from slices
  if(ichunk == CHUNK_AB) then

   do imsg = 1,nb_msgs_theor_in_cube

! receive buffers from slices
  isender = sender_from_slices_to_cube(imsg)
  call MPI_RECV(buffer_slices, &
              NDIM*npoin2D_cube_from_slices,MPI_DOUBLE_PRECISION,isender, &
              itag,MPI_COMM_WORLD,msg_status,ier)

! copy buffer in 2D array for each slice
   buffer_all_cube_from_slices(imsg,:,:) = buffer_slices(:,:)

   enddo
   endif


! send info to central cube from all the slices except those in CHUNK_AB
  if(ichunk /= CHUNK_AB) then

! for bottom elements in contact with central cube from the slices side
    ipoin = 0
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_INNER_CORE)

      ispec = ibelm_bottom_inner_core(ispec2D)

! only for DOFs exactly on surface of central cube (bottom of these elements)
      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX
          ipoin = ipoin + 1
          iglob = ibool_inner_core(i,j,k,ispec)
          buffer_slices(ipoin,1) = dble(xstore_inner_core(iglob))
          buffer_slices(ipoin,2) = dble(ystore_inner_core(iglob))
          buffer_slices(ipoin,3) = dble(zstore_inner_core(iglob))
        enddo
      enddo
    enddo

! send buffer to central cube
    ireceiver = receiver_cube_from_slices
    call MPI_SEND(buffer_slices,NDIM*npoin2D_cube_from_slices, &
              MPI_DOUBLE_PRECISION,ireceiver,itag,MPI_COMM_WORLD,ier)

 endif  ! end sending info to central cube

!--- now we need to find the points received and create indirect addressing

  if(ichunk == CHUNK_AB) then

   do imsg = 1,nb_msgs_theor_in_cube

   do ipoin = 1,npoin2D_cube_from_slices

     x_target = buffer_all_cube_from_slices(imsg,ipoin,1)
     y_target = buffer_all_cube_from_slices(imsg,ipoin,2)
     z_target = buffer_all_cube_from_slices(imsg,ipoin,3)

! x = x_min

  do ispec2D = 1,nspec2D_xmin_inner_core

      ispec = ibelm_xmin_inner_core(ispec2D)

! do not loop on elements outside of the central cube
     if(idoubling_inner_core(ispec) /= IFLAG_IN_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_BOTTOM_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_TOP_CENTRAL_CUBE) cycle

     i = 1
     do k = 1,NGLLZ
       do j = 1,NGLLY

         iglob = ibool_inner_core(i,j,k,ispec)
         x_current = dble(xstore_inner_core(iglob))
         y_current = dble(ystore_inner_core(iglob))
         z_current = dble(zstore_inner_core(iglob))

! look for matching point
         if(dsqrt((x_current-x_target)**2 + (y_current-y_target)**2 + (z_current-z_target)**2) < SMALLVALTOL) then
           ibool_central_cube(imsg,ipoin) = ibool_inner_core(i,j,k,ispec)
           goto 100
         endif

       enddo
     enddo

   enddo

! x = x_max

  do ispec2D = 1,nspec2D_xmax_inner_core

      ispec = ibelm_xmax_inner_core(ispec2D)

! do not loop on elements outside of the central cube
     if(idoubling_inner_core(ispec) /= IFLAG_IN_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_BOTTOM_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_TOP_CENTRAL_CUBE) cycle

     i = NGLLX
     do k = 1,NGLLZ
       do j = 1,NGLLY

         iglob = ibool_inner_core(i,j,k,ispec)
         x_current = dble(xstore_inner_core(iglob))
         y_current = dble(ystore_inner_core(iglob))
         z_current = dble(zstore_inner_core(iglob))

! look for matching point
         if(dsqrt((x_current-x_target)**2 + (y_current-y_target)**2 + (z_current-z_target)**2) < SMALLVALTOL) then
           ibool_central_cube(imsg,ipoin) = ibool_inner_core(i,j,k,ispec)
           goto 100
         endif

       enddo
     enddo

   enddo

! y = y_min

  do ispec2D = 1,nspec2D_ymin_inner_core

      ispec = ibelm_ymin_inner_core(ispec2D)

! do not loop on elements outside of the central cube
     if(idoubling_inner_core(ispec) /= IFLAG_IN_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_BOTTOM_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_TOP_CENTRAL_CUBE) cycle

     j = 1
     do k = 1,NGLLZ
       do i = 1,NGLLX

         iglob = ibool_inner_core(i,j,k,ispec)
         x_current = dble(xstore_inner_core(iglob))
         y_current = dble(ystore_inner_core(iglob))
         z_current = dble(zstore_inner_core(iglob))

! look for matching point
         if(dsqrt((x_current-x_target)**2 + (y_current-y_target)**2 + (z_current-z_target)**2) < SMALLVALTOL) then
           ibool_central_cube(imsg,ipoin) = ibool_inner_core(i,j,k,ispec)
           goto 100
         endif

       enddo
     enddo

   enddo

! y = y_max

  do ispec2D = 1,nspec2D_ymax_inner_core

      ispec = ibelm_ymax_inner_core(ispec2D)

! do not loop on elements outside of the central cube
     if(idoubling_inner_core(ispec) /= IFLAG_IN_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_BOTTOM_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_TOP_CENTRAL_CUBE) cycle

     j = NGLLY
     do k = 1,NGLLZ
       do i = 1,NGLLX

         iglob = ibool_inner_core(i,j,k,ispec)
         x_current = dble(xstore_inner_core(iglob))
         y_current = dble(ystore_inner_core(iglob))
         z_current = dble(zstore_inner_core(iglob))

! look for matching point
         if(dsqrt((x_current-x_target)**2 + (y_current-y_target)**2 + (z_current-z_target)**2) < SMALLVALTOL) then
           ibool_central_cube(imsg,ipoin) = ibool_inner_core(i,j,k,ispec)
           goto 100
         endif

       enddo
     enddo

   enddo

! bottom of cube

  do ispec = 1,NSPEC_INNER_CORE

! loop on elements at the bottom of the cube only
     if(idoubling_inner_core(ispec) /= IFLAG_BOTTOM_CENTRAL_CUBE) cycle

     k = 1
     do j = 1,NGLLY
       do i = 1,NGLLX

         iglob = ibool_inner_core(i,j,k,ispec)
         x_current = dble(xstore_inner_core(iglob))
         y_current = dble(ystore_inner_core(iglob))
         z_current = dble(zstore_inner_core(iglob))

! look for matching point
         if(dsqrt((x_current-x_target)**2 + (y_current-y_target)**2 + (z_current-z_target)**2) < SMALLVALTOL) then
           ibool_central_cube(imsg,ipoin) = ibool_inner_core(i,j,k,ispec)
           goto 100
         endif

       enddo
     enddo

   enddo

! check that a matching point is found in all cases
  call exit_MPI(myrank,'point never found in central cube')

 100 continue

   enddo
   enddo
   endif

!---
!---  now use buffers to assemble mass matrix with central cube once and for all
!---

! on chunk AB, receive all the messages from slices
  if(ichunk == CHUNK_AB) then

   do imsg = 1,nb_msgs_theor_in_cube

! receive buffers from slices
  isender = sender_from_slices_to_cube(imsg)
  call MPI_RECV(buffer_slices, &
              npoin2D_cube_from_slices,MPI_DOUBLE_PRECISION,isender, &
              itag,MPI_COMM_WORLD,msg_status,ier)

! copy buffer in 2D array for each slice
   buffer_all_cube_from_slices(imsg,:,1) = buffer_slices(:,1)

   enddo
   endif


! send info to central cube from all the slices except those in CHUNK_AB
  if(ichunk /= CHUNK_AB) then

! for bottom elements in contact with central cube from the slices side
    ipoin = 0
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_INNER_CORE)

      ispec = ibelm_bottom_inner_core(ispec2D)

! only for DOFs exactly on surface of central cube (bottom of these elements)
      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX
          ipoin = ipoin + 1
          buffer_slices(ipoin,1) = dble(rmass_inner_core(ibool_inner_core(i,j,k,ispec)))
        enddo
      enddo
    enddo

! send buffer to central cube
    ireceiver = receiver_cube_from_slices
    call MPI_SEND(buffer_slices,npoin2D_cube_from_slices, &
              MPI_DOUBLE_PRECISION,ireceiver,itag,MPI_COMM_WORLD,ier)

 endif  ! end sending info to central cube

!--- now we need to assemble the contributions

  if(ichunk == CHUNK_AB) then

! erase contributions to central cube array
   array_central_cube(:) = 0._CUSTOM_REAL

! use indirect addressing to store contributions only once
! distinguish whether single or double precision for reals
   do imsg = 1,nb_msgs_theor_in_cube
   do ipoin = 1,npoin2D_cube_from_slices
     if(CUSTOM_REAL == SIZE_REAL) then
       array_central_cube(ibool_central_cube(imsg,ipoin)) = sngl(buffer_all_cube_from_slices(imsg,ipoin,1))
     else
       array_central_cube(ibool_central_cube(imsg,ipoin)) = buffer_all_cube_from_slices(imsg,ipoin,1)
     endif
   enddo
   enddo

! suppress degrees of freedom already assembled at top of cube on edges
  do ispec = 1,NSPEC_INNER_CORE
    if(idoubling_inner_core(ispec) == IFLAG_TOP_CENTRAL_CUBE) then
      k = NGLLZ
      do j = 1,NGLLY
        do i = 1,NGLLX
          array_central_cube(ibool_inner_core(i,j,k,ispec)) = 0._CUSTOM_REAL
        enddo
      enddo
    endif
  enddo

! assemble contributions
  rmass_inner_core(:) = rmass_inner_core(:) + array_central_cube(:)

! copy sum back
   do imsg = 1,nb_msgs_theor_in_cube
   do ipoin = 1,npoin2D_cube_from_slices
     buffer_all_cube_from_slices(imsg,ipoin,1) = rmass_inner_core(ibool_central_cube(imsg,ipoin))
   enddo
   enddo

   endif


!----------

! receive info from central cube on all the slices except those in CHUNK_AB
  if(ichunk /= CHUNK_AB) then

! receive buffers from slices
  isender = receiver_cube_from_slices
  call MPI_RECV(buffer_slices, &
              npoin2D_cube_from_slices,MPI_DOUBLE_PRECISION,isender, &
              itag,MPI_COMM_WORLD,msg_status,ier)

! for bottom elements in contact with central cube from the slices side
    ipoin = 0
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_INNER_CORE)

      ispec = ibelm_bottom_inner_core(ispec2D)

! only for DOFs exactly on surface of central cube (bottom of these elements)
      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX
          ipoin = ipoin + 1

! distinguish whether single or double precision for reals
          if(CUSTOM_REAL == SIZE_REAL) then
            rmass_inner_core(ibool_inner_core(i,j,k,ispec)) = sngl(buffer_slices(ipoin,1))
          else
            rmass_inner_core(ibool_inner_core(i,j,k,ispec)) = buffer_slices(ipoin,1)
          endif

        enddo
      enddo
    enddo

 endif  ! end receiving info from central cube

!------- send info back from central cube to slices

! on chunk AB, send all the messages to slices
  if(ichunk == CHUNK_AB) then

   do imsg = 1,nb_msgs_theor_in_cube

! copy buffer in 2D array for each slice
   buffer_slices(:,1) = buffer_all_cube_from_slices(imsg,:,1)

! send buffers to slices
    ireceiver = sender_from_slices_to_cube(imsg)
    call MPI_SEND(buffer_slices,npoin2D_cube_from_slices, &
              MPI_DOUBLE_PRECISION,ireceiver,itag,MPI_COMM_WORLD,ier)

   enddo
   endif


  endif   ! end of assembling mass matrix for matching with central cube


! suppress fictitious mass matrix elements in central cube
  if(INCLUDE_CENTRAL_CUBE) where(rmass_inner_core(:) <= 0.) rmass_inner_core = 1.

! check that mass matrix is positive
  if((OCEANS .and. minval(rmass_ocean_load(1:nglob_crust_mantle)) <= 0.) .or. &
     minval(rmass_crust_mantle(1:nglob_crust_mantle)) <= 0. .or. &
     (minval(rmass_inner_core) <= 0. .or. &
     minval(rmass_outer_core(1:nglob_outer_core)) <= 0.)) &
       call exit_MPI(myrank,'negative mass matrix term')

! for efficiency, invert final mass matrix once and for all on each slice
  if(OCEANS) rmass_ocean_load(1:nglob_crust_mantle) = 1. / rmass_ocean_load(1:nglob_crust_mantle)
  rmass_crust_mantle(1:nglob_crust_mantle) = 1. / rmass_crust_mantle(1:nglob_crust_mantle)
  rmass_outer_core(1:nglob_outer_core) = 1. / rmass_outer_core(1:nglob_outer_core)
  rmass_inner_core(:) = 1. / rmass_inner_core(:)

! change x, y, z to r, theta and phi once and for all
! IMPROVE dangerous: old name kept (xstore ystore zstore) for new values

! convert in the crust and mantle
    do iglob = 1,nglob_crust_mantle
      call xyz_2_rthetaphi(xstore_crust_mantle(iglob), &
    ystore_crust_mantle(iglob),zstore_crust_mantle(iglob),rval,thetaval,phival)
      xstore_crust_mantle(iglob) = rval
      ystore_crust_mantle(iglob) = thetaval
      zstore_crust_mantle(iglob) = phival
    enddo

! convert in the outer core
    do iglob = 1,nglob_outer_core
      call xyz_2_rthetaphi(xstore_outer_core(iglob), &
    ystore_outer_core(iglob),zstore_outer_core(iglob),rval,thetaval,phival)
      xstore_outer_core(iglob) = rval
      ystore_outer_core(iglob) = thetaval
      zstore_outer_core(iglob) = phival
    enddo

! convert in the inner core
    do iglob = 1,nglob_inner_core
      call xyz_2_rthetaphi(xstore_inner_core(iglob), &
    ystore_inner_core(iglob),zstore_inner_core(iglob),rval,thetaval,phival)
      xstore_inner_core(iglob) = rval
      ystore_inner_core(iglob) = thetaval
      zstore_inner_core(iglob) = phival
    enddo

! if attenuation is on, shift PREM to right frequency
! rescale mu in PREM to average frequency for attenuation

  if(ATTENUATION) then

! get and store PREM attenuation model

    do iregion_attenuation = 1,NUM_REGIONS_ATTENUATION
      call get_attenuation_model(myrank,iregion_attenuation,MIN_ATTENUATION_PERIOD,MAX_ATTENUATION_PERIOD,tau_mu_dble, &
        tau_sigma_dble,beta_dble,one_minus_sum_beta_dble,factor_scale_dble)

! distinguish whether single or double precision for reals
      if(CUSTOM_REAL == SIZE_REAL) then
        tau_mu(iregion_attenuation,:) = sngl(tau_mu_dble(:))
        tau_sigma(iregion_attenuation,:) = sngl(tau_sigma_dble(:))
        beta(iregion_attenuation,:) = sngl(beta_dble(:))
        factor_scale(iregion_attenuation) = sngl(factor_scale_dble)
        one_minus_sum_beta(iregion_attenuation) = sngl(one_minus_sum_beta_dble)
      else
        tau_mu(iregion_attenuation,:) = tau_mu_dble(:)
        tau_sigma(iregion_attenuation,:) = tau_sigma_dble(:)
        beta(iregion_attenuation,:) = beta_dble(:)
        factor_scale(iregion_attenuation) = factor_scale_dble
        one_minus_sum_beta(iregion_attenuation) = one_minus_sum_beta_dble
      endif
    enddo

! rescale in crust and mantle

    do ispec = 1,nspec_crust_mantle
      do k=1,NGLLZ
        do j=1,NGLLY
          do i=1,NGLLX

  if(idoubling_crust_mantle(ispec) == IFLAG_DOUBLING_670 .or. &
     idoubling_crust_mantle(ispec) == IFLAG_MANTLE_NORMAL .or. &
     idoubling_crust_mantle(ispec) == IFLAG_BOTTOM_MANTLE) then

     scale_factor = factor_scale(IREGION_ATTENUATION_CMB_670)

  else if(idoubling_crust_mantle(ispec) == IFLAG_670_220) then

     scale_factor = factor_scale(IREGION_ATTENUATION_670_220)

  else if(idoubling_crust_mantle(ispec) == IFLAG_220_MOHO .or. idoubling_crust_mantle(ispec) == IFLAG_CRUST) then

! special case of d80 which is not honored by the mesh
! xstore contains the radius
    iglob = ibool_crust_mantle(i,j,k,ispec)
    dist = xstore_crust_mantle(iglob)

! map ellipticity back for d80 detection
! ystore contains theta
    if(ELLIPTICITY) then
      theta = ystore_crust_mantle(iglob)
      cost = cos(theta)
      p20 = 0.5*(3.*cost*cost-1.)
      dist = dist*(1.+(2./3.)*ell_d80*p20)
    endif

    if(dist > R80/R_EARTH) then
      scale_factor = factor_scale(IREGION_ATTENUATION_80_SURFACE)
    else
      scale_factor = factor_scale(IREGION_ATTENUATION_220_80)
    endif

  else

    call exit_MPI(myrank,'wrong attenuation doubling flag')

  endif

    if(ANISOTROPIC_MANTLE) then
      scale_factor_minus_one = scale_factor - 1.
      mul = c44store_crust_mantle(i,j,k,ispec)
      c11store_crust_mantle(i,j,k,ispec) = c11store_crust_mantle(i,j,k,ispec) &
              + FOUR_THIRDS * scale_factor_minus_one * mul
      c12store_crust_mantle(i,j,k,ispec) = c12store_crust_mantle(i,j,k,ispec) &
              - TWO_THIRDS * scale_factor_minus_one * mul
      c13store_crust_mantle(i,j,k,ispec) = c13store_crust_mantle(i,j,k,ispec) &
              - TWO_THIRDS * scale_factor_minus_one * mul
      c22store_crust_mantle(i,j,k,ispec) = c22store_crust_mantle(i,j,k,ispec) &
              + FOUR_THIRDS * scale_factor_minus_one * mul
      c23store_crust_mantle(i,j,k,ispec) = c23store_crust_mantle(i,j,k,ispec) &
              - TWO_THIRDS * scale_factor_minus_one * mul
      c33store_crust_mantle(i,j,k,ispec) = c33store_crust_mantle(i,j,k,ispec) &
              + FOUR_THIRDS * scale_factor_minus_one * mul
      c44store_crust_mantle(i,j,k,ispec) = c44store_crust_mantle(i,j,k,ispec) &
              + scale_factor_minus_one * mul
      c55store_crust_mantle(i,j,k,ispec) = c55store_crust_mantle(i,j,k,ispec) &
              + scale_factor_minus_one * mul
      c66store_crust_mantle(i,j,k,ispec) = c66store_crust_mantle(i,j,k,ispec) &
              + scale_factor_minus_one * mul
    else
      muvstore_crust_mantle(i,j,k,ispec) = muvstore_crust_mantle(i,j,k,ispec) * scale_factor
      if(TRANSVERSE_ISOTROPY .and. idoubling_crust_mantle(ispec) == IFLAG_220_MOHO) &
        muhstore_crust_mantle(i,j,k,ispec) = muhstore_crust_mantle(i,j,k,ispec) * scale_factor
    endif

          enddo
        enddo
      enddo
    enddo

! rescale in inner core

    scale_factor_minus_one = factor_scale(IREGION_ATTENUATION_INNER_CORE) - 1.

    do ispec = 1,nspec_inner_core
      do k=1,NGLLZ
        do j=1,NGLLY
          do i=1,NGLLX

        if(ANISOTROPIC_INNER_CORE) then
          mul = muvstore_inner_core(i,j,k,ispec)
          c11store_inner_core(i,j,k,ispec) = c11store_inner_core(i,j,k,ispec) &
                  + FOUR_THIRDS * scale_factor_minus_one * mul
          c12store_inner_core(i,j,k,ispec) = c12store_inner_core(i,j,k,ispec) &
                  - TWO_THIRDS * scale_factor_minus_one * mul
          c13store_inner_core(i,j,k,ispec) = c13store_inner_core(i,j,k,ispec) &
                  - TWO_THIRDS * scale_factor_minus_one * mul
          c33store_inner_core(i,j,k,ispec) = c33store_inner_core(i,j,k,ispec) &
                  + FOUR_THIRDS * scale_factor_minus_one * mul
          c44store_inner_core(i,j,k,ispec) = c44store_inner_core(i,j,k,ispec) &
                  + scale_factor_minus_one * mul
        endif

        muvstore_inner_core(i,j,k,ispec) = muvstore_inner_core(i,j,k,ispec) * factor_scale(IREGION_ATTENUATION_INNER_CORE)

          enddo
        enddo
      enddo
    enddo

  endif

! initialize arrays to zero

  displ_crust_mantle(:,:) = 0._CUSTOM_REAL
  veloc_crust_mantle(:,:) = 0._CUSTOM_REAL
  accel_crust_mantle(:,:) = 0._CUSTOM_REAL

  displ_outer_core(:) = 0._CUSTOM_REAL
  veloc_outer_core(:) = 0._CUSTOM_REAL
  accel_outer_core(:) = 0._CUSTOM_REAL

  displ_inner_core(:,:) = 0._CUSTOM_REAL
  veloc_inner_core(:,:) = 0._CUSTOM_REAL
  accel_inner_core(:,:) = 0._CUSTOM_REAL

! put negligible initial value to avoid very slow underflow trapping
  if(FIX_UNDERFLOW_PROBLEM) then
    displ_crust_mantle(:,:) = VERYSMALLVAL
    displ_outer_core(:) = VERYSMALLVAL
    displ_inner_core(:,:) = VERYSMALLVAL
  endif

! store g, rho and dg/dr=dg using normalized radius in lookup table every 100 m
! get density and velocity from PREM model using dummy doubling flag
! this assumes that the gravity perturbations are small and smooth
! and that we can neglect the 3D model and use PREM every 100 m in all cases
! this is probably a rather reasonable assumption
  if(GRAVITY) then
    call make_gravity(nspl_gravity,rspl_gravity,gspl,gspl2,ONE_CRUST)
    do int_radius = 1,NRAD_GRAVITY
      radius = dble(int_radius) / (R_EARTH_KM * 10.d0)
      call splint(rspl_gravity,gspl,gspl2,nspl_gravity,radius,g)
      idoubling = 0
      call prem_iso(myrank,radius,rho,vp,vs,Qkappa,Qmu,idoubling,.false.,ONE_CRUST,.false.)
      dg = 4.0d0*rho - 2.0d0*g/radius
      minus_gravity_table(int_radius) = - g
      minus_deriv_gravity_table(int_radius) = - dg
      density_table(int_radius) = rho
      minus_rho_g_over_kappa_fluid(int_radius) = - g / vp**2
    enddo

! make sure fluid array is only assigned in outer core between 1222 and 3478 km
! lookup table is defined every 100 m
    do int_radius = 1,NRAD_GRAVITY
      radius_km = dble(int_radius) / 10.d0
      if(radius_km > RCMB/1000.d0 - 3.d0) &
        minus_rho_g_over_kappa_fluid(int_radius) = minus_rho_g_over_kappa_fluid(nint((RCMB/1000.d0 - 3.d0)*10.d0))
      if(radius_km < RICB/1000.d0 + 3.d0) &
        minus_rho_g_over_kappa_fluid(int_radius) = minus_rho_g_over_kappa_fluid(nint((RICB/1000.d0 + 3.d0)*10.d0))
    enddo

! compute gravity value at CMB and ICB once and for all
    radius = RCMB / R_EARTH
    call splint(rspl_gravity,gspl,gspl2,nspl_gravity,radius,g_cmb_dble)

    radius = RICB / R_EARTH
    call splint(rspl_gravity,gspl,gspl2,nspl_gravity,radius,g_icb_dble)

! distinguish whether single or double precision for reals
    if(CUSTOM_REAL == SIZE_REAL) then
      minus_g_cmb = sngl(- g_cmb_dble)
      minus_g_icb = sngl(- g_icb_dble)
    else
      minus_g_cmb = - g_cmb_dble
      minus_g_icb = - g_icb_dble
    endif

   endif

! synchronize all processes to make sure everybody is ready to start time loop
  call MPI_BARRIER(MPI_COMM_WORLD,ier)
  if(myrank == 0) write(IMAIN,*) 'All processes are synchronized before time loop'

! allocate files to save movies
  if(MOVIE_SURFACE) then
    allocate(store_val_x(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE)))
    allocate(store_val_y(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE)))
    allocate(store_val_z(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE)))
    allocate(store_val_ux(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE)))
    allocate(store_val_uy(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE)))
    allocate(store_val_uz(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE)))

    allocate(store_val_x_all(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE),0:NPROCTOT-1))
    allocate(store_val_y_all(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE),0:NPROCTOT-1))
    allocate(store_val_z_all(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE),0:NPROCTOT-1))
    allocate(store_val_ux_all(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE),0:NPROCTOT-1))
    allocate(store_val_uy_all(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE),0:NPROCTOT-1))
    allocate(store_val_uz_all(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE),0:NPROCTOT-1))
  endif

!
!   s t a r t   t i m e   i t e r a t i o n s
!

  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) '           time step: ',sngl(DT),' s'
    write(IMAIN,*) 'number of time steps: ',NSTEP
    write(IMAIN,*) 'total simulated time: ',sngl(((NSTEP-1)*DT-hdur(1))/60.d0),' minutes'
    write(IMAIN,*)
  endif

! define constants for the time integration
! scaling to make displacement in meters
  scale_t = ONE/dsqrt(PI*GRAV*RHOAV)
  scale_displ = R_EARTH

! distinguish whether single or double precision for reals
  if(CUSTOM_REAL == SIZE_REAL) then
    deltat = sngl(DT/scale_t)
    deltatover2 = sngl(0.5d0*DT/scale_t)
    deltatsqover2 = sngl(0.5d0*DT*DT/(scale_t*scale_t))
  else
    deltat = DT/scale_t
    deltatover2 = 0.5d0*DT/scale_t
    deltatsqover2 = 0.5d0*DT*DT/(scale_t*scale_t)
  endif

! non-dimensionalized rotation rate of the Earth times two
  if(ROTATION) then
! distinguish whether single or double precision for reals
    if(CUSTOM_REAL == SIZE_REAL) then
      two_omega_earth = sngl(2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t))
    else
      two_omega_earth = 2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t)
    endif
  else
    two_omega_earth = 0._CUSTOM_REAL
  endif

! precompute Runge-Kutta coefficients if attenuation
  if(ATTENUATION) then
    tauinv(:,:) = - 1. / tau_sigma(:,:)
    factor_common(:,:) = 2. * beta(:,:) * tauinv(:,:)
    alphaval(:,:) = 1 + deltat*tauinv(:,:) + deltat**2*tauinv(:,:)**2 / 2. + &
      deltat**3*tauinv(:,:)**3 / 6. + deltat**4*tauinv(:,:)**4 / 24.
    betaval(:,:) = deltat / 2. + deltat**2*tauinv(:,:) / 3. + deltat**3*tauinv(:,:)**2 / 8. + deltat**4*tauinv(:,:)**3 / 24.
    gammaval(:,:) = deltat / 2. + deltat**2*tauinv(:,:) / 6. + deltat**3*tauinv(:,:)**2 / 24.
  endif

! define indirect numbering arrays for inlined version
  do k = 1,NGLLZ
    do i = 1,NGLLX
      ij = (k-1)*NGLLX + i
      index_fluid_i(ij) = i
      index_fluid_k(ij) = k
    enddo
  enddo

  do idimension = 1,NDIM
    do k = 1,NGLLZ
      do i = 1,NGLLX
        ijd = (idimension-1)*NGLLX*NGLLZ + (k-1)*NGLLX + i
        index_i(ijd) = i
        index_k(ijd) = k
        index_dim(ijd) = idimension
      enddo
    enddo
  enddo

! define Lagrange interpolants for receivers for inlined version
  do irec_local = 1,nrec_local
    do k = 1,NGLLZ
      do j = 1,NGLLY
        do i = 1,NGLLX
          hlagrange(irec_local,i,j,k) = hxir_store(irec_local,i)*hetar_store(irec_local,j)*hgammar_store(irec_local,k)
        enddo
      enddo
    enddo
  enddo

! JT JT Stacey, indexing for inlined code

  if(REGIONAL_CODE .and. STACEY_ABS_CONDITIONS) then

    allocate(stacey_outer_core_xmin_j(NGLLSQUARE,nspec2D_xmin_outer_core))
    allocate(stacey_outer_core_xmin_k(NGLLSQUARE,nspec2D_xmin_outer_core))
    allocate(stacey_outer_core_xmax_j(NGLLSQUARE,nspec2D_xmax_outer_core))
    allocate(stacey_outer_core_xmax_k(NGLLSQUARE,nspec2D_xmax_outer_core))
    allocate(stacey_outer_core_ymin_i(NGLLSQUARE,nspec2D_ymin_outer_core))
    allocate(stacey_outer_core_ymin_k(NGLLSQUARE,nspec2D_ymin_outer_core))
    allocate(stacey_outer_core_ymax_i(NGLLSQUARE,nspec2D_ymax_outer_core))
    allocate(stacey_outer_core_ymax_k(NGLLSQUARE,nspec2D_ymax_outer_core))
    allocate(stacey_bottom_outer_core_i(NGLLSQUARE,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)))
    allocate(stacey_bottom_outer_core_j(NGLLSQUARE,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)))
    allocate(stacey_outer_core_xmin_jk(nspec2D_xmin_outer_core))
    allocate(stacey_outer_core_xmax_jk(nspec2D_xmax_outer_core))
    allocate(stacey_outer_core_ymin_ik(nspec2D_ymin_outer_core))
    allocate(stacey_outer_core_ymax_ik(nspec2D_ymax_outer_core))

! outer core

!   xmin
    do ispec2D=1,nspec2D_xmin_outer_core
! exclude elements that are not on absorbing edges
      if(nkmin_xi_outer_core(1,ispec2D) == 0 .or. njmin_outer_core(1,ispec2D) == 0) cycle
      jk = 0
      do k=nkmin_xi_outer_core(1,ispec2D),NGLLZ
        do j=njmin_outer_core(1,ispec2D),njmax_outer_core(1,ispec2D)
          jk = jk + 1
          stacey_outer_core_xmin_j(jk,ispec2D) = j
          stacey_outer_core_xmin_k(jk,ispec2D) = k
        enddo
      enddo
      stacey_outer_core_xmin_jk(ispec2D) = jk
    enddo

!   xmax
    do ispec2D=1,nspec2D_xmax_outer_core
! exclude elements that are not on absorbing edges
      if(nkmin_xi_outer_core(2,ispec2D) == 0 .or. njmin_outer_core(2,ispec2D) == 0) cycle
      jk = 0
      do k=nkmin_xi_outer_core(2,ispec2D),NGLLZ
        do j=njmin_outer_core(2,ispec2D),njmax_outer_core(2,ispec2D)
          jk = jk + 1
          stacey_outer_core_xmax_j(jk,ispec2D) = j
          stacey_outer_core_xmax_k(jk,ispec2D) = k
        enddo
      enddo
      stacey_outer_core_xmax_jk(ispec2D) = jk
    enddo

!   ymin
    do ispec2D=1,nspec2D_ymin_outer_core
! exclude elements that are not on absorbing edges
      if(nkmin_eta_outer_core(1,ispec2D) == 0 .or. nimin_outer_core(1,ispec2D) == 0) cycle
      ik = 0
      do k=nkmin_eta_outer_core(1,ispec2D),NGLLZ
        do i=nimin_outer_core(1,ispec2D),nimax_outer_core(1,ispec2D)
          ik = ik + 1
          stacey_outer_core_ymin_i(ik,ispec2D) = i
          stacey_outer_core_ymin_k(ik,ispec2D) = k
        enddo
      enddo
      stacey_outer_core_ymin_ik(ispec2D) = ik
    enddo

!   ymax
    do ispec2D=1,nspec2D_ymax_outer_core
! exclude elements that are not on absorbing edges
      if(nkmin_eta_outer_core(2,ispec2D) == 0 .or. nimin_outer_core(2,ispec2D) == 0) cycle
      ik = 0
      do k=nkmin_eta_outer_core(2,ispec2D),NGLLZ
        do i=nimin_outer_core(2,ispec2D),nimax_outer_core(2,ispec2D)
          ik = ik + 1
          stacey_outer_core_ymax_i(ik,ispec2D) = i
          stacey_outer_core_ymax_k(ik,ispec2D) = k
        enddo
      enddo
      stacey_outer_core_ymax_ik(ispec2D) = ik
    enddo

! for surface elements exactly on the ICB
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)
      ij = 0
      do j = 1,NGLLY
        do i = 1,NGLLX
          ij = ij + 1
          stacey_bottom_outer_core_i(ij,ispec2D) = i
          stacey_bottom_outer_core_j(ij,ispec2D) = j
        enddo
      enddo
    enddo

! crust & mantle

    allocate(stacey_crust_mantle_xmin_j(NGLLSQUARE,nspec2D_xmin_crust_mantle))
    allocate(stacey_crust_mantle_xmin_k(NGLLSQUARE,nspec2D_xmin_crust_mantle))
    allocate(stacey_crust_mantle_xmax_j(NGLLSQUARE,nspec2D_xmax_crust_mantle))
    allocate(stacey_crust_mantle_xmax_k(NGLLSQUARE,nspec2D_xmax_crust_mantle))
    allocate(stacey_crust_mantle_ymin_i(NGLLSQUARE,nspec2D_ymin_crust_mantle))
    allocate(stacey_crust_mantle_ymin_k(NGLLSQUARE,nspec2D_ymin_crust_mantle))
    allocate(stacey_crust_mantle_ymax_i(NGLLSQUARE,nspec2D_ymax_crust_mantle))
    allocate(stacey_crust_mantle_ymax_k(NGLLSQUARE,nspec2D_ymax_crust_mantle))
    allocate(stacey_crust_mantle_xmin_jk(nspec2D_xmin_crust_mantle))
    allocate(stacey_crust_mantle_xmax_jk(nspec2D_xmax_crust_mantle))
    allocate(stacey_crust_mantle_ymin_ik(nspec2D_ymin_crust_mantle))
    allocate(stacey_crust_mantle_ymax_ik(nspec2D_ymax_crust_mantle))

!   xmin
    do ispec2D=1,nspec2D_xmin_crust_mantle
! exclude elements that are not on absorbing edges
      if(nkmin_xi_crust_mantle(1,ispec2D) == 0 .or. njmin_crust_mantle(1,ispec2D) == 0) cycle
      jk = 0
      do k=nkmin_xi_crust_mantle(1,ispec2D),NGLLZ
        do j=njmin_crust_mantle(1,ispec2D),njmax_crust_mantle(1,ispec2D)
          jk = jk + 1
          stacey_crust_mantle_xmin_j(jk,ispec2D) = j
          stacey_crust_mantle_xmin_k(jk,ispec2D) = k
        enddo
      enddo
      stacey_crust_mantle_xmin_jk(ispec2D) = jk
    enddo

!   xmax
    do ispec2D=1,nspec2D_xmax_crust_mantle
! exclude elements that are not on absorbing edges
      if(nkmin_xi_crust_mantle(2,ispec2D) == 0 .or. njmin_crust_mantle(2,ispec2D) == 0) cycle
      jk = 0
      do k=nkmin_xi_crust_mantle(2,ispec2D),NGLLZ
        do j=njmin_crust_mantle(2,ispec2D),njmax_crust_mantle(2,ispec2D)
          jk = jk + 1
          stacey_crust_mantle_xmax_j(jk,ispec2D) = j
          stacey_crust_mantle_xmax_k(jk,ispec2D) = k
        enddo
      enddo
      stacey_crust_mantle_xmax_jk(ispec2D) = jk
    enddo

!   ymin
    do ispec2D=1,nspec2D_ymin_crust_mantle
! exclude elements that are not on absorbing edges
      if(nkmin_eta_crust_mantle(1,ispec2D) == 0 .or. nimin_crust_mantle(1,ispec2D) == 0) cycle
      ik = 0
      do k=nkmin_eta_crust_mantle(1,ispec2D),NGLLZ
        do i=nimin_crust_mantle(1,ispec2D),nimax_crust_mantle(1,ispec2D)
          ik = ik + 1
          stacey_crust_mantle_ymin_i(ik,ispec2D) = i
          stacey_crust_mantle_ymin_k(ik,ispec2D) = k
        enddo
      enddo
      stacey_crust_mantle_ymin_ik(ispec2D) = ik
    enddo

!   ymax
    do ispec2D=1,nspec2D_ymax_crust_mantle
! exclude elements that are not on absorbing edges
      if(nkmin_eta_crust_mantle(2,ispec2D) == 0 .or. nimin_crust_mantle(2,ispec2D) == 0) cycle
      ik = 0
      do k=nkmin_eta_crust_mantle(2,ispec2D),NGLLZ
        do i=nimin_crust_mantle(2,ispec2D),nimax_crust_mantle(2,ispec2D)
          ik = ik + 1
          stacey_crust_mantle_ymax_i(ik,ispec2D) = i
          stacey_crust_mantle_ymax_k(ik,ispec2D) = k
        enddo
      enddo
      stacey_crust_mantle_ymax_ik(ispec2D) = ik
    enddo

  endif ! Stacey conditions


  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'Starting time iteration loop...'
    write(IMAIN,*)
  endif

! create an empty file to monitor the start of the simulation
  if(myrank == 0) then
    open(unit=IOUT,file='OUTPUT_FILES/starttimeloop.txt',status='unknown')
    write(IOUT,*) 'starting time loop'
    close(IOUT)
  endif

! clear memory variables if attenuation
  if(ATTENUATION) then
    R_memory_crust_mantle(:,:,:,:,:,:) = 0._CUSTOM_REAL
    R_memory_inner_core(:,:,:,:,:,:) = 0._CUSTOM_REAL

    if(FIX_UNDERFLOW_PROBLEM) then
      R_memory_crust_mantle(:,:,:,:,:,:) = VERYSMALLVAL
      R_memory_inner_core(:,:,:,:,:,:) = VERYSMALLVAL
    endif

  endif

! get MPI starting time
  time_start = MPI_WTIME()

! *********************************************************
! ************* MAIN LOOP OVER THE TIME STEPS *************
! *********************************************************

! for longer vectors
  nglob_crust_mantle_ndim = nglob_crust_mantle * NDIM

! define correct time steps if restart files
  if(NUMBER_OF_RUNS < 1 .or. NUMBER_OF_RUNS > 3) stop 'number of restart runs can be 1, 2 or 3'
  if(NUMBER_OF_THIS_RUN < 1 .or. NUMBER_OF_THIS_RUN > NUMBER_OF_RUNS) stop 'incorrect run number'

  if(NUMBER_OF_RUNS == 3) then
    if(NUMBER_OF_THIS_RUN == 1) then
      it_begin = 1
      it_end = NSTEP/3
    else if(NUMBER_OF_THIS_RUN == 2) then
      it_begin = NSTEP/3 + 1
      it_end = 2*(NSTEP/3)
    else
      it_begin = 2*(NSTEP/3) + 1
      it_end = NSTEP
    endif

  else if(NUMBER_OF_RUNS == 2) then
    if(NUMBER_OF_THIS_RUN == 1) then
      it_begin = 1
      it_end = NSTEP/2
    else
      it_begin = NSTEP/2 + 1
      it_end = NSTEP
    endif

  else
    it_begin = 1
    it_end = NSTEP
  endif

! suppress white spaces if any
  clean_LOCAL_PATH = adjustl(LOCAL_PATH)

! create full final local path
  final_LOCAL_PATH = clean_LOCAL_PATH(1:len_trim(clean_LOCAL_PATH)) // '/'

! read files back from local disk or MT tape system if restart file
  if(NUMBER_OF_THIS_RUN > 1) then
    write(outputname,"('dump_all_arrays',i4.4)") myrank
    open(unit=55,file=final_LOCAL_PATH(1:len_trim(final_LOCAL_PATH))//outputname,status='old',form='unformatted')
    read(55) displ_crust_mantle
    read(55) veloc_crust_mantle
    read(55) accel_crust_mantle
    read(55) displ_inner_core
    read(55) veloc_inner_core
    read(55) accel_inner_core
    read(55) displ_outer_core
    read(55) veloc_outer_core
    read(55) accel_outer_core
    read(55) R_memory_crust_mantle
    read(55) R_memory_inner_core
    read(55) epsilondev_crust_mantle
    read(55) epsilondev_inner_core
    read(55) A_array_rotation
    read(55) B_array_rotation
    close(55)
  endif

!CDIR NOVECTOR
  do it=it_begin,it_end

! compute predictors

! for longer vectors
!CDIR NOASSUME
  do i=1,nglob_crust_mantle_ndim
    displ_crust_mantle(i,1) = displ_crust_mantle(i,1) + deltat*veloc_crust_mantle(i,1) + deltatsqover2*accel_crust_mantle(i,1)
    veloc_crust_mantle(i,1) = veloc_crust_mantle(i,1) + deltatover2*accel_crust_mantle(i,1)
  enddo

! outer core
  do i=1,nglob_outer_core
    displ_outer_core(i) = displ_outer_core(i) + deltat*veloc_outer_core(i) + deltatsqover2*accel_outer_core(i)
    veloc_outer_core(i) = veloc_outer_core(i) + deltatover2*accel_outer_core(i)
  enddo

! for longer vectors
!CDIR NOASSUME
  do i=1,NGLOB_INNER_CORE*NDIM
    displ_inner_core(i,1) = displ_inner_core(i,1) + deltat*veloc_inner_core(i,1) + deltatsqover2*accel_inner_core(i,1)
    veloc_inner_core(i,1) = veloc_inner_core(i,1) + deltatover2*accel_inner_core(i,1)
  enddo

! compute the maximum of the norm of the displacement
! in all the slices using an MPI reduction
! and output timestamp file to check that simulation is running fine
  if(mod(it,ITAFF_TIME_STEPS) == 0 .or. it == it_begin + 4) then

! compute maximum of norm of displacement in each slice
    Usolidnorm = max( &
        maxval(sqrt(displ_crust_mantle(1,1:nglob_crust_mantle)**2 + &
          displ_crust_mantle(2,1:nglob_crust_mantle)**2 + displ_crust_mantle(3,1:nglob_crust_mantle)**2)), &
        maxval(sqrt(displ_inner_core(1,:)**2 + displ_inner_core(2,:)**2 + displ_inner_core(3,:)**2)))

    Ufluidnorm = maxval(abs(displ_outer_core(1:nglob_outer_core)))

! compute the maximum of the maxima for all the slices using an MPI reduction
    call MPI_REDUCE(Usolidnorm,Usolidnorm_all,1,CUSTOM_MPI_TYPE,MPI_MAX,0, &
                          MPI_COMM_WORLD,ier)
    call MPI_REDUCE(Ufluidnorm,Ufluidnorm_all,1,CUSTOM_MPI_TYPE,MPI_MAX,0, &
                          MPI_COMM_WORLD,ier)

    if(myrank == 0) then

      write(IMAIN,*) 'Time step # ',it
      write(IMAIN,*) 'Time: ',sngl(((it-1)*DT-hdur(1))/60.d0),' minutes'

! elapsed time since beginning of the simulation
      tCPU = MPI_WTIME() - time_start
      int_tCPU = int(tCPU)
      ihours = int_tCPU / 3600
      iminutes = (int_tCPU - 3600*ihours) / 60
      iseconds = int_tCPU - 3600*ihours - 60*iminutes
      write(IMAIN,*) 'Elapsed time in seconds = ',tCPU
      write(IMAIN,"(' Elapsed time in hh:mm:ss = ',i4,' h ',i2.2,' m ',i2.2,' s')") ihours,iminutes,iseconds
      write(IMAIN,*) 'Mean elapsed time per time step in seconds = ',tCPU/dble(it)

! rescale maximum displacement to correct dimensions
      Usolidnorm_all = Usolidnorm_all * sngl(scale_displ)
      write(IMAIN,*) 'Max norm displacement vector U in solid in all slices (m) = ',Usolidnorm_all
      write(IMAIN,*) 'Max non-dimensional potential Ufluid in fluid in all slices = ',Ufluidnorm_all
      write(IMAIN,*)

! write time stamp file to give information about progression of simulation
      write(outputname,"('OUTPUT_FILES/timestamp',i6.6)") it
      open(unit=IOUT,file=outputname,status='unknown')
      write(IOUT,*) 'Time step # ',it
      write(IOUT,*) 'Time: ',sngl(((it-1)*DT-hdur(1))/60.d0),' minutes'
      write(IOUT,*) 'Elapsed time in seconds = ',tCPU
      write(IOUT,"(' Elapsed time in hh:mm:ss = ',i4,' h ',i2.2,' m ',i2.2,' s')") ihours,iminutes,iseconds
      write(IOUT,*) 'Mean elapsed time per time step in seconds = ',tCPU/dble(it)
      write(IOUT,*) 'Max norm displacement vector U in solid in all slices (m) = ',Usolidnorm_all
      write(IOUT,*) 'Max non-dimensional potential Ufluid in fluid in all slices = ',Ufluidnorm_all
      close(IOUT)

! check stability of the code, exit if unstable
      if(Usolidnorm_all > STABILITY_THRESHOLD) call exit_MPI(myrank,'code became unstable and blew up in solid')
      if(Ufluidnorm_all > STABILITY_THRESHOLD) call exit_MPI(myrank,'code became unstable and blew up in fluid')

    endif
  endif

! ****************************************************
!   big loop over all spectral elements in the fluid
! ****************************************************

! compute internal forces in the fluid region
  if(CUSTOM_REAL == SIZE_REAL) then
    time = sngl((dble(it-1)*DT-hdur(1))/scale_t)
  else
    time = (dble(it-1)*DT-hdur(1))/scale_t
  endif

  call compute_forces_outer_core(time,deltat,two_omega_earth, &
         A_array_rotation,B_array_rotation, &
         minus_rho_g_over_kappa_fluid,displ_outer_core,accel_outer_core, &
         xstore_outer_core,ystore_outer_core,zstore_outer_core, &
         xix_outer_core,xiy_outer_core,xiz_outer_core, &
         etax_outer_core,etay_outer_core,etaz_outer_core, &
         gammax_outer_core,gammay_outer_core,gammaz_outer_core, &
         jacobian_outer_core,hprime_xx,hprime_yy,hprime_zz, &
         hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
         wgll_cube,wgllwgll_yz_no_i,wgllwgll_xz_no_j,wgllwgll_xy_no_k, &
         ibool_outer_core,nspec_outer_core, &
         nglob_outer_core,index_fluid_i,index_fluid_k)

! JT JT Stacey conditions

  if(REGIONAL_CODE .and. STACEY_ABS_CONDITIONS) then

!   xmin
!CDIR NOVECTOR
    do ispec2D=1,nspec2D_xmin_outer_core
 
      ispec=ibelm_xmin_outer_core(ispec2D)
 
! exclude elements that are not on absorbing edges
      if(nkmin_xi_outer_core(1,ispec2D) == 0 .or. njmin_outer_core(1,ispec2D) == 0) cycle
 
      i=1
!CDIR NODEP(accel_outer_core)
      do jk=1,stacey_outer_core_xmin_jk(ispec2D)
 
        j = stacey_outer_core_xmin_j(jk,ispec2D)
        k = stacey_outer_core_xmin_k(jk,ispec2D)
        ijk = i + (j-1)*NGLLX + (k-1)*NGLLSQUARE
 
        iglob=ibool_outer_core(ijk,1,1,ispec)

        sn = veloc_outer_core(iglob)/vp_outer_core(ijk,1,1,ispec)

        weight=jacobian2D_xmin_outer_core(j,k,ispec2D)*wgllwgll_yz(j,k)
 
        accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn
 
      enddo
    enddo

!   xmax
!CDIR NOVECTOR
    do ispec2D=1,nspec2D_xmax_outer_core
 
      ispec=ibelm_xmax_outer_core(ispec2D)
 
! exclude elements that are not on absorbing edges
      if(nkmin_xi_outer_core(2,ispec2D) == 0 .or. njmin_outer_core(2,ispec2D) == 0) cycle
 
      i=NGLLX
!CDIR NODEP(accel_outer_core)
      do jk=1,stacey_outer_core_xmax_jk(ispec2D)
 
        j = stacey_outer_core_xmax_j(jk,ispec2D)
        k = stacey_outer_core_xmax_k(jk,ispec2D)
        ijk = i + (j-1)*NGLLX + (k-1)*NGLLSQUARE
 
        iglob=ibool_outer_core(ijk,1,1,ispec)

        sn = veloc_outer_core(iglob)/vp_outer_core(ijk,1,1,ispec)

        weight=jacobian2D_xmax_outer_core(j,k,ispec2D)*wgllwgll_yz(j,k)
 
        accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn
 
      enddo
    enddo

!   ymin
!CDIR NOVECTOR
    do ispec2D=1,nspec2D_ymin_outer_core
 
      ispec=ibelm_ymin_outer_core(ispec2D)
 
! exclude elements that are not on absorbing edges
      if(nkmin_eta_outer_core(1,ispec2D) == 0 .or. nimin_outer_core(1,ispec2D) == 0) cycle
 
      j=1
!CDIR NODEP(accel_outer_core)
      do ik=1,stacey_outer_core_ymin_ik(ispec2D)
 
        i = stacey_outer_core_ymin_i(ik,ispec2D)
        k = stacey_outer_core_ymin_k(ik,ispec2D)
        ijk = i + (j-1)*NGLLX + (k-1)*NGLLSQUARE
 
        iglob=ibool_outer_core(ijk,1,1,ispec)

        sn = veloc_outer_core(iglob)/vp_outer_core(ijk,1,1,ispec)

        weight=jacobian2D_ymin_outer_core(i,k,ispec2D)*wgllwgll_xz(i,k)
 
        accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn
 
      enddo
    enddo

!   ymax
!CDIR NOVECTOR
    do ispec2D=1,nspec2D_ymax_outer_core
 
      ispec=ibelm_ymax_outer_core(ispec2D)
 
! exclude elements that are not on absorbing edges
      if(nkmin_eta_outer_core(2,ispec2D) == 0 .or. nimin_outer_core(2,ispec2D) == 0) cycle
 
      j=NGLLY
!CDIR NODEP(accel_outer_core)
      do ik=1,stacey_outer_core_ymax_ik(ispec2D)
 
        i = stacey_outer_core_ymax_i(ik,ispec2D)
        k = stacey_outer_core_ymax_k(ik,ispec2D)
        ijk = i + (j-1)*NGLLX + (k-1)*NGLLSQUARE
 
        iglob=ibool_outer_core(ijk,1,1,ispec)

        sn = veloc_outer_core(iglob)/vp_outer_core(ijk,1,1,ispec)

        weight=jacobian2D_ymax_outer_core(i,k,ispec2D)*wgllwgll_xz(i,k)
 
        accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn
 
      enddo
    enddo

! for surface elements exactly on the ICB
!CDIR NOVECTOR
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)
 
      ispec = ibelm_bottom_outer_core(ispec2D)
 
      k = 1
!CDIR NODEP(accel_outer_core)
      do ij = 1,NGLLSQUARE
 
        i = stacey_bottom_outer_core_i(ij,ispec2D)
        j = stacey_bottom_outer_core_j(ij,ispec2D)
        ijk = i + (j-1)*NGLLX + (k-1)*NGLLSQUARE
 
        iglob = ibool_outer_core(ijk,1,1,ispec)
 
        sn = veloc_outer_core(iglob)/vp_outer_core(ijk,1,1,ispec)
 
        weight = jacobian2D_bottom_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)
 
        accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn
 
      enddo
    enddo
 
  endif ! Stacey conditions


! ****************************************************
! **********  add matching with solid part  **********
! ****************************************************

! only for elements in first matching layer in the fluid

!---
!--- couple with mantle at the top of the outer core
!---

  if(ACTUALLY_COUPLE_FLUID_CMB) then

! for surface elements exactly on the CMB
!CDIR NOVECTOR
    do ispec2D = 1,NSPEC2D_TOP(IREGION_OUTER_CORE)

      ispec = ibelm_top_outer_core(ispec2D)

! only for DOFs exactly on the CMB (top of these elements)
      k = NGLLZ

!CDIR NODEP(accel_outer_core)
      do ij = 1,NGLLSQUARE

! get velocity on the solid side using pointwise matching
          ispec_selected = ibelm_bottom_crust_mantle(ispec2D)

! corresponding points are located at the bottom of the mantle
          k_corresp = 1
          iglob = ibool_crust_mantle(ij,1,k_corresp,ispec_selected)

          vx = displ_crust_mantle(1,iglob)
          vy = displ_crust_mantle(2,iglob)
          vz = displ_crust_mantle(3,iglob)

! get global point number
          iglob = ibool_outer_core(ij,1,k,ispec)

! get normal on the CMB
          nx = normal_top_outer_core(1,ij,1,ispec2D)
          ny = normal_top_outer_core(2,ij,1,ispec2D)
          nz = normal_top_outer_core(3,ij,1,ispec2D)

! compute dot product
          vn = vx*nx+vy*ny+vz*nz

! formulation with generalized potential
          weight = jacobian2D_top_outer_core(ij,1,ispec2D)*wgllwgll_xy(ij,1)

          accel_outer_core(iglob) = accel_outer_core(iglob) + weight*vn

      enddo
    enddo

    endif

!---
!--- couple with inner core at the bottom of the outer core
!---

  if(ACTUALLY_COUPLE_FLUID_ICB .and. .not. REGIONAL_CODE) then

! for surface elements exactly on the ICB
!CDIR NOVECTOR
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)

      ispec = ibelm_bottom_outer_core(ispec2D)

! only for DOFs exactly on the ICB (bottom of these elements)
      k = 1

!CDIR NODEP(accel_outer_core)
      do ij = 1,NGLLSQUARE

! get velocity on the solid side using pointwise matching
          ispec_selected = ibelm_top_inner_core(ispec2D)

! corresponding points are located at the bottom of the mantle
          k_corresp = NGLLZ
          iglob = ibool_inner_core(ij,1,k_corresp,ispec_selected)

          vx = displ_inner_core(1,iglob)
          vy = displ_inner_core(2,iglob)
          vz = displ_inner_core(3,iglob)

! get global point number
          iglob = ibool_outer_core(ij,1,k,ispec)

! get normal on the ICB
          nx = normal_bottom_outer_core(1,ij,1,ispec2D)
          ny = normal_bottom_outer_core(2,ij,1,ispec2D)
          nz = normal_bottom_outer_core(3,ij,1,ispec2D)

! compute dot product
          vn = vx*nx+vy*ny+vz*nz

! formulation with generalized potential
          weight = jacobian2D_bottom_outer_core(ij,1,ispec2D)*wgllwgll_xy(ij,1)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*vn

      enddo
    enddo

  endif

! assemble all the contributions between slices using MPI

! outer core
  call assemble_MPI_scalar(myrank,accel_outer_core,nglob_outer_core, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_outer_core,iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core, &
            npoin2D_faces_outer_core,npoin2D_xi_outer_core,npoin2D_eta_outer_core, &
            iboolfaces_outer_core,iboolcorner_outer_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
            buffer_send_faces,buffer_received_faces, &
            buffer_send_chunk_corners,buffer_received_chunk_corners, &
            NUMMSGS_FACES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_OUTER_CORE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE),NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE),NPOIN2DMAX_XY)

! multiply by the inverse of the mass matrix and update velocity

  do i=1,nglob_outer_core
    accel_outer_core(i) = accel_outer_core(i)*rmass_outer_core(i)
    veloc_outer_core(i) = veloc_outer_core(i) + deltatover2*accel_outer_core(i)
  enddo

! ****************************************************
!   big loop over all spectral elements in the solid
! ****************************************************

! compute internal forces in the solid regions

! for anisotropy and gravity, x y and z contain r theta and phi
  call compute_forces_crust_mantle(ell_d80,minus_gravity_table,density_table,minus_deriv_gravity_table, &
          nspec_crust_mantle,displ_crust_mantle,accel_crust_mantle, &
          xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
          xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle, &
          etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
          gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,jacobian_crust_mantle, &
          hprime_xx,hprime_yy,hprime_zz, &
          hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
          wgll_cube,wgllwgll_yz_no_i,wgllwgll_xz_no_j,wgllwgll_xy_no_k, &
          kappavstore_crust_mantle,kappahstore_crust_mantle,muvstore_crust_mantle, &
          muhstore_crust_mantle,eta_anisostore_crust_mantle, &
          c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle, &
          c14store_crust_mantle,c15store_crust_mantle,c16store_crust_mantle, &
          c22store_crust_mantle,c23store_crust_mantle,c24store_crust_mantle, &
          c25store_crust_mantle,c26store_crust_mantle,c33store_crust_mantle, &
          c34store_crust_mantle,c35store_crust_mantle,c36store_crust_mantle, &
          c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
          c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
          ibool_crust_mantle,idoubling_crust_mantle, &
          R_memory_crust_mantle,epsilondev_crust_mantle,one_minus_sum_beta, &
          alphaval,betaval,gammaval,factor_common,index_i,index_k,index_dim)

! JT JT Stacey

  if(REGIONAL_CODE .and. STACEY_ABS_CONDITIONS) then

! crust & mantle

!   xmin
    do ispec2D=1,nspec2D_xmin_crust_mantle

      ispec=ibelm_xmin_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_xi_crust_mantle(1,ispec2D) == 0 .or. njmin_crust_mantle(1,ispec2D) == 0) cycle

      i=1
!CDIR NODEP(accel_crust_mantle)
      do jk=1,stacey_crust_mantle_xmin_jk(ispec2D)

        j = stacey_crust_mantle_xmin_j(jk,ispec2D)
        k = stacey_crust_mantle_xmin_k(jk,ispec2D)
        ijk = i + (j-1)*NGLLX + (k-1)*NGLLSQUARE

        iglob=ibool_crust_mantle(ijk,1,1,ispec)

        vx=veloc_crust_mantle(1,iglob)
        vy=veloc_crust_mantle(2,iglob)
        vz=veloc_crust_mantle(3,iglob)

        nx=normal_xmin_crust_mantle(1,j,k,ispec2D)
        ny=normal_xmin_crust_mantle(2,j,k,ispec2D)
        nz=normal_xmin_crust_mantle(3,j,k,ispec2D)

        vn=vx*nx+vy*ny+vz*nz

        tx=rho_vp_crust_mantle(ijk,1,1,ispec)*vn*nx+rho_vs_crust_mantle(ijk,1,1,ispec)*(vx-vn*nx)
        ty=rho_vp_crust_mantle(ijk,1,1,ispec)*vn*ny+rho_vs_crust_mantle(ijk,1,1,ispec)*(vy-vn*ny)
        tz=rho_vp_crust_mantle(ijk,1,1,ispec)*vn*nz+rho_vs_crust_mantle(ijk,1,1,ispec)*(vz-vn*nz)

        weight=jacobian2D_xmin_crust_mantle(j,k,ispec2D)*wgllwgll_yz(j,k)

        accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
        accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
        accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

      enddo
    enddo

!   xmax
!CDIR NOVECTOR
    do ispec2D=1,nspec2D_xmax_crust_mantle

      ispec=ibelm_xmax_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_xi_crust_mantle(2,ispec2D) == 0 .or. njmin_crust_mantle(2,ispec2D) == 0) cycle

      i=NGLLX
!CDIR NODEP(accel_crust_mantle) 
      do jk=1,stacey_crust_mantle_xmax_jk(ispec2D)

        j = stacey_crust_mantle_xmax_j(jk,ispec2D)
        k = stacey_crust_mantle_xmax_k(jk,ispec2D)
        ijk = i + (j-1)*NGLLX + (k-1)*NGLLSQUARE

        iglob=ibool_crust_mantle(ijk,1,1,ispec)

        vx=veloc_crust_mantle(1,iglob)
        vy=veloc_crust_mantle(2,iglob)
        vz=veloc_crust_mantle(3,iglob)

        nx=normal_xmax_crust_mantle(1,j,k,ispec2D)
        ny=normal_xmax_crust_mantle(2,j,k,ispec2D)
        nz=normal_xmax_crust_mantle(3,j,k,ispec2D)

        vn=vx*nx+vy*ny+vz*nz

        tx=rho_vp_crust_mantle(ijk,1,1,ispec)*vn*nx+rho_vs_crust_mantle(ijk,1,1,ispec)*(vx-vn*nx)
        ty=rho_vp_crust_mantle(ijk,1,1,ispec)*vn*ny+rho_vs_crust_mantle(ijk,1,1,ispec)*(vy-vn*ny)
        tz=rho_vp_crust_mantle(ijk,1,1,ispec)*vn*nz+rho_vs_crust_mantle(ijk,1,1,ispec)*(vz-vn*nz)

        weight=jacobian2D_xmax_crust_mantle(j,k,ispec2D)*wgllwgll_yz(j,k)

        accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
        accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
        accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

      enddo
    enddo

!   ymin
!CDIR NOVECTOR
    do ispec2D=1,nspec2D_ymin_crust_mantle

      ispec=ibelm_ymin_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_eta_crust_mantle(1,ispec2D) == 0 .or. nimin_crust_mantle(1,ispec2D) == 0) cycle

      j=1
!CDIR NODEP(accel_crust_mantle) 
      do ik=1,stacey_crust_mantle_ymin_ik(ispec2D)

        i = stacey_crust_mantle_ymin_i(ik,ispec2D)
        k = stacey_crust_mantle_ymin_k(ik,ispec2D)
        ijk = i + (j-1)*NGLLX + (k-1)*NGLLSQUARE

        iglob=ibool_crust_mantle(ijk,1,1,ispec)

        vx=veloc_crust_mantle(1,iglob)
        vy=veloc_crust_mantle(2,iglob)
        vz=veloc_crust_mantle(3,iglob)

        nx=normal_ymin_crust_mantle(1,i,k,ispec2D)
        ny=normal_ymin_crust_mantle(2,i,k,ispec2D)
        nz=normal_ymin_crust_mantle(3,i,k,ispec2D)

        vn=vx*nx+vy*ny+vz*nz

        tx=rho_vp_crust_mantle(ijk,1,1,ispec)*vn*nx+rho_vs_crust_mantle(ijk,1,1,ispec)*(vx-vn*nx)
        ty=rho_vp_crust_mantle(ijk,1,1,ispec)*vn*ny+rho_vs_crust_mantle(ijk,1,1,ispec)*(vy-vn*ny)
        tz=rho_vp_crust_mantle(ijk,1,1,ispec)*vn*nz+rho_vs_crust_mantle(ijk,1,1,ispec)*(vz-vn*nz)

        weight=jacobian2D_ymin_crust_mantle(i,k,ispec2D)*wgllwgll_xz(i,k)

        accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
        accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
        accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

      enddo
    enddo

!   ymax
!CDIR NOVECTOR
    do ispec2D=1,nspec2D_ymax_crust_mantle

      ispec=ibelm_ymax_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_eta_crust_mantle(2,ispec2D) == 0 .or. nimin_crust_mantle(2,ispec2D) == 0) cycle

      j=NGLLY
!CDIR NODEP(accel_crust_mantle) 
      do ik=1,stacey_crust_mantle_ymax_ik(ispec2D)

        i = stacey_crust_mantle_ymax_i(ik,ispec2D)
        k = stacey_crust_mantle_ymax_k(ik,ispec2D)
        ijk = i + (j-1)*NGLLX + (k-1)*NGLLSQUARE

        iglob=ibool_crust_mantle(ijk,1,1,ispec)

        vx=veloc_crust_mantle(1,iglob)
        vy=veloc_crust_mantle(2,iglob)
        vz=veloc_crust_mantle(3,iglob)

        nx=normal_ymax_crust_mantle(1,i,k,ispec2D)
        ny=normal_ymax_crust_mantle(2,i,k,ispec2D)
        nz=normal_ymax_crust_mantle(3,i,k,ispec2D)

        vn=vx*nx+vy*ny+vz*nz

        tx=rho_vp_crust_mantle(ijk,1,1,ispec)*vn*nx+rho_vs_crust_mantle(ijk,1,1,ispec)*(vx-vn*nx)
        ty=rho_vp_crust_mantle(ijk,1,1,ispec)*vn*ny+rho_vs_crust_mantle(ijk,1,1,ispec)*(vy-vn*ny)
        tz=rho_vp_crust_mantle(ijk,1,1,ispec)*vn*nz+rho_vs_crust_mantle(ijk,1,1,ispec)*(vz-vn*nz)

        weight=jacobian2D_ymax_crust_mantle(i,k,ispec2D)*wgllwgll_xz(i,k)

        accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
        accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
        accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

      enddo
    enddo

  endif ! Stacey conditions


  call compute_forces_inner_core(minus_gravity_table,density_table,minus_deriv_gravity_table, &
          displ_inner_core,accel_inner_core, &
          xstore_inner_core,ystore_inner_core,zstore_inner_core, &
          xix_inner_core,xiy_inner_core,xiz_inner_core, &
          etax_inner_core,etay_inner_core,etaz_inner_core, &
          gammax_inner_core,gammay_inner_core,gammaz_inner_core,jacobian_inner_core, &
          hprime_xx,hprime_yy,hprime_zz, &
          hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
          wgll_cube,wgllwgll_yz_no_i,wgllwgll_xz_no_j,wgllwgll_xy_no_k, &
          kappavstore_inner_core,muvstore_inner_core,ibool_inner_core,idoubling_inner_core, &
          c11store_inner_core,c33store_inner_core,c12store_inner_core,c13store_inner_core,c44store_inner_core, &
          R_memory_inner_core,epsilondev_inner_core,one_minus_sum_beta, &
          alphaval,betaval,gammaval,factor_common,index_i,index_k,index_dim)

!CDIR NOVECTOR
  do isource = 1,NSOURCES

!   add the source (only if this proc carries the source)
    if(myrank == islice_selected_source(isource)) then

      stf = comp_source_time_function(dble(it-1)*DT-hdur(isource)-t_cmt(isource),hdur(isource))

!     distinguish whether single or double precision for reals
      if(CUSTOM_REAL == SIZE_REAL) then
        stf_used = sngl(stf)
      else
        stf_used = stf
      endif

!     add source array
!CDIR NODEP(accel_crust_mantle)
      do ijk=1,NGLLCUBE
        iglob = ibool_crust_mantle(ijk,1,1,ispec_selected_source(isource))
        accel_crust_mantle(1,iglob) = accel_crust_mantle(1,iglob) + sourcearrays(isource,1,ijk,1,1)*stf_used
        accel_crust_mantle(2,iglob) = accel_crust_mantle(2,iglob) + sourcearrays(isource,2,ijk,1,1)*stf_used
        accel_crust_mantle(3,iglob) = accel_crust_mantle(3,iglob) + sourcearrays(isource,3,ijk,1,1)*stf_used
      enddo

    endif

  enddo

! ****************************************************
! **********  add matching with fluid part  **********
! ****************************************************

! only for elements in first matching layer in the solid

!---
!--- couple with outer core at the bottom of the mantle
!---

  if(ACTUALLY_COUPLE_FLUID_CMB) then

! for surface elements exactly on the CMB
!CDIR NOVECTOR
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_CRUST_MANTLE)

      ispec = ibelm_bottom_crust_mantle(ispec2D)

! only for DOFs exactly on the CMB (bottom of these elements)
      k = 1

!CDIR NODEP(accel_crust_mantle)
      do ij = 1,NGLLSQUARE

! get velocity potential on the fluid side using pointwise matching
          ispec_selected = ibelm_top_outer_core(ispec2D)
          k_corresp = NGLLZ

! get normal at the CMB
          nx = normal_top_outer_core(1,ij,1,ispec2D)
          ny = normal_top_outer_core(2,ij,1,ispec2D)
          nz = normal_top_outer_core(3,ij,1,ispec2D)

! get global point number
! corresponding points are located at the top of the outer core
          iglob = ibool_outer_core(ij,1,NGLLZ,ispec_selected)
          iglob_mantle = ibool_crust_mantle(ij,1,k,ispec)

! compute pressure, taking gravity into account
          if(GRAVITY_VAL) then
            pressure = RHO_TOP_OC * (- accel_outer_core(iglob) &
               + minus_g_cmb *(displ_crust_mantle(1,iglob_mantle)*nx &
               + displ_crust_mantle(2,iglob_mantle)*ny + displ_crust_mantle(3,iglob_mantle)*nz))
          else
            pressure = - RHO_TOP_OC * accel_outer_core(iglob)
          endif

! formulation with generalized potential
          weight = jacobian2D_top_outer_core(ij,1,ispec2D)*wgllwgll_xy(ij,1)

          accel_crust_mantle(1,iglob_mantle) = accel_crust_mantle(1,iglob_mantle) + weight*nx*pressure
          accel_crust_mantle(2,iglob_mantle) = accel_crust_mantle(2,iglob_mantle) + weight*ny*pressure
          accel_crust_mantle(3,iglob_mantle) = accel_crust_mantle(3,iglob_mantle) + weight*nz*pressure

      enddo
    enddo

  endif

!---
!--- couple with outer core at the top of the inner core
!---

  if(ACTUALLY_COUPLE_FLUID_ICB .and. .not. REGIONAL_CODE) then

! for surface elements exactly on the ICB
!CDIR NOVECTOR
    do ispec2D = 1,NSPEC2D_TOP(IREGION_INNER_CORE)

      ispec = ibelm_top_inner_core(ispec2D)

! only for DOFs exactly on the ICB (top of these elements)
      k = NGLLZ

!CDIR NODEP(accel_inner_core)
      do ij = 1,NGLLSQUARE

! get velocity potential on the fluid side using pointwise matching
          ispec_selected = ibelm_bottom_outer_core(ispec2D)
          k_corresp = 1

! get normal at the ICB
          nx = normal_bottom_outer_core(1,ij,1,ispec2D)
          ny = normal_bottom_outer_core(2,ij,1,ispec2D)
          nz = normal_bottom_outer_core(3,ij,1,ispec2D)

! get global point number
! corresponding points are located at the bottom of the outer core
          iglob = ibool_outer_core(ij,1,k_corresp,ispec_selected)
          iglob_inner_core = ibool_inner_core(ij,1,k,ispec)

! compute pressure, taking gravity into account
          if(GRAVITY_VAL) then
            pressure = RHO_BOTTOM_OC * (- accel_outer_core(iglob) &
               + minus_g_icb *(displ_inner_core(1,iglob_inner_core)*nx &
               + displ_inner_core(2,iglob_inner_core)*ny + displ_inner_core(3,iglob_inner_core)*nz))
          else
            pressure = - RHO_BOTTOM_OC * accel_outer_core(iglob)
          endif

! formulation with generalized potential
          weight = jacobian2D_bottom_outer_core(ij,1,ispec2D)*wgllwgll_xy(ij,1)

          accel_inner_core(1,iglob_inner_core) = accel_inner_core(1,iglob_inner_core) - weight*nx*pressure
          accel_inner_core(2,iglob_inner_core) = accel_inner_core(2,iglob_inner_core) - weight*ny*pressure
          accel_inner_core(3,iglob_inner_core) = accel_inner_core(3,iglob_inner_core) - weight*nz*pressure

      enddo
    enddo

    endif

! assemble all the contributions between slices using MPI

! crust and mantle
  call assemble_MPI_vector(myrank,accel_crust_mantle,nglob_crust_mantle, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_crust_mantle,iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
            npoin2D_faces_crust_mantle,npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
            iboolfaces_crust_mantle,iboolcorner_crust_mantle, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
            buffer_send_faces,buffer_received_faces, &
            buffer_send_chunk_corners,buffer_received_chunk_corners, &
            NUMMSGS_FACES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_XY)

! inner core
  call assemble_MPI_vector(myrank,accel_inner_core,NGLOB_INNER_CORE, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_inner_core,iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core, &
            npoin2D_faces_inner_core,npoin2D_xi_inner_core,npoin2D_eta_inner_core, &
            iboolfaces_inner_core,iboolcorner_inner_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
            buffer_send_faces,buffer_received_faces, &
            buffer_send_chunk_corners,buffer_received_chunk_corners, &
            NUMMSGS_FACES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_INNER_CORE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE),NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE),NPOIN2DMAX_XY)

!---
!---  use buffers to assemble forces with the central cube
!---

  if(INCLUDE_CENTRAL_CUBE) then

! on chunk AB, receive all the messages from slices
  if(ichunk == CHUNK_AB) then

   do imsg = 1,nb_msgs_theor_in_cube

! receive buffers from slices
  isender = sender_from_slices_to_cube(imsg)
  call MPI_RECV(buffer_slices, &
              NDIM*npoin2D_cube_from_slices,MPI_DOUBLE_PRECISION,isender, &
              itag,MPI_COMM_WORLD,msg_status,ier)

! copy buffer in 2D array for each slice
     do ipoin = 1,npoin2D_cube_from_slices
       buffer_all_cube_from_slices(imsg,ipoin,1) = buffer_slices(ipoin,1)
       buffer_all_cube_from_slices(imsg,ipoin,2) = buffer_slices(ipoin,2)
       buffer_all_cube_from_slices(imsg,ipoin,3) = buffer_slices(ipoin,3)
     enddo

   enddo
   endif


! send info to central cube from all the slices except those in CHUNK_AB
  if(ichunk /= CHUNK_AB) then

! for bottom elements in contact with central cube from the slices side
    ipoin = 0

    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_INNER_CORE)

      ispec = ibelm_bottom_inner_core(ispec2D)

! only for DOFs exactly on surface of central cube (bottom of these elements)
      k = 1
      do ij = 1,NGLLSQUARE
        ipoin = ipoin + 1
        buffer_slices(ipoin,1) = dble(accel_inner_core(1,ibool_inner_core(ij,1,k,ispec)))
        buffer_slices(ipoin,2) = dble(accel_inner_core(2,ibool_inner_core(ij,1,k,ispec)))
        buffer_slices(ipoin,3) = dble(accel_inner_core(3,ibool_inner_core(ij,1,k,ispec)))
      enddo
    enddo

! send buffer to central cube
    ireceiver = receiver_cube_from_slices
    call MPI_SEND(buffer_slices,NDIM*npoin2D_cube_from_slices, &
              MPI_DOUBLE_PRECISION,ireceiver,itag,MPI_COMM_WORLD,ier)

 endif  ! end sending info to central cube

!--- now we need to assemble the contributions

  if(ichunk == CHUNK_AB) then

! loop on the three dimensions of the array
  do idimension = 1,NDIM

! erase contributions to central cube array
  array_central_cube(:) = 0._CUSTOM_REAL

! use indirect addressing to store contributions only once
! distinguish whether single or double precision for reals
   do imsg = 1,nb_msgs_theor_in_cube
   do ipoin = 1,npoin2D_cube_from_slices
     if(CUSTOM_REAL == SIZE_REAL) then
       array_central_cube(ibool_central_cube(imsg,ipoin)) = sngl(buffer_all_cube_from_slices(imsg,ipoin,idimension))
     else
       array_central_cube(ibool_central_cube(imsg,ipoin)) = buffer_all_cube_from_slices(imsg,ipoin,idimension)
     endif
   enddo
   enddo

! suppress degrees of freedom already assembled at top of cube on edges
  do ispec = 1,NSPEC_INNER_CORE
    if(idoubling_inner_core(ispec) == IFLAG_TOP_CENTRAL_CUBE) then
      k = NGLLZ
      do ij = 1,NGLLSQUARE
        array_central_cube(ibool_inner_core(ij,1,k,ispec)) = 0._CUSTOM_REAL
      enddo
    endif
  enddo

! assemble contributions
  accel_inner_core(idimension,:) = accel_inner_core(idimension,:) + array_central_cube(:)

! copy sum back
   do imsg = 1,nb_msgs_theor_in_cube
   do ipoin = 1,npoin2D_cube_from_slices
     buffer_all_cube_from_slices(imsg,ipoin,idimension) = accel_inner_core(idimension,ibool_central_cube(imsg,ipoin))
   enddo
   enddo

   enddo

   endif


!----------

! receive info from central cube on all the slices except those in CHUNK_AB
  if(ichunk /= CHUNK_AB) then

! receive buffers from slices
  isender = receiver_cube_from_slices
  call MPI_RECV(buffer_slices, &
              NDIM*npoin2D_cube_from_slices,MPI_DOUBLE_PRECISION,isender, &
              itag,MPI_COMM_WORLD,msg_status,ier)

! for bottom elements in contact with central cube from the slices side
    ipoin = 0

    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_INNER_CORE)

      ispec = ibelm_bottom_inner_core(ispec2D)

! only for DOFs exactly on surface of central cube (bottom of these elements)
      k = 1
      do ij = 1,NGLLSQUARE
        ipoin = ipoin + 1

! distinguish whether single or double precision for reals
        if(CUSTOM_REAL == SIZE_REAL) then
          accel_inner_core(1,ibool_inner_core(ij,1,k,ispec)) = sngl(buffer_slices(ipoin,1))
          accel_inner_core(2,ibool_inner_core(ij,1,k,ispec)) = sngl(buffer_slices(ipoin,2))
          accel_inner_core(3,ibool_inner_core(ij,1,k,ispec)) = sngl(buffer_slices(ipoin,3))
        else
          accel_inner_core(1,ibool_inner_core(ij,1,k,ispec)) = buffer_slices(ipoin,1)
          accel_inner_core(2,ibool_inner_core(ij,1,k,ispec)) = buffer_slices(ipoin,2)
          accel_inner_core(3,ibool_inner_core(ij,1,k,ispec)) = buffer_slices(ipoin,3)
        endif

      enddo
    enddo

 endif  ! end receiving info from central cube

!------- send info back from central cube to slices

! on chunk AB, send all the messages to slices
  if(ichunk == CHUNK_AB) then

   do imsg = 1,nb_msgs_theor_in_cube

! copy buffer in 2D array for each slice
     do ipoin = 1,npoin2D_cube_from_slices
       buffer_slices(ipoin,1) = buffer_all_cube_from_slices(imsg,ipoin,1)
       buffer_slices(ipoin,2) = buffer_all_cube_from_slices(imsg,ipoin,2)
       buffer_slices(ipoin,3) = buffer_all_cube_from_slices(imsg,ipoin,3)
     enddo

! send buffers to slices
    ireceiver = sender_from_slices_to_cube(imsg)
    call MPI_SEND(buffer_slices,NDIM*npoin2D_cube_from_slices, &
              MPI_DOUBLE_PRECISION,ireceiver,itag,MPI_COMM_WORLD,ier)

   enddo
   endif

  endif   ! end of assembling forces with the central cube

  if(ROTATION_VAL) then
    do i=1,nglob_crust_mantle
      accel_crust_mantle(1,i) = accel_crust_mantle(1,i)*rmass_crust_mantle(i) &
               + two_omega_earth*veloc_crust_mantle(2,i)
      accel_crust_mantle(2,i) = accel_crust_mantle(2,i)*rmass_crust_mantle(i) &
               - two_omega_earth*veloc_crust_mantle(1,i)
      accel_crust_mantle(3,i) = accel_crust_mantle(3,i)*rmass_crust_mantle(i)
    enddo
  else
    do i=1,nglob_crust_mantle
      accel_crust_mantle(1,i) = accel_crust_mantle(1,i)*rmass_crust_mantle(i)
      accel_crust_mantle(2,i) = accel_crust_mantle(2,i)*rmass_crust_mantle(i)
      accel_crust_mantle(3,i) = accel_crust_mantle(3,i)*rmass_crust_mantle(i)
    enddo
  endif

  if(OCEANS) then

!   initialize the updates
    updated_dof_ocean_load(:) = .false.

! for surface elements exactly at the top of the crust (ocean bottom)
!CDIR NOVECTOR
    do ispec2D = 1,NSPEC2D_TOP(IREGION_CRUST_MANTLE)

      ispec = ibelm_top_crust_mantle(ispec2D)

! only for DOFs exactly at the top of the crust (ocean bottom)
      k = NGLLZ

!CDIR NODEP(accel_crust_mantle,updated_dof_ocean_load)
      do ij = 1,NGLLSQUARE

! get global point number
        iglob = ibool_crust_mantle(ij,1,k,ispec)

! only update once
        if(.not. updated_dof_ocean_load(iglob)) then

! get normal
          nx = normal_top_crust_mantle(1,ij,1,ispec2D)
          ny = normal_top_crust_mantle(2,ij,1,ispec2D)
          nz = normal_top_crust_mantle(3,ij,1,ispec2D)

! make updated component of right-hand side
! we divide by rmass_crust_mantle() which is 1 / M
! we use the total force which includes the Coriolis term above
          force_normal_comp = (accel_crust_mantle(1,iglob)*nx + &
               accel_crust_mantle(2,iglob)*ny + &
               accel_crust_mantle(3,iglob)*nz) / rmass_crust_mantle(iglob)

          additional_term = (rmass_ocean_load(iglob) - rmass_crust_mantle(iglob)) * force_normal_comp

          accel_crust_mantle(1,iglob) = accel_crust_mantle(1,iglob) + additional_term * nx
          accel_crust_mantle(2,iglob) = accel_crust_mantle(2,iglob) + additional_term * ny
          accel_crust_mantle(3,iglob) = accel_crust_mantle(3,iglob) + additional_term * nz

!         done with this point
          updated_dof_ocean_load(iglob) = .true.

        endif
      enddo

    enddo
  endif

! for longer vectors
!CDIR NOASSUME
  do i=1,nglob_crust_mantle_ndim
    veloc_crust_mantle(i,1) = veloc_crust_mantle(i,1) + deltatover2*accel_crust_mantle(i,1)
  enddo

  if(ROTATION_VAL) then
    do i=1,NGLOB_INNER_CORE
      accel_inner_core(1,i) = accel_inner_core(1,i)*rmass_inner_core(i) &
             + two_omega_earth*veloc_inner_core(2,i)
      accel_inner_core(2,i) = accel_inner_core(2,i)*rmass_inner_core(i) &
             - two_omega_earth*veloc_inner_core(1,i)
      accel_inner_core(3,i) = accel_inner_core(3,i)*rmass_inner_core(i)
    enddo
  else
    do i=1,NGLOB_INNER_CORE
      accel_inner_core(1,i) = accel_inner_core(1,i)*rmass_inner_core(i)
      accel_inner_core(2,i) = accel_inner_core(2,i)*rmass_inner_core(i)
      accel_inner_core(3,i) = accel_inner_core(3,i)*rmass_inner_core(i)
    enddo
  endif

! for longer vectors
!CDIR NOASSUME
  do i=1,NGLOB_INNER_CORE*NDIM
    veloc_inner_core(i,1) = veloc_inner_core(i,1) + deltatover2*accel_inner_core(i,1)
  enddo

! write the seismograms with time shift

  do irec_local = 1,nrec_local

! get global number of that receiver
    irec = number_receiver_global(irec_local)

! perform the general interpolation using Lagrange polynomials
        uxd = ZERO
        uyd = ZERO
        uzd = ZERO

        do k = 1,NGLLZ
          do ij = 1,NGLLSQUARE

            iglob = ibool_crust_mantle(ij,1,k,ispec_selected_rec(irec))
            hlagrange_val = hlagrange(irec_local,ij,1,k)

            uxd = uxd + dble(displ_crust_mantle(1,iglob))*hlagrange_val
            uyd = uyd + dble(displ_crust_mantle(2,iglob))*hlagrange_val
            uzd = uzd + dble(displ_crust_mantle(3,iglob))*hlagrange_val

          enddo
        enddo

! store North, East and Vertical components

! distinguish whether single or double precision for reals
      if(CUSTOM_REAL == SIZE_REAL) then
        seismograms(1,irec_local,it) = sngl(scale_displ*(nu(1,1,irec)*uxd + &
                          nu(1,2,irec)*uyd + nu(1,3,irec)*uzd))
        seismograms(2,irec_local,it) = sngl(scale_displ*(nu(2,1,irec)*uxd + &
                          nu(2,2,irec)*uyd + nu(2,3,irec)*uzd))
        seismograms(3,irec_local,it) = sngl(scale_displ*(nu(3,1,irec)*uxd + &
                          nu(3,2,irec)*uyd + nu(3,3,irec)*uzd))
      else
        seismograms(1,irec_local,it) = scale_displ*(nu(1,1,irec)*uxd + &
                          nu(1,2,irec)*uyd + nu(1,3,irec)*uzd)
        seismograms(2,irec_local,it) = scale_displ*(nu(2,1,irec)*uxd + &
                          nu(2,2,irec)*uyd + nu(2,3,irec)*uzd)
        seismograms(3,irec_local,it) = scale_displ*(nu(3,1,irec)*uxd + &
                          nu(3,2,irec)*uyd + nu(3,3,irec)*uzd)
      endif

  enddo

! write the current seismograms
  if(mod(it,NSEIS) == 0) &
      call write_seismograms(myrank,seismograms,number_receiver_global,station_name, &
              network_name,nrec,nrec_local,DT,NSTEP,hdur(1),LOCAL_PATH,it_begin,it_end)

! save movie frame
  if(MOVIE_SURFACE .and. mod(it,NMOVIE) == 0) then

! save velocity here to avoid static offset on displacement for movies

! rescale non-dimensional velocity to right units
! check if this formula is correct
      scale_veloc = scale_displ / scale_t

! get coordinates of surface mesh and surface displacement
    ipoin = 0
    do ispec2D = 1,NSPEC2D_TOP(IREGION_CRUST_MANTLE)
      ispec = ibelm_top_crust_mantle(ispec2D)
      k = NGLLZ

! loop on all the points inside the element
      do j = 1,NGLLY
        do i = 1,NGLLX
          ipoin = ipoin + 1
          iglob = ibool_crust_mantle(i,j,k,ispec)
          store_val_x(ipoin) = xstore_crust_mantle(iglob)
          store_val_y(ipoin) = ystore_crust_mantle(iglob)
          store_val_z(ipoin) = zstore_crust_mantle(iglob)
          store_val_ux(ipoin) = veloc_crust_mantle(1,iglob)
          store_val_uy(ipoin) = veloc_crust_mantle(2,iglob)
          store_val_uz(ipoin) = veloc_crust_mantle(3,iglob)
        enddo
      enddo

    enddo

! gather info on master proc
    ispec = NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE)
    call MPI_GATHER(store_val_x,ispec,CUSTOM_MPI_TYPE,store_val_x_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_y,ispec,CUSTOM_MPI_TYPE,store_val_y_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_z,ispec,CUSTOM_MPI_TYPE,store_val_z_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_ux,ispec,CUSTOM_MPI_TYPE,store_val_ux_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_uy,ispec,CUSTOM_MPI_TYPE,store_val_uy_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_uz,ispec,CUSTOM_MPI_TYPE,store_val_uz_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)

! save movie data to disk in home directory
    if(myrank == 0) then
      write(outputname,"('OUTPUT_FILES/moviedata',i6.6)") it
      open(unit=IOUT,file=outputname,status='unknown',form='unformatted')
      write(IOUT) store_val_x_all
      write(IOUT) store_val_y_all
      write(IOUT) store_val_z_all
      write(IOUT) store_val_ux_all
      write(IOUT) store_val_uy_all
      write(IOUT) store_val_uz_all
      close(IOUT)
    endif

  endif

!
!---- end of time iteration loop
!
  enddo   ! end of main time loop

! write the final seismograms
  call write_seismograms(myrank,seismograms,number_receiver_global,station_name, &
          network_name,nrec,nrec_local,DT,NSTEP,hdur(1),LOCAL_PATH,it_begin,it_end)

! save files to local disk or MT tape system if restart file
  if(NUMBER_OF_RUNS > 1 .and. NUMBER_OF_THIS_RUN < NUMBER_OF_RUNS) then
    write(outputname,"('dump_all_arrays',i4.4)") myrank
    open(unit=55,file=final_LOCAL_PATH(1:len_trim(final_LOCAL_PATH))//outputname,status='unknown',form='unformatted')
    write(55) displ_crust_mantle
    write(55) veloc_crust_mantle
    write(55) accel_crust_mantle
    write(55) displ_inner_core
    write(55) veloc_inner_core
    write(55) accel_inner_core
    write(55) displ_outer_core
    write(55) veloc_outer_core
    write(55) accel_outer_core
    write(55) R_memory_crust_mantle
    write(55) R_memory_inner_core
    write(55) epsilondev_crust_mantle
    write(55) epsilondev_inner_core
    write(55) A_array_rotation
    write(55) B_array_rotation
    close(55)
  endif

! close the main output file
  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'End of the simulation'
    write(IMAIN,*)
    close(IMAIN)
  endif

! synchronize all the processes to make sure everybody has finished
  call MPI_BARRIER(MPI_COMM_WORLD,ier)

! stop all the MPI processes, and exit
  call MPI_FINALIZE(ier)

  end program specfem3D

