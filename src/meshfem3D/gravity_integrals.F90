!=====================================================================
!
!                       S p e c f e m 3 D  G l o b e
!                       ----------------------------
!
!     Main historical authors: Dimitri Komatitsch and Jeroen Tromp
!                        Princeton University, USA
!                and CNRS / University of Marseille, France
!                 (there are currently many more authors!)
! (c) Princeton University and CNRS / University of Marseille, April 2014
!
! This program is free software; you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation; either version 3 of the License, or
! (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License along
! with this program; if not, write to the Free Software Foundation, Inc.,
! 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
!
!=====================================================================

! routines compute the gravity field as well as its derivatives (i.e., gravity gradiometry)
! generated by any given 3D Earth model at the height of an observation satellite, for instance GOCE
!
! see e.g.: https://en.wikipedia.org/wiki/Gravity_Field_and_Steady-State_Ocean_Circulation_Explorer


  subroutine gravity_initialize_integrals()

! initializes integrals

  use constants, only: myrank,IMAIN,ZERO,CUSTOM_REAL,SIZE_DOUBLE, &
    GRAVITY_INTEGRALS,REUSE_EXISTING_OBSERVATION_SURF, &
    ONLY_COMPUTE_CENTER_OF_MASS,COMPUTE_CRUST_CONTRIB_ONLY,SHIFT_TO_THIS_CENTER_OF_MASS, &
    NX_OBSERVATION,NY_OBSERVATION, &
    x_shift,y_shift,z_shift

  use meshfem_par, only: g_x,g_y,g_z,G_xx,G_yy,G_zz,G_xy,G_xz,G_yz

  implicit none

  ! safety check
  if (.not. GRAVITY_INTEGRALS) stop 'Invalid calling gravity initialization'

  ! user output
  if (myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) '***'
    write(IMAIN,*) 'gravity integrals computation'
    write(IMAIN,*) '***'
    write(IMAIN,*)
    if (REUSE_EXISTING_OBSERVATION_SURF) &
      write(IMAIN,*) 'reusing existing observation surface'
    if (ONLY_COMPUTE_CENTER_OF_MASS) &
      write(IMAIN,*) 'only computing center of mass'
    if (COMPUTE_CRUST_CONTRIB_ONLY) &
      write(IMAIN,*) 'only computing crust contribution'
    if (SHIFT_TO_THIS_CENTER_OF_MASS) then
      write(IMAIN,*) 'shifting to center of mass:'
      write(IMAIN,*) '  new center position x/y/z =  ',sngl(x_shift),'/',sngl(y_shift),'/',sngl(z_shift)
    endif
    write(IMAIN,*)
    write(IMAIN,*) 'array size for number of observation nx/ny = ',NX_OBSERVATION,NY_OBSERVATION
    write(IMAIN,*) '***'
    write(IMAIN,*)
    call flush_IMAIN()
  endif

  ! checks
  ! in the case of GRAVITY_INTEGRALS we should always use double precision
  if (CUSTOM_REAL /= SIZE_DOUBLE) &
    call exit_MPI(myrank,'for GRAVITY_INTEGRALS use double precision i.e. configure the code with --enable-double-precision')

  ! makes sure we integrate from zero
  g_x(:,:,:) = ZERO
  g_y(:,:,:) = ZERO
  g_z(:,:,:) = ZERO

  G_xx(:,:,:) = ZERO
  G_yy(:,:,:) = ZERO
  G_zz(:,:,:) = ZERO
  G_xy(:,:,:) = ZERO
  G_xz(:,:,:) = ZERO
  G_yz(:,:,:) = ZERO

  end subroutine gravity_initialize_integrals

!
!=====================================================================
!


  subroutine gravity_observation_surface()

! create observation grid (surface) on which we compute the gravity integrals.
! each processor has a copy of the whole grid and sums its contribution there,
! and at the end of the process an MPI reduction is performed to compute the global sum

  use constants

  use shared_parameters, only: R_PLANET

  use meshfem_par, only: x_observation,y_observation,z_observation, &
                           lon_observation,lat_observation,ELLIPTICITY,TOPOGRAPHY,OUTPUT_FILES

  use meshfem_models_par, only: nspl_ellip,rspl_ellip,ellipicity_spline,ellipicity_spline2,ibathy_topo

  implicit none

  ! local variables
  integer :: ix,iy,ichunk,ier

  double precision :: gamma,x,y,rgt
  double precision :: x_top,y_top,z_top
  double precision :: ratio_xi, ratio_eta

  double precision :: r,lat,lon,elevation

  ! the observation surface is always above the whole Earth, thus each mesh chunk has a size of PI / 2 in each direction
  double precision, parameter :: ANGULAR_WIDTH_XI_RAD = PI_OVER_TWO, ANGULAR_WIDTH_ETA_RAD = PI_OVER_TWO

  ! reuse an existing observation surface created in another run and stored to disk,
  ! so that we are sure that they are exactly the same (for instance when comparing results for a reference ellipsoidal Earth
  ! and results for a 3D Earth with topography)
  if (REUSE_EXISTING_OBSERVATION_SURF) then

    if (myrank == 0) then
      open(unit=IIN,file=trim(OUTPUT_FILES)//'/saved_observation_grid_real_x_y_z_used_by_the_code.txt', &
           status='old',action='read',iostat=ier)
      if (ier /= 0 ) call exit_mpi(myrank,'Error opening file for REUSE_EXISTING_OBSERVATION_SURF')

      ! loop on all the chunks and then on all the observation nodes in each chunk
      do ichunk = 1,NCHUNKS_MAX
        do iy = 1,NY_OBSERVATION
          do ix = 1,NX_OBSERVATION
            ! read the saved values
            read(IIN,*) x_observation(ix,iy,ichunk),y_observation(ix,iy,ichunk),z_observation(ix,iy,ichunk)
          enddo
        enddo
      enddo
      close(unit=IIN)

    endif

    ! implicitly converts the 3D to 1D arrays
    call bcast_all_dp(x_observation, NX_OBSERVATION * NY_OBSERVATION * NCHUNKS_MAX)
    call bcast_all_dp(y_observation, NX_OBSERVATION * NY_OBSERVATION * NCHUNKS_MAX)
    call bcast_all_dp(z_observation, NX_OBSERVATION * NY_OBSERVATION * NCHUNKS_MAX)

    ! loop on all the chunks and then on all the observation nodes in each chunk
    do ichunk = 1,NCHUNKS_MAX
      do iy = 1,NY_OBSERVATION
        do ix = 1,NX_OBSERVATION

          x_top = x_observation(ix,iy,ichunk)
          y_top = y_observation(ix,iy,ichunk)
          z_top = z_observation(ix,iy,ichunk)

          ! converts geocentric coordinates x/y/z to geographic radius/latitude/longitude (in degrees)
          call xyz_2_rlatlon_dble(x_top,y_top,z_top,r,lat,lon,ELLIPTICITY)

          ! store the values obtained for future display with GMT
          if (lon > 180.0d0 ) lon = lon - 360.0d0
          lon_observation(ix,iy,ichunk) = lon
          lat_observation(ix,iy,ichunk) = lat

        enddo
      enddo
    enddo

  else ! of if (REUSE_EXISTING_OBSERVATION_SURF)

  ! for future GMT display
  if (myrank == 0) then
    open(unit=IOUT,file=trim(OUTPUT_FILES)//'/observation_grid_long_lat_topo_for_GMT.txt',status='unknown',action='write')
    open(unit=9965,file=trim(OUTPUT_FILES)//'/saved_observation_grid_real_x_y_z_used_by_the_code.txt',status='unknown', &
                                                                                                 action='write')
  endif

  ! loop on all the chunks and then on all the observation nodes in each chunk
  do ichunk = 1,NCHUNKS_MAX
    do iy = 1,NY_OBSERVATION
      do ix = 1,NX_OBSERVATION

      ratio_xi = dble(ix - 1) / dble(NX_OBSERVATION - 1)
      x = 2.d0*ratio_xi-1

      ratio_eta = dble(iy - 1) / dble(NY_OBSERVATION - 1)
      y = 2.d0*ratio_eta-1

      x = tan((ANGULAR_WIDTH_XI_RAD/2.d0) * x)
      y = tan((ANGULAR_WIDTH_ETA_RAD/2.d0) * y)

      gamma = ONE / sqrt(ONE + x*x + y*y)

      ! first compute the position of the points exactly at the free surface of the Earth (without the oceans)
      ! keeping in mind that the code non-dimensionalizes the radius of the spherical Earth to one
      rgt = R_UNIT_SPHERE * gamma

      ! define the mesh points on the top and the bottom in the six regions of the cubed sphere
      select case (ichunk)

        case (CHUNK_AB)

          x_top = -y*rgt
          y_top = x*rgt
          z_top = rgt

        case (CHUNK_AB_ANTIPODE)

          x_top = -y*rgt
          y_top = -x*rgt
          z_top = -rgt

        case (CHUNK_AC)

          x_top = -y*rgt
          y_top = -rgt
          z_top = x*rgt

        case (CHUNK_AC_ANTIPODE)

          x_top = -y*rgt
          y_top = rgt
          z_top = -x*rgt

        case (CHUNK_BC)

          x_top = -rgt
          y_top = y*rgt
          z_top = x*rgt

        case (CHUNK_BC_ANTIPODE)

          x_top = rgt
          y_top = -y*rgt
          z_top = x*rgt

        case default
          stop 'incorrect chunk number in compute_coord_main_mesh'

      end select

      ! add ellipticity
      if (ELLIPTICITY) call add_ellipticity(x_top,y_top,z_top,nspl_ellip,rspl_ellip,ellipicity_spline,ellipicity_spline2)

      ! converts geocentric coordinates x/y/z to geographic radius/latitude/longitude (in degrees)
      call xyz_2_rlatlon_dble(x_top,y_top,z_top,r,lat,lon,ELLIPTICITY)

      ! compute elevation at current point
      if (TOPOGRAPHY) then
        call get_topo_bathy(lat,lon,elevation,ibathy_topo)
      else
        elevation = ZERO
      endif

      ! store the values obtained for future display with GMT
      if (myrank == 0) then
        if (lon > 180.0d0 ) lon = lon - 360.0d0
        write(IOUT,*) lon,lat,elevation
        lon_observation(ix,iy,ichunk) = lon
        lat_observation(ix,iy,ichunk) = lat
      endif

      ! add topography
      if (TOPOGRAPHY) then
        ! non-dimensionalize the elevation, which is in meters
        elevation = elevation / R_PLANET

        x_top = x_top*(ONE + elevation)
        y_top = y_top*(ONE + elevation)
        z_top = z_top*(ONE + elevation)
      endif

      ! compute the position of the point
      x_observation(ix,iy,ichunk) = x_top * observation_elevation_ratio
      y_observation(ix,iy,ichunk) = y_top * observation_elevation_ratio
      z_observation(ix,iy,ichunk) = z_top * observation_elevation_ratio

      ! store the values obtained so that they can be reused from other runs
      if (myrank == 0) write(9965,*) x_observation(ix,iy,ichunk),y_observation(ix,iy,ichunk),z_observation(ix,iy,ichunk)

      enddo
    enddo
  enddo

  ! for future GMT display
  if (myrank == 0) then
    close(unit=IOUT)
    close(unit=9965)
  endif

  endif ! of if (REUSE_EXISTING_OBSERVATION_SURF)

  end subroutine gravity_observation_surface

!
!=====================================================================
!

  ! compute gravity integrals of that part of the slice, and then total integrals for the whole Earth

  subroutine gravity_compute_integrals(iregion_code,nspec,wxgll,wygll,wzgll,xstore,ystore,zstore, &
                                       xixstore,xiystore,xizstore, &
                                       etaxstore,etaystore,etazstore, &
                                       gammaxstore,gammaystore,gammazstore, &
                                       rhostore,idoubling)

  use constants

  use meshfem_par, only: OUTPUT_FILES,NCHUNKS, &
    x_observation,y_observation,z_observation,g_x,g_y,g_z,G_xx,G_yy,G_zz,G_xy,G_xz,G_yz

  implicit none

  integer :: iregion_code,nspec
  double precision :: wxgll(NGLLX),wygll(NGLLY),wzgll(NGLLZ)

  integer,dimension(nspec) :: idoubling

  double precision,dimension(NGLLX,NGLLY,NGLLZ,nspec) :: xstore,ystore,zstore

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,nspec) :: &
    xixstore,xiystore,xizstore,etaxstore,etaystore,etazstore,gammaxstore,gammaystore,gammazstore

  real(kind=CUSTOM_REAL),dimension(NGLLX,NGLLY,NGLLZ,nspec) :: rhostore

  ! local parameters
  double precision :: weight
  real(kind=CUSTOM_REAL) :: xixl,xiyl,xizl,etaxl,etayl,etazl,gammaxl,gammayl,gammazl
  double precision :: jacobianl
  integer :: i,j,k,ispec
  double precision :: xval,yval,zval
  double precision :: xval_squared,yval_squared,zval_squared
  double precision :: x_meshpoint,y_meshpoint,z_meshpoint
  double precision :: distance_squared,distance_cubed, &
                      three_over_distance_squared,one_over_distance_cubed,three_over_distance_fifth_power
  double precision :: common_multiplying_factor,common_mult_times_one_over,common_mult_times_three_over

  ! name of the timestamp files
  character(len=MAX_STRING_LEN) :: outputname

#ifdef FORCE_VECTORIZATION
  integer :: ix_iy_ichunk
#else
  integer :: ix,iy,ichunk
#endif

  ! if we do not want to compute the gravity integrals, only the center of mass (computed before)
  if (ONLY_COMPUTE_CENTER_OF_MASS) return

  ! safety check, needs global simulation
  if (NCHUNKS /= NCHUNKS_MAX) stop 'Error calling compute_gravity_integrals(), only supported for global simulation'

  ! calculates volume of all elements in mesh
  do ispec = 1,nspec

    ! print information about number of elements done so far
    if (myrank == 0 .and. (mod(ispec,NSPEC_DISPLAY_INTERVAL) == 0 .or. ispec == 1 .or. ispec == nspec)) then
       write(IMAIN,*) 'for gravity integrals ',ispec,' elements computed out of ',nspec
       ! write time stamp file to give information about progression of simulation
       write(outputname,"('/timestamp_reg',i1.1,'_ispec',i7.7,'_out_of_',i7.7)") iregion_code,ispec,nspec
       ! timestamp file output
       open(unit=IOUT,file=trim(OUTPUT_FILES)//outputname,status='unknown',action='write')
       write(IOUT,*) ispec,' elements done out of ',nspec,' in region ',iregion_code
       close(unit=IOUT)
    endif

    ! suppress fictitious elements in central cube
    if (idoubling(ispec) == IFLAG_IN_FICTITIOUS_CUBE) cycle

    ! see if we compute the contribution of the crust only
    if (COMPUTE_CRUST_CONTRIB_ONLY .and. idoubling(ispec) /= IFLAG_CRUST) cycle

    do k = 1,NGLLZ
      do j = 1,NGLLY
        do i = 1,NGLLX

          weight = wxgll(i)*wygll(j)*wzgll(k)

          ! compute the Jacobian
          xixl = xixstore(i,j,k,ispec)
          xiyl = xiystore(i,j,k,ispec)
          xizl = xizstore(i,j,k,ispec)
          etaxl = etaxstore(i,j,k,ispec)
          etayl = etaystore(i,j,k,ispec)
          etazl = etazstore(i,j,k,ispec)
          gammaxl = gammaxstore(i,j,k,ispec)
          gammayl = gammaystore(i,j,k,ispec)
          gammazl = gammazstore(i,j,k,ispec)

          ! do this in double precision for accuracy
          jacobianl = 1.d0 / dble(xixl*(etayl*gammazl-etazl*gammayl) &
                        - xiyl*(etaxl*gammazl-etazl*gammaxl) &
                        + xizl*(etaxl*gammayl-etayl*gammaxl))

          if (CHECK_FOR_NEGATIVE_JACOBIANS .and. jacobianl <= ZERO) stop 'Error: negative Jacobian found in integral calculation'

          x_meshpoint = xstore(i,j,k,ispec)
          y_meshpoint = ystore(i,j,k,ispec)
          z_meshpoint = zstore(i,j,k,ispec)

          ! for gravity integral calculations we may want to shift the reference frame to a pre-computed center of mass
          if (SHIFT_TO_THIS_CENTER_OF_MASS) then
            x_meshpoint = x_meshpoint - x_shift
            y_meshpoint = y_meshpoint - y_shift
            z_meshpoint = z_meshpoint - z_shift
          endif

          common_multiplying_factor = jacobianl * weight * rhostore(i,j,k,ispec)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!! beginning of loop on all the data to create
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! loop on all the chunks and then on all the observation nodes in each chunk

#ifdef FORCE_VECTORIZATION
! this works only if the arrays are contiguous in memory (which is always the case for static arrays, as used in the code)
! but the code produced is extremely fast because we get a single and fully-vectorized loop on the whole array
          do ix_iy_ichunk = 1,NX_OBSERVATION * NY_OBSERVATION * NCHUNKS_MAX

            xval = x_meshpoint - x_observation(ix_iy_ichunk,1,1)
            yval = y_meshpoint - y_observation(ix_iy_ichunk,1,1)
            zval = z_meshpoint - z_observation(ix_iy_ichunk,1,1)

            xval_squared = xval**2
            yval_squared = yval**2
            zval_squared = zval**2

            distance_squared = xval_squared + yval_squared + zval_squared
            distance_cubed = distance_squared * sqrt(distance_squared)

            three_over_distance_squared = 3.d0 / distance_squared
            one_over_distance_cubed = 1.d0 / distance_cubed
            three_over_distance_fifth_power = three_over_distance_squared * one_over_distance_cubed

            common_mult_times_one_over = common_multiplying_factor * one_over_distance_cubed
            common_mult_times_three_over = common_multiplying_factor * three_over_distance_fifth_power

            g_x(ix_iy_ichunk,1,1) = g_x(ix_iy_ichunk,1,1) + common_mult_times_one_over * xval
            g_y(ix_iy_ichunk,1,1) = g_y(ix_iy_ichunk,1,1) + common_mult_times_one_over * yval
            g_z(ix_iy_ichunk,1,1) = g_z(ix_iy_ichunk,1,1) + common_mult_times_one_over * zval

            G_xx(ix_iy_ichunk,1,1) = G_xx(ix_iy_ichunk,1,1) &
                                   + common_mult_times_one_over * (xval_squared * three_over_distance_squared - 1.d0)
            G_yy(ix_iy_ichunk,1,1) = G_yy(ix_iy_ichunk,1,1) &
                                   + common_mult_times_one_over * (yval_squared * three_over_distance_squared - 1.d0)
            G_zz(ix_iy_ichunk,1,1) = G_zz(ix_iy_ichunk,1,1) &
                                   + common_mult_times_one_over * (zval_squared * three_over_distance_squared - 1.d0)

            G_xy(ix_iy_ichunk,1,1) = G_xy(ix_iy_ichunk,1,1) + common_mult_times_three_over * xval*yval
            G_xz(ix_iy_ichunk,1,1) = G_xz(ix_iy_ichunk,1,1) + common_mult_times_three_over * xval*zval
            G_yz(ix_iy_ichunk,1,1) = G_yz(ix_iy_ichunk,1,1) + common_mult_times_three_over * yval*zval

          enddo
#else
          ! non-vectorized
          do ichunk = 1,NCHUNKS_MAX
            do iy = 1,NY_OBSERVATION
              do ix = 1,NX_OBSERVATION

                xval = x_meshpoint - x_observation(ix,iy,ichunk)
                yval = y_meshpoint - y_observation(ix,iy,ichunk)
                zval = z_meshpoint - z_observation(ix,iy,ichunk)

                xval_squared = xval**2
                yval_squared = yval**2
                zval_squared = zval**2

                distance_squared = xval_squared + yval_squared + zval_squared
                distance_cubed = distance_squared * sqrt(distance_squared)

                three_over_distance_squared = 3.d0 / distance_squared
                one_over_distance_cubed = 1.d0 / distance_cubed
                three_over_distance_fifth_power = three_over_distance_squared * one_over_distance_cubed

                common_mult_times_one_over = common_multiplying_factor * one_over_distance_cubed
                common_mult_times_three_over = common_multiplying_factor * three_over_distance_fifth_power

                g_x(ix,iy,ichunk) = g_x(ix,iy,ichunk) + common_mult_times_one_over * xval
                g_y(ix,iy,ichunk) = g_y(ix,iy,ichunk) + common_mult_times_one_over * yval
                g_z(ix,iy,ichunk) = g_z(ix,iy,ichunk) + common_mult_times_one_over * zval

                G_xx(ix,iy,ichunk) = G_xx(ix,iy,ichunk) &
                                     + common_mult_times_one_over * (xval_squared * three_over_distance_squared - 1.d0)
                G_yy(ix,iy,ichunk) = G_yy(ix,iy,ichunk) &
                                     + common_mult_times_one_over * (yval_squared * three_over_distance_squared - 1.d0)
                G_zz(ix,iy,ichunk) = G_zz(ix,iy,ichunk) &
                                     + common_mult_times_one_over * (zval_squared * three_over_distance_squared - 1.d0)

                G_xy(ix,iy,ichunk) = G_xy(ix,iy,ichunk) + common_mult_times_three_over * xval*yval
                G_xz(ix,iy,ichunk) = G_xz(ix,iy,ichunk) + common_mult_times_three_over * xval*zval
                G_yz(ix,iy,ichunk) = G_yz(ix,iy,ichunk) + common_mult_times_three_over * yval*zval

              enddo
            enddo
          enddo
#endif

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!! end of loop on all the data to create
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        enddo
      enddo
    enddo
  enddo

  end subroutine gravity_compute_integrals


!
!=====================================================================
!

  subroutine finalize_gravity_integrals()

  use constants, only: SI_UNITS_TO_EOTVOS,IXR,IYR,ICHUNKR,ONLY_COMPUTE_CENTER_OF_MASS
  use meshfem_par
  use meshfem_models_par

  implicit none

  ! for gravity integrals
  ! take into account the fact that the density and the radius of the Earth have previously been non-dimensionalized
  ! for the gravity vector force, a distance is involved in the dimensions
  double precision :: nondimensionalizing_factor_gi
  ! for the second-order gravity tensor, no distance is involved in the dimensions
  double precision :: nondimensionalizing_factor_Gij
  double precision :: scaling_factor_gi
  double precision :: scaling_factor_Gij_Eotvos

  double precision :: real_altitude_of_observ_point

  integer :: ixval,iyval,ichunkval

  ! scaling factors
  nondimensionalizing_factor_gi  = RHOAV * R_PLANET
  nondimensionalizing_factor_Gij = RHOAV
  scaling_factor_gi = GRAV * nondimensionalizing_factor_gi
  scaling_factor_Gij_Eotvos = GRAV * nondimensionalizing_factor_Gij * SI_UNITS_TO_EOTVOS

  ! multiply by the gravitational constant in S.I. units i.e. in m3 kg-1 s-2
  ! and also take into account the fact that the density and the radius of the Earth have previously been non-dimensionalized
  ! the final result is in m.s-2 i.e. in S.I. units
  g_x(:,:,:) = g_x(:,:,:) * scaling_factor_gi
  g_y(:,:,:) = g_y(:,:,:) * scaling_factor_gi
  g_z(:,:,:) = g_z(:,:,:) * scaling_factor_gi

  ! the final result is in Eotvos = 1.e+9 s-2
  G_xx(:,:,:) = G_xx(:,:,:) * scaling_factor_Gij_Eotvos
  G_yy(:,:,:) = G_yy(:,:,:) * scaling_factor_Gij_Eotvos
  G_zz(:,:,:) = G_zz(:,:,:) * scaling_factor_Gij_Eotvos
  G_xy(:,:,:) = G_xy(:,:,:) * scaling_factor_Gij_Eotvos
  G_xz(:,:,:) = G_xz(:,:,:) * scaling_factor_Gij_Eotvos
  G_yz(:,:,:) = G_yz(:,:,:) * scaling_factor_Gij_Eotvos

  ! use an MPI reduction to compute the total value of the integral into a temporary array
  ! and then copy it back into the original array
  call sum_all_3Darray_dp(g_x,temporary_array_for_sum,NX_OBSERVATION,NY_OBSERVATION,NCHUNKS_MAX)
  if (myrank == 0) g_x(:,:,:) = temporary_array_for_sum(:,:,:)

  call sum_all_3Darray_dp(g_y,temporary_array_for_sum,NX_OBSERVATION,NY_OBSERVATION,NCHUNKS_MAX)
  if (myrank == 0) g_y(:,:,:) = temporary_array_for_sum(:,:,:)

  call sum_all_3Darray_dp(g_z,temporary_array_for_sum,NX_OBSERVATION,NY_OBSERVATION,NCHUNKS_MAX)
  if (myrank == 0) g_z(:,:,:) = temporary_array_for_sum(:,:,:)

  call sum_all_3Darray_dp(G_xx,temporary_array_for_sum,NX_OBSERVATION,NY_OBSERVATION,NCHUNKS_MAX)
  if (myrank == 0) G_xx(:,:,:) = temporary_array_for_sum(:,:,:)

  call sum_all_3Darray_dp(G_yy,temporary_array_for_sum,NX_OBSERVATION,NY_OBSERVATION,NCHUNKS_MAX)
  if (myrank == 0) G_yy(:,:,:) = temporary_array_for_sum(:,:,:)

  call sum_all_3Darray_dp(G_zz,temporary_array_for_sum,NX_OBSERVATION,NY_OBSERVATION,NCHUNKS_MAX)
  if (myrank == 0) G_zz(:,:,:) = temporary_array_for_sum(:,:,:)

  call sum_all_3Darray_dp(G_xy,temporary_array_for_sum,NX_OBSERVATION,NY_OBSERVATION,NCHUNKS_MAX)
  if (myrank == 0) G_xy(:,:,:) = temporary_array_for_sum(:,:,:)

  call sum_all_3Darray_dp(G_xz,temporary_array_for_sum,NX_OBSERVATION,NY_OBSERVATION,NCHUNKS_MAX)
  if (myrank == 0) G_xz(:,:,:) = temporary_array_for_sum(:,:,:)

  call sum_all_3Darray_dp(G_yz,temporary_array_for_sum,NX_OBSERVATION,NY_OBSERVATION,NCHUNKS_MAX)
  if (myrank == 0) G_yz(:,:,:) = temporary_array_for_sum(:,:,:)


  ! check total Earth mass
  if (NCHUNKS == 6 .and. myrank == 0) then
    ! warning
    if (.not. ONLY_COMPUTE_CENTER_OF_MASS .and. distance_to_center_in_km > 0.01d0) then
      write(IMAIN,*) '***'
      write(IMAIN,*) '*** Warning:'
      write(IMAIN,*) '***'
      write(IMAIN,*) '*** center of mass of the model is not located in zero for gravity integrals'
      write(IMAIN,*) '*** distance to center is ',sngl(distance_to_center_in_km),'km'
      write(IMAIN,*) '***'
      write(IMAIN,*) '*** Please make sure that for more exact gravity field calculations,'
      write(IMAIN,*) '*** you need a higher-resolution mesh...'
      write(IMAIN,*) '***'
      ! hard stop?
      !stop 'Error: center of mass of the model is not located in zero for gravity integrals, aborting...'
    endif
  endif

  !--- print number of points and elements in the mesh for each region
  if (myrank == 0) then

    real_altitude_of_observ_point = sqrt(x_observation(ixr,iyr,ichunkr)**2 + &
                                         y_observation(ixr,iyr,ichunkr)**2 + &
                                         z_observation(ixr,iyr,ichunkr)**2)


    ! info output
    write(IMAIN,*)
    temporary_array_for_sum(:,:,:) = sqrt(g_x(:,:,:)**2 + g_y(:,:,:)**2 + g_z(:,:,:)**2)
    write(IMAIN,*) 'minval of norm of g vector on whole observation surface = ',minval(temporary_array_for_sum),' m.s-2'
    write(IMAIN,*) 'maxval of norm of g vector on whole observation surface = ',maxval(temporary_array_for_sum),' m.s-2'

    write(IMAIN,*)
    write(IMAIN,*) 'minval of G_xx on whole observation surface = ',minval(G_xx),' Eotvos'
    write(IMAIN,*) 'maxval of G_xx on whole observation surface = ',maxval(G_xx),' Eotvos'

    write(IMAIN,*)
    write(IMAIN,*) 'minval of G_yy on whole observation surface = ',minval(G_yy),' Eotvos'
    write(IMAIN,*) 'maxval of G_yy on whole observation surface = ',maxval(G_yy),' Eotvos'

    write(IMAIN,*)
    write(IMAIN,*) 'minval of G_zz on whole observation surface = ',minval(G_zz),' Eotvos'
    write(IMAIN,*) 'maxval of G_zz on whole observation surface = ',maxval(G_zz),' Eotvos'

    write(IMAIN,*)
    write(IMAIN,*) 'minval of G_xy on whole observation surface = ',minval(G_xy),' Eotvos'
    write(IMAIN,*) 'maxval of G_xy on whole observation surface = ',maxval(G_xy),' Eotvos'

    write(IMAIN,*)
    write(IMAIN,*) 'minval of G_xz on whole observation surface = ',minval(G_xz),' Eotvos'
    write(IMAIN,*) 'maxval of G_xz on whole observation surface = ',maxval(G_xz),' Eotvos'

    write(IMAIN,*)
    write(IMAIN,*) 'minval of G_yz on whole observation surface = ',minval(G_yz),' Eotvos'
    write(IMAIN,*) 'maxval of G_yz on whole observation surface = ',maxval(G_yz),' Eotvos'

    write(IMAIN,*)
    write(IMAIN,*) 'Minval and maxval of trace of G, which in principle should be zero:'
    write(IMAIN,*)

    temporary_array_for_sum(:,:,:) = abs(G_xx(:,:,:) + G_yy(:,:,:) + G_zz(:,:,:))
    write(IMAIN,*) 'minval of abs(G_xx + G_yy + G_zz) on whole observation surface = ',minval(temporary_array_for_sum),' Eotvos'
    write(IMAIN,*) 'maxval of abs(G_xx + G_yy + G_zz) on whole observation surface = ',maxval(temporary_array_for_sum),' Eotvos'

    write(IMAIN,*)
    write(IMAIN,*) '-----------------------------'
    write(IMAIN,*)
    write(IMAIN,*) 'displaying the fields computed at:'
    write(IMAIN,*) '    ix_observation = ',ixr,' out of ',NX_OBSERVATION
    write(IMAIN,*) '    iy_observation = ',iyr,' out of ',NY_OBSERVATION
    write(IMAIN,*) '    of mesh chunk ',ichunkr
    write(IMAIN,*)
    write(IMAIN,*) 'computed g_x  = ',g_x(ixr,iyr,ichunkr),' m.s-2'
    write(IMAIN,*) 'computed g_y  = ',g_y(ixr,iyr,ichunkr),' m.s-2'
    write(IMAIN,*) 'computed g_z  = ',g_z(ixr,iyr,ichunkr),' m.s-2'
    write(IMAIN,*)
    write(IMAIN,*) 'computed norm of g vector = ', &
                    sqrt(g_x(ixr,iyr,ichunkr)**2 + g_y(ixr,iyr,ichunkr)**2 + g_z(ixr,iyr,ichunkr)**2),' m.s-2'

    ! gravity force vector norm decays approximately as (r / r_prime)^2 above the surface of the Earth
    write(IMAIN,*) '  (should be not too far from ', &
                    sngl(STANDARD_GRAVITY * (R_UNIT_SPHERE / real_altitude_of_observ_point)**2),' m.s-2)'

    write(IMAIN,*)
    write(IMAIN,*) 'computed G_xx = ',G_xx(ixr,iyr,ichunkr),' Eotvos'
    write(IMAIN,*) 'computed G_yy = ',G_yy(ixr,iyr,ichunkr),' Eotvos'
    write(IMAIN,*) 'computed G_zz = ',G_zz(ixr,iyr,ichunkr),' Eotvos'
    write(IMAIN,*)
    write(IMAIN,*) 'G tensor should be traceless, G_xx + G_yy + G_zz = 0.'
    write(IMAIN,*) 'Actual sum obtained = ',G_xx(ixr,iyr,ichunkr) + G_yy(ixr,iyr,ichunkr) + G_zz(ixr,iyr,ichunkr)

    if (max(abs(G_xx(ixr,iyr,ichunkr)),abs(G_yy(ixr,iyr,ichunkr)),abs(G_zz(ixr,iyr,ichunkr))) > TINYVAL) &
         write(IMAIN,*) ' i.e., ',sngl(100.d0*abs(G_xx(ixr,iyr,ichunkr) + G_yy(ixr,iyr,ichunkr) + G_zz(ixr,iyr,ichunkr)) / &
                                   max(abs(G_xx(ixr,iyr,ichunkr)),abs(G_yy(ixr,iyr,ichunkr)),abs(G_zz(ixr,iyr,ichunkr)))), &
                                   '% of max(abs(G_xx),abs(G_yy),abs(G_zz))'
    write(IMAIN,*)
    write(IMAIN,*) 'computed G_xy = ',G_xy(ixr,iyr,ichunkr),' Eotvos'
    write(IMAIN,*) 'computed G_xz = ',G_xz(ixr,iyr,ichunkr),' Eotvos'
    write(IMAIN,*) 'computed G_yz = ',G_yz(ixr,iyr,ichunkr),' Eotvos'
    write(IMAIN,*)
    write(IMAIN,*) '-----------------------------'
    write(IMAIN,*)
    call flush_IMAIN()
  endif

  ! file output for future GMT display
  if (myrank == 0) then
    ! loop on all the chunks and then on all the observation nodes in each chunk
    open(unit=IOUT,file=trim(OUTPUT_FILES)//'/results_g_x_for_GMT.txt',status='unknown',action='write')
    do ichunkval = 1,NCHUNKS_MAX
      do iyval = 1,NY_OBSERVATION
        do ixval = 1,NX_OBSERVATION
          write(IOUT,*) lon_observation(ixval,iyval,ichunkval),lat_observation(ixval,iyval,ichunkval),g_x(ixval,iyval,ichunkval)
        enddo
      enddo
    enddo
    close(unit=IOUT)

    open(unit=IOUT,file=trim(OUTPUT_FILES)//'/results_g_y_for_GMT.txt',status='unknown',action='write')
    do ichunkval = 1,NCHUNKS_MAX
      do iyval = 1,NY_OBSERVATION
        do ixval = 1,NX_OBSERVATION
          write(IOUT,*) lon_observation(ixval,iyval,ichunkval),lat_observation(ixval,iyval,ichunkval),g_y(ixval,iyval,ichunkval)
        enddo
      enddo
    enddo
    close(unit=IOUT)

    open(unit=IOUT,file=trim(OUTPUT_FILES)//'/results_g_z_for_GMT.txt',status='unknown',action='write')
    do ichunkval = 1,NCHUNKS_MAX
      do iyval = 1,NY_OBSERVATION
        do ixval = 1,NX_OBSERVATION
          write(IOUT,*) lon_observation(ixval,iyval,ichunkval),lat_observation(ixval,iyval,ichunkval),g_z(ixval,iyval,ichunkval)
        enddo
      enddo
    enddo
    close(unit=IOUT)

    open(unit=IOUT,file=trim(OUTPUT_FILES)//'/results_norm_of_g_for_GMT.txt',status='unknown',action='write')
    do ichunkval = 1,NCHUNKS_MAX
      do iyval = 1,NY_OBSERVATION
        do ixval = 1,NX_OBSERVATION
          write(IOUT,*) lon_observation(ixval,iyval,ichunkval),lat_observation(ixval,iyval,ichunkval), &
                           sqrt(g_x(ixval,iyval,ichunkval)**2 + g_y(ixval,iyval,ichunkval)**2 + g_z(ixval,iyval,ichunkval)**2)
        enddo
      enddo
    enddo
    close(unit=IOUT)

    open(unit=IOUT,file=trim(OUTPUT_FILES)//'/results_G_xx_for_GMT.txt',status='unknown',action='write')
    do ichunkval = 1,NCHUNKS_MAX
      do iyval = 1,NY_OBSERVATION
        do ixval = 1,NX_OBSERVATION
          write(IOUT,*) lon_observation(ixval,iyval,ichunkval),lat_observation(ixval,iyval,ichunkval),G_xx(ixval,iyval,ichunkval)
        enddo
      enddo
    enddo
    close(unit=IOUT)

    open(unit=IOUT,file=trim(OUTPUT_FILES)//'/results_G_yy_for_GMT.txt',status='unknown',action='write')
    do ichunkval = 1,NCHUNKS_MAX
      do iyval = 1,NY_OBSERVATION
        do ixval = 1,NX_OBSERVATION
          write(IOUT,*) lon_observation(ixval,iyval,ichunkval),lat_observation(ixval,iyval,ichunkval),G_yy(ixval,iyval,ichunkval)
        enddo
      enddo
    enddo
    close(unit=IOUT)

    open(unit=IOUT,file=trim(OUTPUT_FILES)//'/results_G_zz_for_GMT.txt',status='unknown',action='write')
    do ichunkval = 1,NCHUNKS_MAX
      do iyval = 1,NY_OBSERVATION
        do ixval = 1,NX_OBSERVATION
          write(IOUT,*) lon_observation(ixval,iyval,ichunkval),lat_observation(ixval,iyval,ichunkval),G_zz(ixval,iyval,ichunkval)
        enddo
      enddo
    enddo
    close(unit=IOUT)

    open(unit=IOUT,file=trim(OUTPUT_FILES)//'/results_G_xy_for_GMT.txt',status='unknown',action='write')
    do ichunkval = 1,NCHUNKS_MAX
      do iyval = 1,NY_OBSERVATION
        do ixval = 1,NX_OBSERVATION
          write(IOUT,*) lon_observation(ixval,iyval,ichunkval),lat_observation(ixval,iyval,ichunkval),G_xy(ixval,iyval,ichunkval)
        enddo
      enddo
    enddo
    close(unit=IOUT)

    open(unit=IOUT,file=trim(OUTPUT_FILES)//'/results_G_xz_for_GMT.txt',status='unknown',action='write')
    do ichunkval = 1,NCHUNKS_MAX
      do iyval = 1,NY_OBSERVATION
        do ixval = 1,NX_OBSERVATION
          write(IOUT,*) lon_observation(ixval,iyval,ichunkval),lat_observation(ixval,iyval,ichunkval),G_xz(ixval,iyval,ichunkval)
        enddo
      enddo
    enddo
    close(unit=IOUT)

    open(unit=IOUT,file=trim(OUTPUT_FILES)//'/results_G_yz_for_GMT.txt',status='unknown',action='write')
    do ichunkval = 1,NCHUNKS_MAX
      do iyval = 1,NY_OBSERVATION
        do ixval = 1,NX_OBSERVATION
          write(IOUT,*) lon_observation(ixval,iyval,ichunkval),lat_observation(ixval,iyval,ichunkval),G_yz(ixval,iyval,ichunkval)
        enddo
      enddo
    enddo
    close(unit=IOUT)
  endif

  end subroutine finalize_gravity_integrals

