!=====================================================================
!
!          S p e c f e m 3 D  G l o b e  V e r s i o n  4 . 0
!          --------------------------------------------------
!
!          Main authors: Dimitri Komatitsch and Jeroen Tromp
!    Seismological Laboratory, California Institute of Technology, USA
!                 and University of Pau / CNRS, France
! (c) California Institute of Technology and University of Pau / CNRS, November 2007
!
! This program is free software; you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation; either version 2 of the License, or
! (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License along
! with this program; if not, write to the Free Software Foundation, Inc.,
! 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
!
!=====================================================================
!
! United States Government Sponsorship Acknowledged.

  subroutine specfem3D

  implicit none

! standard include of the MPI library
  include 'mpif.h'

  include "constants.h"
  include "precision.h"

! include values created by the mesher
  include "OUTPUT_FILES/values_from_mesher.h"

!=======================================================================!
!                                                                       !
!   specfem3D is a 3-D spectral-element solver for the Earth.           !
!   It uses a mesh generated by program meshfem3D                       !
!                                                                       !
!=======================================================================!
!
! If you use this code for your own research, please cite some of these articles:
!
! @ARTICLE{KoRiTr02,
! author={D. Komatitsch and J. Ritsema and J. Tromp},
! year=2002,
! title={The Spectral-Element Method, {B}eowulf Computing, and Global Seismology},
! journal={Science},
! volume=298,
! number=5599,
! pages={1737-1742},
! doi={10.1126/science.1076024}}
!
! @ARTICLE{KoTr02a,
! author={D. Komatitsch and J. Tromp},
! year=2002,
! title={Spectral-Element Simulations of Global Seismic Wave Propagation{-I. V}alidation},
! journal={Geophys. J. Int.},
! volume=149,
! number=2,
! pages={390-412},
! doi={10.1046/j.1365-246X.2002.01653.x}}
!
! @ARTICLE{KoTr02b,
! author={D. Komatitsch and J. Tromp},
! year=2002,
! title={Spectral-Element Simulations of Global Seismic Wave Propagation{-II. 3-D} Models, Oceans, Rotation, and Self-Gravitation},
! journal={Geophys. J. Int.},
! volume=150,
! pages={303-318},
! number=1,
! doi={10.1046/j.1365-246X.2002.01716.x}}
!
! @ARTICLE{KoTr99,
! author={D. Komatitsch and J. Tromp},
! year=1999,
! title={Introduction to the spectral-element method for 3-{D} seismic wave propagation},
! journal={Geophys. J. Int.},
! volume=139,
! number=3,
! pages={806-822},
! doi={10.1046/j.1365-246x.1999.00967.x}}
!
! @ARTICLE{KoVi98,
! author={D. Komatitsch and J. P. Vilotte},
! title={The spectral-element method: an efficient tool to simulate the seismic response of 2{D} and 3{D} geological structures},
! journal={Bull. Seismol. Soc. Am.},
! year=1998,
! volume=88,
! number=2,
! pages={368-392}}
!
! If you use the kernel capabilities of the code, please cite
!
! @ARTICLE{LiTr06,
! author={Qinya Liu and Jeroen Tromp},
! title={Finite-frequency kernels based on adjoint methods},
! journal={Bull. Seismol. Soc. Am.},
! year=2006,
! volume=96,
! number=6,
! pages={2383-2397},
! doi={10.1785/0120060041}}
!
! If you use 3-D model S20RTS, please cite
!
! @ARTICLE{RiVa00,
! author={J. Ritsema and H. J. {Van Heijst}},
! year=2000,
! title={Seismic imaging of structural heterogeneity in {E}arth's mantle: Evidence for large-scale mantle flow},
! journal={Science Progress},
! volume=83,
! pages={243-259}}
!
! Reference frame - convention:
! ----------------------------
!
! The code uses the following convention for the reference frame:
!
!  - X axis is East
!  - Y axis is North
!  - Z axis is up
!
! Note that this convention is different from both the Aki-Richards convention
! and the Harvard CMT convention.
!
! Let us recall that the Aki-Richards convention is:
!
!  - X axis is North
!  - Y axis is East
!  - Z axis is down
!
! and that the Harvard CMT convention is:
!
!  - X axis is South
!  - Y axis is East
!  - Z axis is up
!
! To report bugs or suggest improvements to the code, please send an email
! to Jeroen Tromp <jtromp AT caltech.edu> and/or use our online
! bug tracking system at http://www.geodynamics.org/roundup .
!
! Evolution of the code:
! ---------------------
!
! v. 4.0 David Michea and Dimitri Komatitsch, University of Pau, France, November 2007:
!      new doubling brick in the mesh, new perfectly load-balanced mesh,
!      more flexible routines for mesh design, one more doubling level
!      at the bottom of the outer core, new inflated central cube
!      with optimized shape, far fewer mesh files saved by the mesher.
! v. 3.6 Many people, many affiliations, September 2006:
!      adjoint and kernel calculations, fixed IASP91 model,
!      added AK135 and 1066a, fixed topography/bathymetry routine,
!      new attenuation routines, faster and better I/Os on very large
!      systems, many small improvements and bug fixes, new "configure"
!      script, new Pyre version, new user's manual etc.
! v. 3.5 Dimitri Komatitsch, Brian Savage and Jeroen Tromp, Caltech, July 2004:
!      any size of chunk, 3D attenuation, case of two chunks,
!      more precise topography/bathymetry model, new Par_file structure
! v. 3.4 Dimitri Komatitsch and Jeroen Tromp, Caltech, August 2003:
!      merged global and regional codes, no iterations in fluid, better movies
! v. 3.3 Dimitri Komatitsch, Caltech, September 2002:
!      flexible mesh doubling in outer core, inlined code, OpenDX support
! v. 3.2 Jeroen Tromp, Caltech, July 2002:
!      multiple sources and flexible PREM reading
! v. 3.1 Dimitri Komatitsch, Caltech, June 2002:
!      vectorized loops in solver and merged central cube
! v. 3.0 Dimitri Komatitsch and Jeroen Tromp, Caltech, May 2002:
!   ported to SGI and Compaq, double precision solver, more general anisotropy
! v. 2.3 Dimitri Komatitsch and Jeroen Tromp, Caltech, August 2001:
!                       gravity, rotation, oceans and 3-D models
! v. 2.2 Dimitri Komatitsch and Jeroen Tromp, Caltech, March 2001:
!                       final MPI package
! v. 2.0 Dimitri Komatitsch, Harvard, January 2000: MPI code for the globe
! v. 1.0 Dimitri Komatitsch, Mexico, June 1999: first MPI code for a chunk
! Jeroen Tromp, Harvard, July 1998: first chunk solver using OpenMP on Sun
! Dimitri Komatitsch, IPG Paris, December 1996: first 3-D solver for the CM5
!
! From Dahlen and Tromp (1998):
! ----------------------------
!
! Gravity is approximated by solving eq (3.259) without the Phi_E' term
! The ellipsoidal reference model is that of section 14.1
! The transversely isotropic expression for PREM is that of eq (8.190)
!
! Formulation in the fluid (acoustic) outer core:
! -----------------------------------------------
!
! In case of an acoustic medium, a displacement potential Chi is used
! as in Chaljub and Valette, Geophysical Journal International, vol. 158,
! p. 131-141 (2004) and *NOT* a velocity potential as in Komatitsch and Tromp,
! Geophysical Journal International, vol. 150, p. 303-318 (2002).
! This permits acoustic-elastic coupling based on a non-iterative time scheme.
! Displacement if we ignore gravity is then: u = grad(Chi)
! (In the context of the Cowling approximation displacement is
! u = grad(rho * Chi) / Chi, *not* u = grad(Chi).)
! Velocity is then: v = grad(Chi_dot)       (Chi_dot being the time derivative of Chi)
! and pressure is: p = - rho * Chi_dot_dot  (Chi_dot_dot being the time second derivative of Chi).
! The source in an acoustic element is a pressure source.
! The potential in the outer core is called displ_outer_core for simplicity.
! Its first time derivative is called veloc_outer_core.
! Its second time derivative is called accel_outer_core.

! attenuation_model_variables
  type attenuation_model_variables
    sequence
    double precision min_period, max_period
    double precision                          :: QT_c_source        ! Source Frequency
    double precision, dimension(:), pointer   :: Qtau_s             ! tau_sigma
    double precision, dimension(:), pointer   :: QrDisc             ! Discontinutitues Defined
    double precision, dimension(:), pointer   :: Qr                 ! Radius
    integer, dimension(:), pointer            :: interval_Q         ! Steps
    double precision, dimension(:), pointer   :: Qmu                ! Shear Attenuation
    double precision, dimension(:,:), pointer :: Qtau_e             ! tau_epsilon
    double precision, dimension(:), pointer   :: Qomsb, Qomsb2      ! one_minus_sum_beta
    double precision, dimension(:,:), pointer :: Qfc, Qfc2          ! factor_common
    double precision, dimension(:), pointer   :: Qsf, Qsf2          ! scale_factor
    integer, dimension(:), pointer            :: Qrmin              ! Max and Mins of idoubling
    integer, dimension(:), pointer            :: Qrmax              ! Max and Mins of idoubling
    integer                                   :: Qn                 ! Number of points
  end type attenuation_model_variables

  type (attenuation_model_variables) AM_V
! attenuation_model_variables

! memory variables and standard linear solids for attenuation
  double precision, dimension(N_SLS) :: tau_sigma_dble
  double precision, dimension(ATT1,ATT2,ATT3,ATT4) :: omsb_crust_mantle_dble, factor_scale_crust_mantle_dble
  double precision, dimension(ATT1,ATT2,ATT3,ATT5) :: omsb_inner_core_dble, factor_scale_inner_core_dble
  real(kind=CUSTOM_REAL), dimension(ATT1,ATT2,ATT3,ATT4) :: one_minus_sum_beta_crust_mantle, factor_scale_crust_mantle
  real(kind=CUSTOM_REAL), dimension(ATT1,ATT2,ATT3,ATT5) :: one_minus_sum_beta_inner_core, factor_scale_inner_core

  real(kind=CUSTOM_REAL) mul, kappal, rhol

  double precision, dimension(N_SLS) :: alphaval_dble, betaval_dble, gammaval_dble
  real(kind=CUSTOM_REAL), dimension(N_SLS) :: alphaval, betaval, gammaval
  real(kind=CUSTOM_REAL), dimension(N_SLS,ATT1,ATT2,ATT3,ATT4) :: factor_common_crust_mantle
  real(kind=CUSTOM_REAL), dimension(N_SLS,ATT1,ATT2,ATT3,ATT5) :: factor_common_inner_core
  double precision, dimension(N_SLS,ATT1,ATT2,ATT3,ATT4) :: factor_common_crust_mantle_dble
  double precision, dimension(N_SLS,ATT1,ATT2,ATT3,ATT5) :: factor_common_inner_core_dble

  double precision scale_factor,scale_factor_minus_one
  real(kind=CUSTOM_REAL) dist_cr

  real(kind=CUSTOM_REAL), dimension(5,N_SLS,NGLLX,NGLLY,NGLLZ,NSPEC_CRUST_MANTLE_ATTENUAT) :: R_memory_crust_mantle
  real(kind=CUSTOM_REAL), dimension(5,NGLLX,NGLLY,NGLLZ,NSPEC_CRUST_MANTLE_STRAIN_ATT) :: epsilondev_crust_mantle
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_CRUST_MANTLE_STRAIN_ONLY) :: eps_trace_over_3_crust_mantle
  real(kind=CUSTOM_REAL), dimension(5) :: epsilondev_loc

  real(kind=CUSTOM_REAL), dimension(5,N_SLS,NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE_ATTENUATION) :: R_memory_inner_core
  real(kind=CUSTOM_REAL), dimension(5,NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE_STRAIN_ATT) :: epsilondev_inner_core
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE_STRAIN_ONLY) :: eps_trace_over_3_inner_core

! ADJOINT
  real(kind=CUSTOM_REAL), dimension(N_SLS) :: b_alphaval, b_betaval, b_gammaval

  real(kind=CUSTOM_REAL), dimension(5,N_SLS,NGLLX,NGLLY,NGLLZ,NSPEC_CRUST_MANTLE_ADJOINT) :: b_R_memory_crust_mantle
  real(kind=CUSTOM_REAL), dimension(5,NGLLX,NGLLY,NGLLZ,NSPEC_CRUST_MANTLE_ADJOINT) :: b_epsilondev_crust_mantle
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_CRUST_MANTLE_ADJOINT) :: b_eps_trace_over_3_crust_mantle

  real(kind=CUSTOM_REAL), dimension(5,N_SLS,NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE_ADJOINT) :: b_R_memory_inner_core
  real(kind=CUSTOM_REAL), dimension(5,NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE_ADJOINT) :: b_epsilondev_inner_core
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE_ADJOINT) :: b_eps_trace_over_3_inner_core

  real(kind=CUSTOM_REAL), dimension(5) :: b_epsilondev_loc

! for matching with central cube in inner core
  integer, dimension(:), allocatable :: sender_from_slices_to_cube
  integer, dimension(:,:), allocatable :: ibool_central_cube
  double precision, dimension(:,:), allocatable :: buffer_slices
  double precision, dimension(:,:,:), allocatable :: buffer_all_cube_from_slices
  integer nb_msgs_theor_in_cube,non_zero_nb_msgs_theor_in_cube,npoin2D_cube_from_slices,receiver_cube_from_slices

  integer nspec2D_xmin_inner_core,nspec2D_xmax_inner_core,nspec2D_ymin_inner_core,nspec2D_ymax_inner_core,ndim_assemble

! to save movie frames
  integer nmovie_points,ipoin
  real(kind=CUSTOM_REAL), dimension(:), allocatable :: &
      store_val_x,store_val_y,store_val_z, &
      store_val_ux,store_val_uy,store_val_uz
  real(kind=CUSTOM_REAL), dimension(:,:), allocatable :: &
      store_val_x_all,store_val_y_all,store_val_z_all, &
      store_val_ux_all,store_val_uy_all,store_val_uz_all

! use integer array to store values
  integer ibathy_topo(NX_BATHY,NY_BATHY)

! for crust/oceans coupling
  integer, dimension(NSPEC2DMAX_XMIN_XMAX_CM) :: ibelm_xmin_crust_mantle,ibelm_xmax_crust_mantle
  integer, dimension(NSPEC2DMAX_YMIN_YMAX_CM) :: ibelm_ymin_crust_mantle,ibelm_ymax_crust_mantle
  integer, dimension(NSPEC2D_BOTTOM_CM) :: ibelm_bottom_crust_mantle
  integer, dimension(NSPEC2D_TOP_CM) :: ibelm_top_crust_mantle

! additional mass matrix for ocean load
  real(kind=CUSTOM_REAL), dimension(NGLOB_CRUST_MANTLE_OCEANS) :: rmass_ocean_load

! flag to mask ocean-bottom degrees of freedom for ocean load
  logical, dimension(NGLOB_CRUST_MANTLE_OCEANS) :: updated_dof_ocean_load

  real(kind=CUSTOM_REAL) additional_term,force_normal_comp

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NSPEC2D_BOTTOM_CM) :: jacobian2D_bottom_crust_mantle
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NSPEC2D_TOP_CM) :: jacobian2D_top_crust_mantle
  real(kind=CUSTOM_REAL), dimension(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX_CM) :: jacobian2D_xmin_crust_mantle,&
  jacobian2D_xmax_crust_mantle
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX_CM) :: jacobian2D_ymin_crust_mantle,&
  jacobian2D_ymax_crust_mantle
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX_CM) :: &
  normal_xmin_crust_mantle,normal_xmax_crust_mantle
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLLX,NGLLY,NSPEC2DMAX_YMIN_YMAX_CM) :: &
  normal_ymin_crust_mantle,normal_ymax_crust_mantle
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLLX,NGLLY,NSPEC2D_BOTTOM_CM) :: normal_bottom_crust_mantle
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLLX,NGLLY,NSPEC2D_TOP_CM) :: normal_top_crust_mantle

! Stacey
  real(kind=CUSTOM_REAL) sn,tx,ty,tz
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_CRUST_MANTLE_STACEY) :: rho_vp_crust_mantle,rho_vs_crust_mantle
  integer nspec2D_xmin_crust_mantle,nspec2D_xmax_crust_mantle,nspec2D_ymin_crust_mantle,nspec2D_ymax_crust_mantle
  integer, dimension(2,NSPEC2DMAX_YMIN_YMAX_CM) :: nimin_crust_mantle,nimax_crust_mantle,nkmin_eta_crust_mantle
  integer, dimension(2,NSPEC2DMAX_XMIN_XMAX_CM) :: njmin_crust_mantle,njmax_crust_mantle,nkmin_xi_crust_mantle

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_OUTER_CORE_STACEY) :: vp_outer_core
  integer nspec2D_xmin_outer_core,nspec2D_xmax_outer_core,nspec2D_ymin_outer_core,nspec2D_ymax_outer_core
  integer, dimension(2,NSPEC2DMAX_YMIN_YMAX_OC) :: nimin_outer_core,nimax_outer_core,nkmin_eta_outer_core
  integer, dimension(2,NSPEC2DMAX_XMIN_XMAX_OC) :: njmin_outer_core,njmax_outer_core,nkmin_xi_outer_core

! arrays to couple with the fluid regions by pointwise matching
  integer, dimension(NSPEC2DMAX_XMIN_XMAX_OC) :: ibelm_xmin_outer_core,ibelm_xmax_outer_core
  integer, dimension(NSPEC2DMAX_YMIN_YMAX_OC) :: ibelm_ymin_outer_core,ibelm_ymax_outer_core
  integer, dimension(NSPEC2D_BOTTOM_OC) :: ibelm_bottom_outer_core
  integer, dimension(NSPEC2D_TOP_OC) :: ibelm_top_outer_core

  real(kind=CUSTOM_REAL), dimension(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX_OC) :: normal_xmin_outer_core,normal_xmax_outer_core
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX_OC) :: normal_ymin_outer_core,normal_ymax_outer_core
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLLX,NGLLY,NSPEC2D_BOTTOM_OC) :: normal_bottom_outer_core
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLLX,NGLLY,NSPEC2D_TOP_OC) :: normal_top_outer_core

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NSPEC2D_BOTTOM_OC) :: jacobian2D_bottom_outer_core
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NSPEC2D_TOP_OC) :: jacobian2D_top_outer_core
  real(kind=CUSTOM_REAL), dimension(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX_OC) :: jacobian2D_xmin_outer_core,jacobian2D_xmax_outer_core
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX_OC) :: jacobian2D_ymin_outer_core,jacobian2D_ymax_outer_core


  integer, dimension(NSPEC2DMAX_XMIN_XMAX_IC) :: ibelm_xmin_inner_core,ibelm_xmax_inner_core
  integer, dimension(NSPEC2DMAX_YMIN_YMAX_IC) :: ibelm_ymin_inner_core,ibelm_ymax_inner_core
  integer, dimension(NSPEC2D_BOTTOM_IC) :: ibelm_bottom_inner_core
  integer, dimension(NSPEC2D_TOP_IC) :: ibelm_top_inner_core

! for matching between fluid and solid regions
  integer :: ispec2D,k_corresp,ispec_selected
  real(kind=CUSTOM_REAL) :: displ_x,displ_y,displ_z,nx,ny,nz,displ_n,weight,pressure

! for absorbing conditions
  real(kind=CUSTOM_REAL) :: vx,vy,vz,vn


! for ellipticity
  integer nspl
  double precision rspl(NR),espl(NR),espl2(NR)

! for conversion from x y z to r theta phi
  real(kind=CUSTOM_REAL) rval,thetaval,phival

! ---- arrays to assemble between chunks

! communication pattern for faces between chunks
  integer, dimension(NUMMSGS_FACES_VAL) :: iprocfrom_faces,iprocto_faces,imsg_type

! communication pattern for corners between chunks
  integer, dimension(NCORNERSCHUNKS_VAL) :: iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners

! indirect addressing for each message for faces and corners of the chunks
! a given slice can belong to at most one corner and at most two faces
  integer NGLOB2DMAX_XY
  integer, dimension(NGLOB2DMAX_XY_VAL,NUMFACES_SHARED) :: iboolfaces_crust_mantle, &
      iboolfaces_outer_core,iboolfaces_inner_core

! buffers for send and receive between faces of the slices and the chunks
  real(kind=CUSTOM_REAL), dimension(NGLOB2DMAX_XY_VAL) :: buffer_send_faces_scalar,buffer_received_faces_scalar
! size of buffers is multiplied by 2 because we handle two regions in the same MPI call
  real(kind=CUSTOM_REAL), dimension(NDIM,2*NGLOB2DMAX_XY_VAL) :: buffer_send_faces_vector,buffer_received_faces_vector

! -------- arrays specific to each region here -----------

! ----------------- crust, mantle and oceans ---------------------

! mesh parameters
  integer, dimension(NGLLX,NGLLY,NGLLZ,NSPEC_CRUST_MANTLE) :: ibool_crust_mantle

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_CRUST_MANTLE) :: &
        xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle,&
        etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
        gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle
  real(kind=CUSTOM_REAL), dimension(NGLOB_CRUST_MANTLE) :: &
        xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle

! arrays for isotropic elements stored only where needed to save space
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_ISO_MANTLE) :: &
        rhostore_crust_mantle,kappavstore_crust_mantle,muvstore_crust_mantle

! arrays for anisotropic elements stored only where needed to save space
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_TISO_MANTLE) :: &
        kappahstore_crust_mantle,muhstore_crust_mantle,eta_anisostore_crust_mantle

! arrays for full anisotropy only when needed
  integer nspec_iso,nspec_tiso,nspec_ani
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE) :: &
        c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle, &
        c14store_crust_mantle,c15store_crust_mantle,c16store_crust_mantle, &
        c22store_crust_mantle,c23store_crust_mantle,c24store_crust_mantle, &
        c25store_crust_mantle,c26store_crust_mantle,c33store_crust_mantle, &
        c34store_crust_mantle,c35store_crust_mantle,c36store_crust_mantle, &
        c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
        c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle

! local to global mapping
  integer, dimension(NSPEC_CRUST_MANTLE) :: idoubling_crust_mantle

! mass matrix
  real(kind=CUSTOM_REAL), dimension(NGLOB_CRUST_MANTLE) :: rmass_crust_mantle

! displacement, velocity, acceleration
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLOB_CRUST_MANTLE) :: &
     displ_crust_mantle,veloc_crust_mantle,accel_crust_mantle

! ----------------- outer core ---------------------

! mesh parameters
  integer, dimension(NGLLX,NGLLY,NGLLZ,NSPEC_OUTER_CORE) :: ibool_outer_core

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_OUTER_CORE) :: &
        xix_outer_core,xiy_outer_core,xiz_outer_core,&
        etax_outer_core,etay_outer_core,etaz_outer_core, &
        gammax_outer_core,gammay_outer_core,gammaz_outer_core
  real(kind=CUSTOM_REAL), dimension(NGLOB_OUTER_CORE) :: &
        xstore_outer_core,ystore_outer_core,zstore_outer_core

 real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_OUTER_CORE) :: &
        rhostore_outer_core,kappavstore_outer_core

! local to global mapping
  integer, dimension(NSPEC_OUTER_CORE) :: idoubling_outer_core

! mass matrix
  real(kind=CUSTOM_REAL), dimension(NGLOB_OUTER_CORE) :: rmass_outer_core

! velocity potential
  real(kind=CUSTOM_REAL), dimension(NGLOB_OUTER_CORE) :: displ_outer_core, &
    veloc_outer_core,accel_outer_core

! movie_volume
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: div_s_outer_core

! ----------------- inner core ---------------------

! mesh parameters
  integer, dimension(NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE) :: ibool_inner_core

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE) :: &
        xix_inner_core,xiy_inner_core,xiz_inner_core,&
        etax_inner_core,etay_inner_core,etaz_inner_core, &
        gammax_inner_core,gammay_inner_core,gammaz_inner_core, &
        rhostore_inner_core, kappavstore_inner_core,muvstore_inner_core
  real(kind=CUSTOM_REAL), dimension(NGLOB_INNER_CORE) :: &
        xstore_inner_core,ystore_inner_core,zstore_inner_core

! arrays for inner-core anisotropy only when needed
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_IC) :: &
        c11store_inner_core,c33store_inner_core,c12store_inner_core, &
        c13store_inner_core,c44store_inner_core

! local to global mapping
  integer, dimension(NSPEC_INNER_CORE) :: idoubling_inner_core

! mass matrix
  real(kind=CUSTOM_REAL), dimension(NGLOB_INNER_CORE) :: rmass_inner_core

! displacement, velocity, acceleration
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLOB_INNER_CORE) :: &
     displ_inner_core,veloc_inner_core,accel_inner_core

! Newmark time scheme parameters and non-dimensionalization
  real(kind=CUSTOM_REAL) time,deltat,deltatover2,deltatsqover2
  double precision scale_t,scale_displ,scale_veloc

! ADJOINT
  real(kind=CUSTOM_REAL) b_additional_term,b_force_normal_comp
  real(kind=CUSTOM_REAL) b_deltat,b_deltatover2,b_deltatsqover2
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLOB_CRUST_MANTLE_ADJOINT) :: &
    b_displ_crust_mantle,b_veloc_crust_mantle,b_accel_crust_mantle
  real(kind=CUSTOM_REAL), dimension(NGLOB_OUTER_CORE_ADJOINT) :: &
    b_displ_outer_core,b_veloc_outer_core,b_accel_outer_core
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLOB_INNER_CORE_ADJOINT) :: &
    b_displ_inner_core,b_veloc_inner_core,b_accel_inner_core

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_OUTER_CORE_ADJOINT) :: div_displ_outer_core
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_OUTER_CORE_ADJOINT) :: b_div_displ_outer_core

  real(kind=CUSTOM_REAL) :: rho_kl, beta_kl, alpha_kl

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_CRUST_MANTLE_ADJOINT) :: rho_kl_crust_mantle, &
     beta_kl_crust_mantle, alpha_kl_crust_mantle

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_OUTER_CORE_ADJOINT) :: rho_kl_outer_core, &
     alpha_kl_outer_core

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE_ADJOINT) :: rho_kl_inner_core, &
     beta_kl_inner_core, alpha_kl_inner_core

  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: absorb_xmin_crust_mantle, &
     absorb_xmax_crust_mantle, absorb_ymin_crust_mantle, absorb_ymax_crust_mantle

  real(kind=CUSTOM_REAL), dimension(:,:,:), allocatable :: absorb_xmin_outer_core, &
     absorb_xmax_outer_core, absorb_ymin_outer_core, absorb_ymax_outer_core, &
     absorb_zmin_outer_core

  integer reclen_xmin_crust_mantle, reclen_xmax_crust_mantle, reclen_ymin_crust_mantle, &
     reclen_ymax_crust_mantle, reclen_xmin_outer_core, reclen_xmax_outer_core,&
     reclen_ymin_outer_core, reclen_ymax_outer_core, reclen_zmin, reclen1, reclen2

  real(kind=CUSTOM_REAL), dimension(NDIM,NGLOB_OUTER_CORE) :: vector_accel_outer_core,&
             vector_displ_outer_core, b_vector_displ_outer_core

  real(kind=CUSTOM_REAL) xixl,xiyl,xizl,etaxl,etayl,etazl,gammaxl,gammayl,gammazl
  double precision scale_kl

  integer npoin2D_faces_crust_mantle(NUMFACES_SHARED)
  integer npoin2D_faces_outer_core(NUMFACES_SHARED)
  integer npoin2D_faces_inner_core(NUMFACES_SHARED)

! parameters for the source
  integer it,isource
  integer, dimension(:), allocatable :: islice_selected_source,ispec_selected_source
  integer yr,jda,ho,mi
  real(kind=CUSTOM_REAL) stf_used
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLLX,NGLLY,NGLLZ) :: sourcearray
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:), allocatable :: sourcearrays
  double precision, dimension(:,:,:) ,allocatable:: nu_source
  double precision sec,stf
  double precision, dimension(:), allocatable :: Mxx,Myy,Mzz,Mxy,Mxz,Myz
  double precision, dimension(:), allocatable :: xi_source,eta_source,gamma_source
  double precision, dimension(:), allocatable :: t_cmt,hdur,hdur_gaussian
  double precision, dimension(:), allocatable :: theta_source,phi_source
  double precision, external :: comp_source_time_function
  double precision t0

! receiver information
  integer nrec,nrec_local,nrec_tot_found
  integer irec_local
  integer, dimension(:), allocatable :: islice_selected_rec,ispec_selected_rec,number_receiver_global
  double precision, dimension(:), allocatable :: xi_receiver,eta_receiver,gamma_receiver
  double precision hlagrange
  character(len=150) STATIONS
  character(len=150) :: rec_filename
  double precision, dimension(:,:,:), allocatable :: nu
  double precision, allocatable, dimension(:) :: stlat,stlon,stele
  character(len=MAX_LENGTH_STATION_NAME), dimension(:), allocatable  :: station_name
  character(len=MAX_LENGTH_NETWORK_NAME), dimension(:), allocatable :: network_name

!ADJOINT
  character(len=150) adj_source_file
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:), allocatable :: adj_sourcearray
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:,:), allocatable :: adj_sourcearrays
  integer nrec_simulation, nadj_rec_local
  logical ibool_read_adj_arrays
  integer NSTEP_SUB_ADJ,it_sub_adj,iadj_block !To read input in chunks
  integer, dimension(:,:), allocatable :: iadjsrc !To read input in chunks
  integer, dimension(:), allocatable :: iadjsrc_len,iadj_vec

! seismograms
  integer it_begin,it_end,nit_written
  double precision uxd, uyd, uzd, eps_trace,dxx,dyy,dxy,dxz,dyz,eps_loc(NDIM,NDIM), eps_loc_new(NDIM,NDIM)
  real(kind=CUSTOM_REAL), dimension(:,:,:), allocatable :: seismograms
  integer :: seismo_offset, seismo_current

! non-dimensionalized rotation rate of the Earth times two
  real(kind=CUSTOM_REAL) two_omega_earth

! for the Euler scheme for rotation
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_OUTER_CORE_ROTATION) :: &
    A_array_rotation,B_array_rotation

  integer i,j,k,l,ispec,irec,iglob,iglob_mantle,iglob_inner_core

! number of faces between chunks
  integer NUM_FACES,NUMMSGS_FACES

! number of corners between chunks
  integer NCORNERSCHUNKS

! number of message types
  integer NUM_MSG_TYPES

! indirect addressing for each corner of the chunks
  integer, dimension(NGLOB1D_RADIAL_CM,NUMCORNERS_SHARED) :: iboolcorner_crust_mantle
  integer, dimension(NGLOB1D_RADIAL_OC,NUMCORNERS_SHARED) :: iboolcorner_outer_core
  integer, dimension(NGLOB1D_RADIAL_IC,NUMCORNERS_SHARED) :: iboolcorner_inner_core

! buffers for send and receive between corners of the chunks
  real(kind=CUSTOM_REAL), dimension(NGLOB1D_RADIAL_CM) :: buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar
! size of buffers is the sum of two sizes because we handle two regions in the same MPI call
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLOB1D_RADIAL_CM + NGLOB1D_RADIAL_IC) :: &
     buffer_send_chunkcorners_vector,buffer_recv_chunkcorners_vector

! Gauss-Lobatto-Legendre points of integration and weights
  double precision, dimension(NGLLX) :: xigll,wxgll
  double precision, dimension(NGLLY) :: yigll,wygll
  double precision, dimension(NGLLZ) :: zigll,wzgll

! product of weights for gravity term
  double precision, dimension(NGLLX,NGLLY,NGLLZ) :: wgll_cube

! array with derivatives of Lagrange polynomials and precalculated products
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLX) :: hprime_xx,hprimewgll_xx
  real(kind=CUSTOM_REAL), dimension(NGLLY,NGLLY) :: hprime_yy,hprimewgll_yy
  real(kind=CUSTOM_REAL), dimension(NGLLZ,NGLLZ) :: hprime_zz,hprimewgll_zz
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY) :: wgllwgll_xy
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLZ) :: wgllwgll_xz
  real(kind=CUSTOM_REAL), dimension(NGLLY,NGLLZ) :: wgllwgll_yz

! Lagrange interpolators at receivers
  double precision, dimension(NGLLX) :: hxir,hpxir
  double precision, dimension(NGLLY) :: hpetar,hetar
  double precision, dimension(NGLLZ) :: hgammar,hpgammar
  double precision, dimension(:,:), allocatable :: hxir_store,hetar_store,hgammar_store

! 2-D addressing and buffers for summation between slices
  integer, dimension(NGLOB2DMAX_XMIN_XMAX_CM) :: iboolleft_xi_crust_mantle,iboolright_xi_crust_mantle
  integer, dimension(NGLOB2DMAX_YMIN_YMAX_CM) :: iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle

  integer, dimension(NGLOB2DMAX_XMIN_XMAX_OC) :: iboolleft_xi_outer_core,iboolright_xi_outer_core
  integer, dimension(NGLOB2DMAX_YMIN_YMAX_OC) :: iboolleft_eta_outer_core,iboolright_eta_outer_core

  integer, dimension(NGLOB2DMAX_XMIN_XMAX_IC) :: iboolleft_xi_inner_core,iboolright_xi_inner_core
  integer, dimension(NGLOB2DMAX_YMIN_YMAX_IC) :: iboolleft_eta_inner_core,iboolright_eta_inner_core

! for addressing of the slices
  integer, dimension(NCHUNKS_VAL,0:NPROC_XI_VAL-1,0:NPROC_ETA_VAL-1) :: addressing
  integer, dimension(0:NPROCTOT_VAL-1) :: ichunk_slice,iproc_xi_slice,iproc_eta_slice

! proc numbers for MPI
  integer myrank,sizeprocs,ier

  integer, dimension(NB_SQUARE_EDGES_ONEDIR) :: npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle
  integer, dimension(NB_SQUARE_EDGES_ONEDIR) :: npoin2D_xi_outer_core,npoin2D_eta_outer_core
  integer, dimension(NB_SQUARE_EDGES_ONEDIR) :: npoin2D_xi_inner_core,npoin2D_eta_inner_core

  integer ichunk,iproc_xi,iproc_eta,iproc,iproc_read
  integer NPROC_ONE_DIRECTION

! maximum of the norm of the displacement and of the potential in the fluid
  real(kind=CUSTOM_REAL) Usolidnorm,Usolidnorm_all,Ufluidnorm,Ufluidnorm_all

!ADJOINT
  real(kind=CUSTOM_REAL) b_two_omega_earth
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_OUTER_CORE_ROT_ADJOINT) :: b_A_array_rotation,b_B_array_rotation
  real(kind=CUSTOM_REAL) b_Usolidnorm,b_Usolidnorm_all,b_Ufluidnorm,b_Ufluidnorm_all
  real(kind=CUSTOM_REAL) :: tempx1l,tempx2l,tempx3l

! timer MPI
  integer :: ihours,iminutes,iseconds,int_tCPU, &
             ihours_remain,iminutes_remain,iseconds_remain,int_t_remain, &
             ihours_total,iminutes_total,iseconds_total,int_t_total

  double precision :: time_start,tCPU,t_remain,t_total

! parameters read from parameter file
  integer MIN_ATTENUATION_PERIOD,MAX_ATTENUATION_PERIOD,NER_CRUST, &
          NER_80_MOHO,NER_220_80,NER_400_220,NER_600_400,NER_670_600,NER_771_670, &
          NER_TOPDDOUBLEPRIME_771,NER_CMB_TOPDDOUBLEPRIME,NER_OUTER_CORE, &
          NER_TOP_CENTRAL_CUBE_ICB,NEX_XI,NEX_ETA,RMOHO_FICTITIOUS_IN_MESHER, &
          NPROC_XI,NPROC_ETA,NTSTEP_BETWEEN_OUTPUT_SEISMOS,&
          NTSTEP_BETWEEN_READ_ADJSRC,NSTEP,NSOURCES,NTSTEP_BETWEEN_FRAMES, &
          NTSTEP_BETWEEN_OUTPUT_INFO,NUMBER_OF_RUNS,NUMBER_OF_THIS_RUN,NCHUNKS,SIMULATION_TYPE, &
          REFERENCE_1D_MODEL,THREE_D_MODEL

  double precision DT,ANGULAR_WIDTH_XI_IN_DEGREES,ANGULAR_WIDTH_ETA_IN_DEGREES,CENTER_LONGITUDE_IN_DEGREES, &
          CENTER_LATITUDE_IN_DEGREES,GAMMA_ROTATION_AZIMUTH,ROCEAN,RMIDDLE_CRUST, &
          RMOHO,R80,R120,R220,R400,R600,R670,R771,RTOPDDOUBLEPRIME,RCMB,RICB, &
          R_CENTRAL_CUBE,RHO_TOP_OC,RHO_BOTTOM_OC,RHO_OCEANS,HDUR_MOVIE

  logical TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE,ANISOTROPIC_INNER_CORE, &
          CRUSTAL,ELLIPTICITY,GRAVITY,ONE_CRUST,ROTATION,ISOTROPIC_3D_MANTLE, &
          TOPOGRAPHY,OCEANS,MOVIE_SURFACE,MOVIE_VOLUME,ATTENUATION_3D, &
          RECEIVERS_CAN_BE_BURIED,PRINT_SOURCE_TIME_FUNCTION, &
          SAVE_MESH_FILES,ATTENUATION, &
          ABSORBING_CONDITIONS,INCLUDE_CENTRAL_CUBE,INFLATE_CENTRAL_CUBE,SAVE_FORWARD, &
          OUTPUT_SEISMOS_ASCII_TEXT,OUTPUT_SEISMOS_SAC_ALPHANUM,OUTPUT_SEISMOS_SAC_BINARY, &
          ROTATE_SEISMOGRAMS_RT,HONOR_1D_SPHERICAL_MOHO,WRITE_SEISMOGRAMS_BY_MASTER,&
          SAVE_ALL_SEISMOS_IN_ONE_FILE,USE_BINARY_FOR_LARGE_FILE

  character(len=150) OUTPUT_FILES,LOCAL_PATH,MODEL

! parameters deduced from parameters read from file
  integer NPROC,NPROCTOT,NEX_PER_PROC_XI,NEX_PER_PROC_ETA,ratio_divide_central_cube

  integer, external :: err_occurred

  logical SAVE_STRAIN

! for SAC headers for seismograms
  integer NSOURCES_SAC,yr_SAC,jda_SAC,ho_SAC,mi_SAC
  real mb_SAC
  double precision t_cmt_SAC,elat_SAC,elon_SAC,depth_SAC,cmt_lat_SAC,cmt_lon_SAC,cmt_depth_SAC,cmt_hdur_SAC,sec_SAC
  character(len=12) ename_SAC

! this for all the regions
  integer, dimension(MAX_NUM_REGIONS) :: NSPEC_computed, &
               NSPEC2D_XI, NSPEC2D_ETA, &
               NSPEC2DMAX_XMIN_XMAX,NSPEC2DMAX_YMIN_YMAX, &
               NSPEC2D_BOTTOM,NSPEC2D_TOP, &
               NSPEC1D_RADIAL,NGLOB1D_RADIAL, &
               NGLOB2DMAX_XMIN_XMAX,NGLOB2DMAX_YMIN_YMAX, &
               NGLOB_computed

  character(len=150) prname

! lookup table every km for gravity
  integer int_radius,nspl_gravity,idoubling
  real(kind=CUSTOM_REAL) minus_g_cmb,minus_g_icb
  double precision radius,radius_km,g,dg,rho,drhodr,vp,vs,Qkappa,Qmu
  double precision g_cmb_dble,g_icb_dble
  double precision, dimension(NRAD_GRAVITY) :: minus_gravity_table, &
    minus_deriv_gravity_table,density_table,d_ln_density_dr_table,minus_rho_g_over_kappa_fluid
  double precision rspl_gravity(NR),gspl(NR),gspl2(NR)

! flags to read kappa and mu and anisotropy arrays in regions where needed
  logical READ_KAPPA_MU,READ_TISO

! dummy array that does not need to be actually read
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,1) :: dummy_array

! names of the data files for all the processors in MPI
  character(len=150) outputname

! if running on MareNostrum in Barcelona
  character(len=400) system_command

  integer iregion_selected

! computed in read_compute_parameters
  integer, dimension(MAX_NUMBER_OF_MESH_LAYERS) :: ner,ratio_sampling_array
  integer, dimension(MAX_NUMBER_OF_MESH_LAYERS) :: doubling_index
  double precision, dimension(MAX_NUMBER_OF_MESH_LAYERS) :: r_bottom,r_top
  logical, dimension(MAX_NUMBER_OF_MESH_LAYERS) :: this_region_has_a_doubling
  double precision, dimension(MAX_NUMBER_OF_MESH_LAYERS) :: rmins,rmaxs
  logical :: CASE_3D

! arrays for BCAST
  integer, dimension(35) :: bcast_integer
  double precision, dimension(24) :: bcast_double_precision
  logical, dimension(32) :: bcast_logical

! Boundary Mesh and Kernels
  integer k_top,k_bot,iregion_code,njunk1,njunk2,njunk3
  integer, dimension(NSPEC2D_MOHO) :: ibelm_moho_top,ibelm_moho_bot
  integer, dimension(NSPEC2D_400) :: ibelm_400_top,ibelm_400_bot
  integer, dimension(NSPEC2D_670) :: ibelm_670_top,ibelm_670_bot
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLLX,NGLLY,NSPEC2D_MOHO) :: normal_moho
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLLX,NGLLY,NSPEC2D_400) :: normal_400
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLLX,NGLLY,NSPEC2D_670) :: normal_670
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NSPEC2D_MOHO) :: moho_kl, moho_kl_top, moho_kl_bot
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NSPEC2D_400) :: d400_kl, d400_kl_top, d400_kl_bot
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NSPEC2D_670) ::  d670_kl, d670_kl_top, d670_kl_bot
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NSPEC2D_CMB) :: cmb_kl, cmb_kl_top, cmb_kl_bot
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NSPEC2D_ICB) :: icb_kl, icb_kl_top, icb_kl_bot
  logical :: fluid_solid_boundary

  logical :: CUT_SUPERBRICK_XI,CUT_SUPERBRICK_ETA
  integer, dimension(NB_SQUARE_CORNERS,NB_CUT_CASE) :: DIFF_NSPEC1D_RADIAL
  integer, dimension(NB_SQUARE_EDGES_ONEDIR,NB_CUT_CASE) :: DIFF_NSPEC2D_XI,DIFF_NSPEC2D_ETA

! ************** PROGRAM STARTS HERE **************

! sizeprocs returns number of processes started (should be equal to NPROCTOT).
! myrank is the rank of each process, between 0 and sizeprocs-1.
! as usual in MPI, process 0 is in charge of coordinating everything
! and also takes care of the main output
  call MPI_COMM_SIZE(MPI_COMM_WORLD,sizeprocs,ier)
  call MPI_COMM_RANK(MPI_COMM_WORLD,myrank,ier)

  if (myrank == 0) then

! read the parameter file and compute additional parameters
  call read_compute_parameters(MIN_ATTENUATION_PERIOD,MAX_ATTENUATION_PERIOD,NER_CRUST, &
         NER_80_MOHO,NER_220_80,NER_400_220,NER_600_400,NER_670_600,NER_771_670, &
         NER_TOPDDOUBLEPRIME_771,NER_CMB_TOPDDOUBLEPRIME,NER_OUTER_CORE, &
         NER_TOP_CENTRAL_CUBE_ICB,NEX_XI,NEX_ETA,RMOHO_FICTITIOUS_IN_MESHER, &
         NPROC_XI,NPROC_ETA,NTSTEP_BETWEEN_OUTPUT_SEISMOS, &
         NTSTEP_BETWEEN_READ_ADJSRC,NSTEP,NTSTEP_BETWEEN_FRAMES, &
         NTSTEP_BETWEEN_OUTPUT_INFO,NUMBER_OF_RUNS,NUMBER_OF_THIS_RUN,NCHUNKS,DT, &
         ANGULAR_WIDTH_XI_IN_DEGREES,ANGULAR_WIDTH_ETA_IN_DEGREES,CENTER_LONGITUDE_IN_DEGREES, &
         CENTER_LATITUDE_IN_DEGREES,GAMMA_ROTATION_AZIMUTH,ROCEAN,RMIDDLE_CRUST, &
         RMOHO,R80,R120,R220,R400,R600,R670,R771,RTOPDDOUBLEPRIME,RCMB,RICB, &
         R_CENTRAL_CUBE,RHO_TOP_OC,RHO_BOTTOM_OC,RHO_OCEANS,HDUR_MOVIE, &
         TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE, &
         ANISOTROPIC_INNER_CORE,CRUSTAL,ELLIPTICITY,GRAVITY,ONE_CRUST, &
         ROTATION,ISOTROPIC_3D_MANTLE,TOPOGRAPHY,OCEANS,MOVIE_SURFACE, &
         MOVIE_VOLUME,ATTENUATION_3D,RECEIVERS_CAN_BE_BURIED, &
         PRINT_SOURCE_TIME_FUNCTION,SAVE_MESH_FILES, &
         ATTENUATION,REFERENCE_1D_MODEL,THREE_D_MODEL,ABSORBING_CONDITIONS, &
         INCLUDE_CENTRAL_CUBE,INFLATE_CENTRAL_CUBE,LOCAL_PATH,MODEL,SIMULATION_TYPE,SAVE_FORWARD, &
         NPROC,NPROCTOT,NEX_PER_PROC_XI,NEX_PER_PROC_ETA, &
         NSPEC_computed, &
         NSPEC2D_XI, &
         NSPEC2D_ETA, &
         NSPEC2DMAX_XMIN_XMAX,NSPEC2DMAX_YMIN_YMAX,NSPEC2D_BOTTOM,NSPEC2D_TOP, &
         NSPEC1D_RADIAL,NGLOB1D_RADIAL, &
         NGLOB2DMAX_XMIN_XMAX,NGLOB2DMAX_YMIN_YMAX, &
         NGLOB_computed, &
         ratio_sampling_array, ner, doubling_index,r_bottom,r_top,this_region_has_a_doubling,rmins,rmaxs,CASE_3D, &
         OUTPUT_SEISMOS_ASCII_TEXT,OUTPUT_SEISMOS_SAC_ALPHANUM,OUTPUT_SEISMOS_SAC_BINARY, &
         ROTATE_SEISMOGRAMS_RT,ratio_divide_central_cube,HONOR_1D_SPHERICAL_MOHO,CUT_SUPERBRICK_XI,CUT_SUPERBRICK_ETA,&
         DIFF_NSPEC1D_RADIAL,DIFF_NSPEC2D_XI,DIFF_NSPEC2D_ETA,&
         WRITE_SEISMOGRAMS_BY_MASTER,SAVE_ALL_SEISMOS_IN_ONE_FILE,USE_BINARY_FOR_LARGE_FILE)

    if(err_occurred() /= 0) then
          call exit_MPI(myrank,'an error occurred while reading the parameter file')
    endif

! count the total number of sources in the CMTSOLUTION file
    call count_number_of_sources(NSOURCES)

    bcast_integer = (/MIN_ATTENUATION_PERIOD,MAX_ATTENUATION_PERIOD,NER_CRUST, &
            NER_80_MOHO,NER_220_80,NER_400_220,NER_600_400,NER_670_600,NER_771_670, &
            NER_TOPDDOUBLEPRIME_771,NER_CMB_TOPDDOUBLEPRIME,NER_OUTER_CORE, &
            NER_TOP_CENTRAL_CUBE_ICB,NEX_XI,NEX_ETA,RMOHO_FICTITIOUS_IN_MESHER, &
            NPROC_XI,NPROC_ETA,NTSTEP_BETWEEN_OUTPUT_SEISMOS, &
            NTSTEP_BETWEEN_READ_ADJSRC,NSTEP,NSOURCES,NTSTEP_BETWEEN_FRAMES, &
            NTSTEP_BETWEEN_OUTPUT_INFO,NUMBER_OF_RUNS,NUMBER_OF_THIS_RUN,NCHUNKS,&
            SIMULATION_TYPE,REFERENCE_1D_MODEL,THREE_D_MODEL,NPROC,NPROCTOT, &
            NEX_PER_PROC_XI,NEX_PER_PROC_ETA,ratio_divide_central_cube/)

    bcast_logical = (/TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE,ANISOTROPIC_INNER_CORE, &
            CRUSTAL,ELLIPTICITY,GRAVITY,ONE_CRUST,ROTATION,ISOTROPIC_3D_MANTLE, &
            TOPOGRAPHY,OCEANS,MOVIE_SURFACE,MOVIE_VOLUME,ATTENUATION_3D, &
            RECEIVERS_CAN_BE_BURIED,PRINT_SOURCE_TIME_FUNCTION, &
            SAVE_MESH_FILES,ATTENUATION, &
            ABSORBING_CONDITIONS,INCLUDE_CENTRAL_CUBE,INFLATE_CENTRAL_CUBE,SAVE_FORWARD,CASE_3D, &
            OUTPUT_SEISMOS_ASCII_TEXT,OUTPUT_SEISMOS_SAC_ALPHANUM,OUTPUT_SEISMOS_SAC_BINARY, &
            ROTATE_SEISMOGRAMS_RT,CUT_SUPERBRICK_XI,CUT_SUPERBRICK_ETA,&
            WRITE_SEISMOGRAMS_BY_MASTER,SAVE_ALL_SEISMOS_IN_ONE_FILE,USE_BINARY_FOR_LARGE_FILE/)

    bcast_double_precision = (/DT,ANGULAR_WIDTH_XI_IN_DEGREES,ANGULAR_WIDTH_ETA_IN_DEGREES,CENTER_LONGITUDE_IN_DEGREES, &
            CENTER_LATITUDE_IN_DEGREES,GAMMA_ROTATION_AZIMUTH,ROCEAN,RMIDDLE_CRUST, &
            RMOHO,R80,R120,R220,R400,R600,R670,R771,RTOPDDOUBLEPRIME,RCMB,RICB, &
            R_CENTRAL_CUBE,RHO_TOP_OC,RHO_BOTTOM_OC,RHO_OCEANS,HDUR_MOVIE/)

  endif

! broadcast the information read on the master to the nodes
    call MPI_BCAST(NSOURCES,1,MPI_INTEGER,0,MPI_COMM_WORLD,ier)

    call MPI_BCAST(bcast_integer,35,MPI_INTEGER,0,MPI_COMM_WORLD,ier)

    call MPI_BCAST(bcast_double_precision,24,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ier)

    call MPI_BCAST(bcast_logical,32,MPI_LOGICAL,0,MPI_COMM_WORLD,ier)

    call MPI_BCAST(LOCAL_PATH,150,MPI_CHARACTER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(MODEL,150,MPI_CHARACTER,0,MPI_COMM_WORLD,ier)

    call MPI_BCAST(ner,MAX_NUMBER_OF_MESH_LAYERS,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(ratio_sampling_array,MAX_NUMBER_OF_MESH_LAYERS,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(doubling_index,MAX_NUMBER_OF_MESH_LAYERS,MPI_INTEGER,0,MPI_COMM_WORLD,ier)

    call MPI_BCAST(r_bottom,MAX_NUMBER_OF_MESH_LAYERS,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(r_top,MAX_NUMBER_OF_MESH_LAYERS,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(rmins,MAX_NUMBER_OF_MESH_LAYERS,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(rmaxs,MAX_NUMBER_OF_MESH_LAYERS,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ier)

    call MPI_BCAST(this_region_has_a_doubling,MAX_NUMBER_OF_MESH_LAYERS,MPI_LOGICAL,0,MPI_COMM_WORLD,ier)

    call MPI_BCAST(NSPEC_computed,MAX_NUM_REGIONS,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(NSPEC2D_XI,MAX_NUM_REGIONS,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(NSPEC2D_ETA,MAX_NUM_REGIONS,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(NSPEC2DMAX_XMIN_XMAX,MAX_NUM_REGIONS,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(NSPEC2DMAX_YMIN_YMAX,MAX_NUM_REGIONS,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(NSPEC2D_BOTTOM,MAX_NUM_REGIONS,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(NSPEC2D_TOP,MAX_NUM_REGIONS,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(NSPEC1D_RADIAL,MAX_NUM_REGIONS,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(NGLOB1D_RADIAL,MAX_NUM_REGIONS,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(NGLOB2DMAX_XMIN_XMAX,MAX_NUM_REGIONS,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(NGLOB2DMAX_YMIN_YMAX,MAX_NUM_REGIONS,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(NGLOB_computed,MAX_NUM_REGIONS,MPI_INTEGER,0,MPI_COMM_WORLD,ier)

    call MPI_BCAST(DIFF_NSPEC1D_RADIAL,NB_SQUARE_CORNERS*NB_CUT_CASE,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(DIFF_NSPEC2D_ETA,NB_SQUARE_EDGES_ONEDIR*NB_CUT_CASE,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
    call MPI_BCAST(DIFF_NSPEC2D_XI,NB_SQUARE_EDGES_ONEDIR*NB_CUT_CASE,MPI_INTEGER,0,MPI_COMM_WORLD,ier)

  if (myrank /=0) then

    MIN_ATTENUATION_PERIOD = bcast_integer(1)
    MAX_ATTENUATION_PERIOD = bcast_integer(2)
    NER_CRUST = bcast_integer(3)
    NER_80_MOHO = bcast_integer(4)
    NER_220_80 = bcast_integer(5)
    NER_400_220 = bcast_integer(6)
    NER_600_400 = bcast_integer(7)
    NER_670_600 = bcast_integer(8)
    NER_771_670 = bcast_integer(9)
    NER_TOPDDOUBLEPRIME_771 = bcast_integer(10)
    NER_CMB_TOPDDOUBLEPRIME = bcast_integer(11)
    NER_OUTER_CORE = bcast_integer(12)
    NER_TOP_CENTRAL_CUBE_ICB = bcast_integer(13)
    NEX_XI = bcast_integer(14)
    NEX_ETA = bcast_integer(15)
    RMOHO_FICTITIOUS_IN_MESHER = bcast_integer(16)
    NPROC_XI = bcast_integer(17)
    NPROC_ETA = bcast_integer(18)
    NTSTEP_BETWEEN_OUTPUT_SEISMOS = bcast_integer(19)
    NTSTEP_BETWEEN_READ_ADJSRC = bcast_integer(20)
    NSTEP = bcast_integer(21)
    NSOURCES = bcast_integer(22)
    NTSTEP_BETWEEN_FRAMES = bcast_integer(23)
    NTSTEP_BETWEEN_OUTPUT_INFO = bcast_integer(24)
    NUMBER_OF_RUNS = bcast_integer(25)
    NUMBER_OF_THIS_RUN = bcast_integer(26)
    NCHUNKS = bcast_integer(27)
    SIMULATION_TYPE = bcast_integer(28)
    REFERENCE_1D_MODEL = bcast_integer(29)
    THREE_D_MODEL = bcast_integer(30)
    NPROC = bcast_integer(31)
    NPROCTOT = bcast_integer(32)
    NEX_PER_PROC_XI = bcast_integer(33)
    NEX_PER_PROC_ETA = bcast_integer(34)
    ratio_divide_central_cube = bcast_integer(35)

    TRANSVERSE_ISOTROPY = bcast_logical(1)
    ANISOTROPIC_3D_MANTLE = bcast_logical(2)
    ANISOTROPIC_INNER_CORE = bcast_logical(3)
    CRUSTAL = bcast_logical(4)
    ELLIPTICITY = bcast_logical(5)
    GRAVITY = bcast_logical(6)
    ONE_CRUST = bcast_logical(7)
    ROTATION = bcast_logical(8)
    ISOTROPIC_3D_MANTLE = bcast_logical(9)
    TOPOGRAPHY = bcast_logical(10)
    OCEANS = bcast_logical(11)
    MOVIE_SURFACE = bcast_logical(12)
    MOVIE_VOLUME = bcast_logical(13)
    ATTENUATION_3D = bcast_logical(14)
    RECEIVERS_CAN_BE_BURIED = bcast_logical(15)
    PRINT_SOURCE_TIME_FUNCTION = bcast_logical(16)
    SAVE_MESH_FILES = bcast_logical(17)
    ATTENUATION = bcast_logical(18)
    ABSORBING_CONDITIONS = bcast_logical(19)
    INCLUDE_CENTRAL_CUBE = bcast_logical(20)
    INFLATE_CENTRAL_CUBE = bcast_logical(21)
    SAVE_FORWARD = bcast_logical(22)
    CASE_3D = bcast_logical(23)
    OUTPUT_SEISMOS_ASCII_TEXT = bcast_logical(24)
    OUTPUT_SEISMOS_SAC_ALPHANUM = bcast_logical(25)
    OUTPUT_SEISMOS_SAC_BINARY = bcast_logical(26)
    ROTATE_SEISMOGRAMS_RT = bcast_logical(27)
    CUT_SUPERBRICK_XI = bcast_logical(28)
    CUT_SUPERBRICK_ETA = bcast_logical(29)
    WRITE_SEISMOGRAMS_BY_MASTER = bcast_logical(30)
    SAVE_ALL_SEISMOS_IN_ONE_FILE = bcast_logical(31)
    USE_BINARY_FOR_LARGE_FILE = bcast_logical(32)

    DT = bcast_double_precision(1)
    ANGULAR_WIDTH_XI_IN_DEGREES = bcast_double_precision(2)
    ANGULAR_WIDTH_ETA_IN_DEGREES = bcast_double_precision(3)
    CENTER_LONGITUDE_IN_DEGREES = bcast_double_precision(4)
    CENTER_LATITUDE_IN_DEGREES = bcast_double_precision(5)
    GAMMA_ROTATION_AZIMUTH = bcast_double_precision(6)
    ROCEAN = bcast_double_precision(7)
    RMIDDLE_CRUST = bcast_double_precision(8)
    RMOHO = bcast_double_precision(9)
    R80 = bcast_double_precision(10)
    R120 = bcast_double_precision(11)
    R220 = bcast_double_precision(12)
    R400 = bcast_double_precision(13)
    R600 = bcast_double_precision(14)
    R670 = bcast_double_precision(15)
    R771 = bcast_double_precision(16)
    RTOPDDOUBLEPRIME = bcast_double_precision(17)
    RCMB = bcast_double_precision(18)
    RICB = bcast_double_precision(19)
    R_CENTRAL_CUBE = bcast_double_precision(20)
    RHO_TOP_OC = bcast_double_precision(21)
    RHO_BOTTOM_OC = bcast_double_precision(22)
    RHO_OCEANS = bcast_double_precision(23)
    HDUR_MOVIE = bcast_double_precision(24)

  endif

! if (NTSTEP_BETWEEN_OUTPUT_SEISMOS > NSTEP)
! BS BS: Do we need this? Seismograms are written anyway after the time loop
!  NTSTEP_BETWEEN_OUTPUT_SEISMOS = min(NSTEP, NTSTEP_BETWEEN_OUTPUT_SEISMOS)

! if running on MareNostrum in Barcelona
  if(RUN_ON_MARENOSTRUM_BARCELONA) then

! check that we combine the seismograms in one large file to avoid GPFS overloading
    if(.not. SAVE_ALL_SEISMOS_IN_ONE_FILE) call exit_MPI(myrank,'should use SAVE_ALL_SEISMOS_IN_ONE_FILE for GPFS in Barcelona')

! use the local scratch disk to save all the files, ignore the path that is given in the Par_file
    LOCAL_PATH = '/scratch/komatits_new'

! add processor name to local /scratch/komatits_new path
    write(system_command,"('_proc',i4.4)") myrank
    LOCAL_PATH = trim(LOCAL_PATH) // trim(system_command)

  endif

! check simulation pararmeters
  if (SIMULATION_TYPE /= 1 .and.  SIMULATION_TYPE /= 2 .and. SIMULATION_TYPE /= 3) &
          call exit_MPI(myrank, 'SIMULATION_TYPE could be only 1, 2, or 3')

  if (SIMULATION_TYPE /= 1 .and. NSOURCES > 999999)  &
    call exit_MPI(myrank, 'for adjoint simulations, NSOURCES <= 999999, if you need more change i6.6 in write_seismograms.f90')

  if (SIMULATION_TYPE == 3 .and. ATTENUATION_VAL) &
    call exit_MPI(myrank, 'attenuation is not implemented for kernel simulations yet')

  if((SIMULATION_TYPE == 1 .and. SAVE_FORWARD) .or. SIMULATION_TYPE == 3) then
    if(NSPEC_CRUST_MANTLE_ADJOINT /= NSPEC_CRUST_MANTLE &
      .or. NSPEC_OUTER_CORE_ADJOINT /= NSPEC_OUTER_CORE &
      .or. NSPEC_INNER_CORE_ADJOINT /= NSPEC_INNER_CORE &
      .or. NGLOB_CRUST_MANTLE_ADJOINT /= NGLOB_CRUST_MANTLE &
      .or. NGLOB_OUTER_CORE_ADJOINT /= NGLOB_OUTER_CORE &
      .or. NGLOB_INNER_CORE_ADJOINT /= NGLOB_INNER_CORE) call exit_MPI(myrank, 'improper dimensions of adjoint arrays')
  endif

  if (SIMULATION_TYPE == 3 .and. ANISOTROPIC_3D_MANTLE_VAL .or. ANISOTROPIC_INNER_CORE_VAL) &
     call exit_MPI(myrank, 'anisotropic model is not implemented for kernel simulations yet')

  if (ATTENUATION_VAL .or. SIMULATION_TYPE /= 1 .or. SAVE_FORWARD .or. (MOVIE_VOLUME .and. SIMULATION_TYPE /= 3)) then
    SAVE_STRAIN = .true.
  else
    SAVE_STRAIN = .false.
  endif

! get the base pathname for output files
  call get_value_string(OUTPUT_FILES, 'OUTPUT_FILES', 'OUTPUT_FILES')

! open main output file, only written to by process 0
  if(myrank == 0 .and. IMAIN /= ISTANDARD_OUTPUT) &
    open(unit=IMAIN,file=trim(OUTPUT_FILES)//'/output_solver.txt',status='unknown')

  if(myrank == 0) then

  write(IMAIN,*)
  write(IMAIN,*) '******************************'
  write(IMAIN,*) '**** Specfem3D MPI Solver ****'
  write(IMAIN,*) '******************************'
  write(IMAIN,*)
  write(IMAIN,*)

  if(FIX_UNDERFLOW_PROBLEM) write(IMAIN,*) 'Fixing slow underflow trapping problem using small initial field'

  write(IMAIN,*)
  write(IMAIN,*) 'There are ',sizeprocs,' MPI processes'
  write(IMAIN,*) 'Processes are numbered from 0 to ',sizeprocs-1
  write(IMAIN,*)

  write(IMAIN,*) 'There are ',NEX_XI,' elements along xi in each chunk'
  write(IMAIN,*) 'There are ',NEX_ETA,' elements along eta in each chunk'
  write(IMAIN,*)
  write(IMAIN,*) 'There are ',NPROC_XI,' slices along xi in each chunk'
  write(IMAIN,*) 'There are ',NPROC_ETA,' slices along eta in each chunk'
  write(IMAIN,*) 'There is a total of ',NPROC,' slices in each chunk'
  write(IMAIN,*) 'There are ',NCHUNKS,' chunks'
  write(IMAIN,*) 'There is a total of ',NPROCTOT,' slices in all the chunks'

  write(IMAIN,*)
  write(IMAIN,*) 'NDIM = ',NDIM
  write(IMAIN,*)
  write(IMAIN,*) 'NGLLX = ',NGLLX
  write(IMAIN,*) 'NGLLY = ',NGLLY
  write(IMAIN,*) 'NGLLZ = ',NGLLZ
  write(IMAIN,*)

! write information about precision used for floating-point operations
  if(CUSTOM_REAL == SIZE_REAL) then
    write(IMAIN,*) 'using single precision for the calculations'
  else
    write(IMAIN,*) 'using double precision for the calculations'
  endif
  write(IMAIN,*)
  write(IMAIN,*) 'smallest and largest possible floating-point numbers are: ',tiny(1._CUSTOM_REAL),huge(1._CUSTOM_REAL)
  write(IMAIN,*)

  endif

! check that the code is running with the requested nb of processes
  if(sizeprocs /= NPROCTOT) call exit_MPI(myrank,'wrong number of MPI processes')

! check that the code has been compiled with the right values
  if (NSPEC_computed(IREGION_CRUST_MANTLE) /= NSPEC_CRUST_MANTLE) then
      write(IMAIN,*) NSPEC_computed(IREGION_CRUST_MANTLE),NSPEC_CRUST_MANTLE
      call exit_MPI(myrank,'error in compiled parameters, please recompile solver 1')
  endif
  if (NSPEC_computed(IREGION_OUTER_CORE) /= NSPEC_OUTER_CORE) then
      write(IMAIN,*) NSPEC_computed(IREGION_OUTER_CORE),NSPEC_OUTER_CORE
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver 2')
  endif
  if (NSPEC_computed(IREGION_INNER_CORE) /= NSPEC_INNER_CORE) then
      write(IMAIN,*) NSPEC_computed(IREGION_INNER_CORE),NSPEC_INNER_CORE
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver 3')
  endif
  if (ATTENUATION_3D .NEQV. ATTENUATION_3D_VAL) then
      write(IMAIN,*) ATTENUATION_3D,ATTENUATION_3D_VAL
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver 4')
  endif
  if (NCHUNKS /= NCHUNKS_VAL) then
      write(IMAIN,*) NCHUNKS,NCHUNKS_VAL
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver 6')
  endif
  if (GRAVITY .NEQV. GRAVITY_VAL) then
      write(IMAIN,*) GRAVITY,GRAVITY_VAL
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver 7')
  endif
  if (ROTATION .NEQV. ROTATION_VAL) then
      write(IMAIN,*) ROTATION,ROTATION_VAL
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver 8')
  endif
  if (ATTENUATION .NEQV. ATTENUATION_VAL) then
      write(IMAIN,*) ATTENUATION,ATTENUATION_VAL
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver 9')
  endif
  if (ELLIPTICITY .NEQV. ELLIPTICITY_VAL) then
      write(IMAIN,*) ELLIPTICITY,ELLIPTICITY_VAL
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver 10')
  endif
  if (NPROCTOT /= NPROCTOT_VAL) then
      write(IMAIN,*) NPROCTOT,NPROCTOT_VAL
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver 11')
  endif
  if (NEX_XI /= NEX_XI_VAL) then
      write(IMAIN,*) NEX_XI,NEX_XI_VAL
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver 12')
  endif
  if (NEX_ETA /= NEX_ETA_VAL) then
      write(IMAIN,*) NEX_ETA,NEX_ETA_VAL
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver 13')
  endif
  if (TRANSVERSE_ISOTROPY .NEQV. TRANSVERSE_ISOTROPY_VAL) then
      write(IMAIN,*) TRANSVERSE_ISOTROPY,TRANSVERSE_ISOTROPY_VAL
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver 14')
  endif
  if (ANISOTROPIC_3D_MANTLE .NEQV. ANISOTROPIC_3D_MANTLE_VAL) then
      write(IMAIN,*) ANISOTROPIC_3D_MANTLE,ANISOTROPIC_3D_MANTLE_VAL
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver 15')
  endif
  if (ANISOTROPIC_INNER_CORE .NEQV. ANISOTROPIC_INNER_CORE_VAL) then
      write(IMAIN,*) ANISOTROPIC_INNER_CORE,ANISOTROPIC_INNER_CORE_VAL
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver 16')
  endif
! open file with global slice number addressing
  if(myrank == 0) then
    open(unit=IIN,file=trim(OUTPUT_FILES)//'/addressing.txt',status='old',action='read')
    do iproc = 0,NPROCTOT-1
      read(IIN,*) iproc_read,ichunk,iproc_xi,iproc_eta
      if(iproc_read /= iproc) call exit_MPI(myrank,'incorrect slice number read')
      addressing(ichunk,iproc_xi,iproc_eta) = iproc
      ichunk_slice(iproc) = ichunk
      iproc_xi_slice(iproc) = iproc_xi
      iproc_eta_slice(iproc) = iproc_eta
    enddo
    close(IIN)
  endif

! broadcast the information read on the master to the nodes
  call MPI_BCAST(addressing,NCHUNKS*NPROC_XI*NPROC_ETA,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
  call MPI_BCAST(ichunk_slice,NPROCTOT,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
  call MPI_BCAST(iproc_xi_slice,NPROCTOT,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
  call MPI_BCAST(iproc_eta_slice,NPROCTOT,MPI_INTEGER,0,MPI_COMM_WORLD,ier)

! output a topology map of slices - fix 20x by nproc
  if (myrank == 0 .and. NCHUNKS == 6) then
    write(IMAIN,*) 'Spatial distribution of the slices'
    do iproc_xi = NPROC_XI-1, 0, -1
      write(IMAIN,'(20x)',advance='no')
      do iproc_eta = NPROC_ETA -1, 0, -1
        ichunk = CHUNK_AB
        write(IMAIN,'(i5)',advance='no') addressing(ichunk,iproc_xi,iproc_eta)
      enddo
      write(IMAIN,'(1x)',advance='yes')
    enddo
    write(IMAIN, *) ' '
    do iproc_xi = NPROC_XI-1, 0, -1
      write(IMAIN,'(1x)',advance='no')
      do iproc_eta = NPROC_ETA -1, 0, -1
        ichunk = CHUNK_BC
        write(IMAIN,'(i5)',advance='no') addressing(ichunk,iproc_xi,iproc_eta)
      enddo
      write(IMAIN,'(3x)',advance='no')
      do iproc_eta = NPROC_ETA -1, 0, -1
        ichunk = CHUNK_AC
        write(IMAIN,'(i5)',advance='no') addressing(ichunk,iproc_xi,iproc_eta)
      enddo
      write(IMAIN,'(3x)',advance='no')
      do iproc_eta = NPROC_ETA -1, 0, -1
        ichunk = CHUNK_BC_ANTIPODE
        write(IMAIN,'(i5)',advance='no') addressing(ichunk,iproc_xi,iproc_eta)
      enddo
      write(IMAIN,'(1x)',advance='yes')
    enddo
    write(IMAIN, *) ' '
    do iproc_xi = NPROC_XI-1, 0, -1
      write(IMAIN,'(20x)',advance='no')
      do iproc_eta = NPROC_ETA -1, 0, -1
        ichunk = CHUNK_AB_ANTIPODE
        write(IMAIN,'(i5)',advance='no') addressing(ichunk,iproc_xi,iproc_eta)
      enddo
      write(IMAIN,'(1x)',advance='yes')
    enddo
    write(IMAIN, *) ' '
    do iproc_xi = NPROC_XI-1, 0, -1
      write(IMAIN,'(20x)',advance='no')
      do iproc_eta = NPROC_ETA -1, 0, -1
        ichunk = CHUNK_AC_ANTIPODE
        write(IMAIN,'(i5)',advance='no') addressing(ichunk,iproc_xi,iproc_eta)
      enddo
      write(IMAIN,'(1x)',advance='yes')
    enddo
    write(IMAIN, *) ' '
  endif

! determine chunk number and local slice coordinates using addressing
  ichunk = ichunk_slice(myrank)
  iproc_xi = iproc_xi_slice(myrank)
  iproc_eta = iproc_eta_slice(myrank)

! make ellipticity
  if(ELLIPTICITY_VAL) call make_ellipticity(nspl,rspl,espl,espl2,ONE_CRUST)

! define maximum size for message buffers
! use number of elements found in the mantle since it is the largest region
  NGLOB2DMAX_XY = max(NGLOB2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NGLOB2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE))

! number of corners and faces shared between chunks and number of message types
  if(NCHUNKS_VAL == 1 .or. NCHUNKS_VAL == 2) then
    NCORNERSCHUNKS = 1
    NUM_FACES = 1
    NUM_MSG_TYPES = 1
  else if(NCHUNKS_VAL == 3) then
    NCORNERSCHUNKS = 1
    NUM_FACES = 1
    NUM_MSG_TYPES = 3
  else if(NCHUNKS_VAL == 6) then
    NCORNERSCHUNKS = 8
    NUM_FACES = 4
    NUM_MSG_TYPES = 3
  else
    call exit_MPI(myrank,'number of chunks must be either 1, 2, 3 or 6')
  endif

! if more than one chunk then same number of processors in each direction
  NPROC_ONE_DIRECTION = NPROC_XI

! total number of messages corresponding to these common faces
  NUMMSGS_FACES = NPROC_ONE_DIRECTION*NUM_FACES*NUM_MSG_TYPES

! start reading the databases

! read arrays created by the mesher

! crust and mantle

  if(ANISOTROPIC_3D_MANTLE_VAL) then
    READ_KAPPA_MU = .false.
    READ_TISO = .false.
    nspec_iso = 1
    nspec_tiso = 1
    nspec_ani = NSPEC_CRUST_MANTLE
  else
    nspec_iso = NSPEC_CRUST_MANTLE
    if(TRANSVERSE_ISOTROPY_VAL) then
      nspec_tiso = NSPECMAX_TISO_MANTLE
    else
      nspec_tiso = 1
    endif
    nspec_ani = 1
    READ_KAPPA_MU = .true.
    READ_TISO = .true.
  endif
  call read_arrays_solver(IREGION_CRUST_MANTLE,myrank, &
            rho_vp_crust_mantle,rho_vs_crust_mantle, &
            xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
            xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle, &
            etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
            gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle, &
            rhostore_crust_mantle,kappavstore_crust_mantle,muvstore_crust_mantle, &
            kappahstore_crust_mantle,muhstore_crust_mantle,eta_anisostore_crust_mantle, &
            nspec_iso,nspec_tiso,nspec_ani, &
            c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle, &
            c14store_crust_mantle,c15store_crust_mantle,c16store_crust_mantle, &
            c22store_crust_mantle,c23store_crust_mantle,c24store_crust_mantle, &
            c25store_crust_mantle,c26store_crust_mantle,c33store_crust_mantle, &
            c34store_crust_mantle,c35store_crust_mantle,c36store_crust_mantle, &
            c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
            c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
            ibool_crust_mantle,idoubling_crust_mantle,rmass_crust_mantle,rmass_ocean_load, &
            NSPEC_CRUST_MANTLE,NGLOB_CRUST_MANTLE, &
            READ_KAPPA_MU,READ_TISO,TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE, &
            ANISOTROPIC_INNER_CORE,OCEANS,LOCAL_PATH,ABSORBING_CONDITIONS)

! outer core (no anisotropy nor S velocity)
! rmass_ocean_load is not used in this routine because it is meaningless in the outer core
  READ_KAPPA_MU = .false.
  READ_TISO = .false.
  nspec_iso = NSPEC_OUTER_CORE
  nspec_tiso = 1
  nspec_ani = 1

  call read_arrays_solver(IREGION_OUTER_CORE,myrank, &
            vp_outer_core,dummy_array, &
            xstore_outer_core,ystore_outer_core,zstore_outer_core, &
            xix_outer_core,xiy_outer_core,xiz_outer_core, &
            etax_outer_core,etay_outer_core,etaz_outer_core, &
            gammax_outer_core,gammay_outer_core,gammaz_outer_core, &
            rhostore_outer_core,kappavstore_outer_core,dummy_array, &
            dummy_array,dummy_array,dummy_array, &
            nspec_iso,nspec_tiso,nspec_ani, &
            dummy_array,dummy_array,dummy_array, &
            dummy_array,dummy_array,dummy_array, &
            dummy_array,dummy_array,dummy_array, &
            dummy_array,dummy_array,dummy_array, &
            dummy_array,dummy_array,dummy_array, &
            dummy_array,dummy_array,dummy_array, &
            dummy_array,dummy_array,dummy_array, &
            ibool_outer_core,idoubling_outer_core,rmass_outer_core,rmass_ocean_load, &
            NSPEC_OUTER_CORE,NGLOB_OUTER_CORE, &
            READ_KAPPA_MU,READ_TISO,TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE, &
            ANISOTROPIC_INNER_CORE,OCEANS,LOCAL_PATH,ABSORBING_CONDITIONS)

! inner core (no anisotropy)
! rmass_ocean_load is not used in this routine because it is meaningless in the inner core
  READ_KAPPA_MU = .true.
  READ_TISO = .false.
  nspec_iso = NSPEC_INNER_CORE
  nspec_tiso = 1
  if(ANISOTROPIC_INNER_CORE_VAL) then
    nspec_ani = NSPEC_INNER_CORE
  else
    nspec_ani = 1
  endif

  call read_arrays_solver(IREGION_INNER_CORE,myrank, &
            dummy_array,dummy_array, &
            xstore_inner_core,ystore_inner_core,zstore_inner_core, &
            xix_inner_core,xiy_inner_core,xiz_inner_core, &
            etax_inner_core,etay_inner_core,etaz_inner_core, &
            gammax_inner_core,gammay_inner_core,gammaz_inner_core, &
            rhostore_inner_core,kappavstore_inner_core,muvstore_inner_core, &
            dummy_array,dummy_array,dummy_array, &
            nspec_iso,nspec_tiso,nspec_ani, &
            c11store_inner_core,c12store_inner_core,c13store_inner_core, &
            dummy_array,dummy_array,dummy_array, &
            dummy_array,dummy_array,dummy_array, &
            dummy_array,dummy_array,c33store_inner_core, &
            dummy_array,dummy_array,dummy_array, &
            c44store_inner_core,dummy_array,dummy_array, &
            dummy_array,dummy_array,dummy_array, &
            ibool_inner_core,idoubling_inner_core,rmass_inner_core,rmass_ocean_load, &
            NSPEC_INNER_CORE,NGLOB_INNER_CORE, &
            READ_KAPPA_MU,READ_TISO,TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE, &
            ANISOTROPIC_INNER_CORE,OCEANS,LOCAL_PATH,ABSORBING_CONDITIONS)

! check that the number of points in this slice is correct

  if(minval(ibool_crust_mantle(:,:,:,:)) /= 1 .or. &
    maxval(ibool_crust_mantle(:,:,:,:)) /= NGLOB_CRUST_MANTLE) &
      call exit_MPI(myrank,'incorrect global numbering: iboolmax does not equal nglob in crust and mantle')

  if(minval(ibool_outer_core(:,:,:,:)) /= 1 .or. &
     maxval(ibool_outer_core(:,:,:,:)) /= NGLOB_OUTER_CORE) &
    call exit_MPI(myrank,'incorrect global numbering: iboolmax does not equal nglob in outer core')

  if(minval(ibool_inner_core(:,:,:,:)) /= 1 .or. maxval(ibool_inner_core(:,:,:,:)) /= NGLOB_INNER_CORE) &
    call exit_MPI(myrank,'incorrect global numbering: iboolmax does not equal nglob in inner core')

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

! set up GLL points, weights and derivation matrices
  call define_derivation_matrices(xigll,yigll,zigll,wxgll,wygll,wzgll, &
         hprime_xx,hprime_yy,hprime_zz, &
         hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
         wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube)

! read topography and bathymetry file
  if(myrank == 0 .and. (TOPOGRAPHY .or. OCEANS)) call read_topo_bathy_file(ibathy_topo)
! broadcast the information read on the master to the nodes
  call MPI_BCAST(ibathy_topo,NX_BATHY*NY_BATHY,MPI_INTEGER,0,MPI_COMM_WORLD,ier)

! allocate arrays for source
  allocate(islice_selected_source(NSOURCES))
  allocate(ispec_selected_source(NSOURCES))
  allocate(Mxx(NSOURCES))
  allocate(Myy(NSOURCES))
  allocate(Mzz(NSOURCES))
  allocate(Mxy(NSOURCES))
  allocate(Mxz(NSOURCES))
  allocate(Myz(NSOURCES))
  allocate(xi_source(NSOURCES))
  allocate(eta_source(NSOURCES))
  allocate(gamma_source(NSOURCES))
  allocate(t_cmt(NSOURCES))
  allocate(hdur(NSOURCES))
  allocate(hdur_gaussian(NSOURCES))
  allocate(theta_source(NSOURCES))
  allocate(phi_source(NSOURCES))
  allocate(nu_source(NDIM,NDIM,NSOURCES))

! BS BS moved open statement and writing of first lines into sr.vtk before the
! call to locate_sources, where further write statements to that file follow
  if(myrank == 0) then
! write source and receiver VTK files for Paraview
    open(IOVTK,file=trim(OUTPUT_FILES)//'/sr.vtk',status='unknown')
    write(IOVTK,'(a)') '# vtk DataFile Version 2.0'
    write(IOVTK,'(a)') 'Source and Receiver VTK file'
    write(IOVTK,'(a)') 'ASCII'
    write(IOVTK,'(a)') 'DATASET UNSTRUCTURED_GRID'
!  LQY -- won't be able to know NSOURCES+nrec at this point...
    write(IOVTK, '(a,i6,a)') 'POINTS ', 2, ' float'
  endif

! locate sources in the mesh
  call locate_sources(NSOURCES,myrank,NSPEC_CRUST_MANTLE,NGLOB_CRUST_MANTLE,ibool_crust_mantle, &
            xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
            xigll,yigll,zigll,NPROCTOT,ELLIPTICITY,TOPOGRAPHY, &
            sec,t_cmt,yr,jda,ho,mi,theta_source,phi_source, &
            NSTEP,DT,hdur,Mxx,Myy,Mzz,Mxy,Mxz,Myz, &
            islice_selected_source,ispec_selected_source, &
            xi_source,eta_source,gamma_source, nu_source,&
            rspl,espl,espl2,nspl,ibathy_topo,NEX_XI,PRINT_SOURCE_TIME_FUNCTION)

  if(minval(t_cmt) /= 0.) call exit_MPI(myrank,'one t_cmt must be zero, others must be positive')

! filter source time function by Gaussian with hdur = HDUR_MOVIE when outputing movies or shakemaps
  if (MOVIE_SURFACE .or. MOVIE_VOLUME ) then
     hdur = sqrt(hdur**2 + HDUR_MOVIE**2)
     if(myrank == 0) then
        write(IMAIN,*)
        write(IMAIN,*) 'Each source is being convolved with HDUR_MOVIE = ',HDUR_MOVIE
        write(IMAIN,*)
     endif
  endif
! convert the half duration for triangle STF to the one for gaussian STF
  hdur_gaussian = hdur/SOURCE_DECAY_MIMIC_TRIANGLE

! define t0 as the earliest start time
  t0 = - 1.5d0*minval(t_cmt-hdur)

! --------- receivers ---------------
  if (SIMULATION_TYPE == 1) then
    rec_filename = 'DATA/STATIONS'
  else
    rec_filename = 'DATA/STATIONS_ADJOINT'
  endif
  call get_value_string(STATIONS, 'solver.STATIONS', rec_filename)

  if(myrank == 0) then
    open(unit=IIN,file=STATIONS,status='old',action='read')
    read(IIN,*) nrec
    close(IIN)
  endif
! broadcast the information read on the master to the nodes
  call MPI_BCAST(nrec,1,MPI_INTEGER,0,MPI_COMM_WORLD,ier)

  if(myrank == 0) then
    write(IMAIN,*)
    if (SIMULATION_TYPE == 1 .or. SIMULATION_TYPE == 3) then
      write(IMAIN,*) 'Total number of receivers = ', nrec
    else
      write(IMAIN,*) 'Total number of adjoint sources = ', nrec
    endif
    write(IMAIN,*)
  endif

  if(nrec < 1) call exit_MPI(myrank,'need at least one receiver')

! allocate memory for receiver arrays
  allocate(islice_selected_rec(nrec))
  allocate(ispec_selected_rec(nrec))
  allocate(xi_receiver(nrec))
  allocate(eta_receiver(nrec))
  allocate(gamma_receiver(nrec))
  allocate(station_name(nrec))
  allocate(network_name(nrec))
  allocate(stlat(nrec))
  allocate(stlon(nrec))
  allocate(stele(nrec))
  allocate(nu(NDIM,NDIM,nrec))

! locate receivers in the crust in the mesh
  call locate_receivers(myrank,DT,NSTEP,NSPEC_CRUST_MANTLE,NGLOB_CRUST_MANTLE,ibool_crust_mantle, &
            xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
            xigll,yigll,zigll,trim(rec_filename), &
            nrec,islice_selected_rec,ispec_selected_rec, &
            xi_receiver,eta_receiver,gamma_receiver,station_name,network_name,stlat,stlon,stele,nu, &
            yr,jda,ho,mi,sec, &
            NPROCTOT,ELLIPTICITY,TOPOGRAPHY, &
            theta_source(1),phi_source(1),rspl,espl,espl2,nspl,ibathy_topo,RECEIVERS_CAN_BE_BURIED,NCHUNKS)

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

! read 2-D addressing for summation between slices with MPI

! mantle and crust
  call read_arrays_buffers_solver(IREGION_CRUST_MANTLE,myrank,iboolleft_xi_crust_mantle, &
     iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
     npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
     iprocfrom_faces,iprocto_faces,imsg_type, &
     iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
     iboolfaces_crust_mantle,npoin2D_faces_crust_mantle, &
     iboolcorner_crust_mantle, &
     NGLOB2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE), &
     NGLOB2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NGLOB2DMAX_XY,NGLOB1D_RADIAL(IREGION_CRUST_MANTLE), &
     NUMMSGS_FACES,NCORNERSCHUNKS,NPROCTOT,NPROC_XI,NPROC_ETA,LOCAL_PATH,NCHUNKS)

! outer core
  call read_arrays_buffers_solver(IREGION_OUTER_CORE,myrank, &
     iboolleft_xi_outer_core,iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core, &
     npoin2D_xi_outer_core,npoin2D_eta_outer_core, &
     iprocfrom_faces,iprocto_faces,imsg_type, &
     iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
     iboolfaces_outer_core,npoin2D_faces_outer_core, &
     iboolcorner_outer_core, &
     NGLOB2DMAX_XMIN_XMAX(IREGION_OUTER_CORE), &
     NGLOB2DMAX_YMIN_YMAX(IREGION_OUTER_CORE),NGLOB2DMAX_XY,NGLOB1D_RADIAL(IREGION_OUTER_CORE), &
     NUMMSGS_FACES,NCORNERSCHUNKS,NPROCTOT,NPROC_XI,NPROC_ETA,LOCAL_PATH,NCHUNKS)

! inner core
  call read_arrays_buffers_solver(IREGION_INNER_CORE,myrank, &
     iboolleft_xi_inner_core,iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core, &
     npoin2D_xi_inner_core,npoin2D_eta_inner_core, &
     iprocfrom_faces,iprocto_faces,imsg_type, &
     iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
     iboolfaces_inner_core,npoin2D_faces_inner_core, &
     iboolcorner_inner_core, &
     NGLOB2DMAX_XMIN_XMAX(IREGION_INNER_CORE), &
     NGLOB2DMAX_YMIN_YMAX(IREGION_INNER_CORE),NGLOB2DMAX_XY,NGLOB1D_RADIAL(IREGION_INNER_CORE), &
     NUMMSGS_FACES,NCORNERSCHUNKS,NPROCTOT,NPROC_XI,NPROC_ETA,LOCAL_PATH,NCHUNKS)

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

! to couple mantle with outer core

!
!---- crust and mantle
!

! create name of database
  call create_name_database(prname,myrank,IREGION_CRUST_MANTLE,LOCAL_PATH)

! Stacey put back
  open(unit=27,file=prname(1:len_trim(prname))//'boundary.bin',status='unknown',form='unformatted')
  read(27) nspec2D_xmin_crust_mantle
  read(27) nspec2D_xmax_crust_mantle
  read(27) nspec2D_ymin_crust_mantle
  read(27) nspec2D_ymax_crust_mantle
  read(27) njunk1
  read(27) njunk2

! boundary parameters
  read(27) ibelm_xmin_crust_mantle
  read(27) ibelm_xmax_crust_mantle
  read(27) ibelm_ymin_crust_mantle
  read(27) ibelm_ymax_crust_mantle
  read(27) ibelm_bottom_crust_mantle
  read(27) ibelm_top_crust_mantle

  read(27) normal_xmin_crust_mantle
  read(27) normal_xmax_crust_mantle
  read(27) normal_ymin_crust_mantle
  read(27) normal_ymax_crust_mantle
  read(27) normal_bottom_crust_mantle
  read(27) normal_top_crust_mantle

  read(27) jacobian2D_xmin_crust_mantle
  read(27) jacobian2D_xmax_crust_mantle
  read(27) jacobian2D_ymin_crust_mantle
  read(27) jacobian2D_ymax_crust_mantle
  read(27) jacobian2D_bottom_crust_mantle
  read(27) jacobian2D_top_crust_mantle
  close(27)

! read arrays for Stacey conditions

  if(ABSORBING_CONDITIONS) then
      open(unit=27,file=prname(1:len_trim(prname))//'stacey.bin',status='unknown',form='unformatted')
      read(27) nimin_crust_mantle
      read(27) nimax_crust_mantle
      read(27) njmin_crust_mantle
      read(27) njmax_crust_mantle
      read(27) nkmin_xi_crust_mantle
      read(27) nkmin_eta_crust_mantle
      close(27)

      if (nspec2D_xmin_crust_mantle > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_xmin_crust_mantle(NDIM,NGLLY,NGLLZ,nspec2D_xmin_crust_mantle))
        reclen_xmin_crust_mantle = CUSTOM_REAL * (NDIM * NGLLY * NGLLZ * nspec2D_xmin_crust_mantle)
        if (SIMULATION_TYPE == 3) then
          open(unit=51,file=trim(prname)//'absorb_xmin.bin',status='old',action='read',form='unformatted',access='direct', &
                recl=reclen_xmin_crust_mantle+2*4)
        else
          open(unit=51,file=trim(prname)//'absorb_xmin.bin',status='unknown',form='unformatted',access='direct',&
                recl=reclen_xmin_crust_mantle+2*4)
        endif
      endif

      if (nspec2D_xmax_crust_mantle > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_xmax_crust_mantle(NDIM,NGLLY,NGLLZ,nspec2D_xmax_crust_mantle))
        reclen_xmax_crust_mantle = CUSTOM_REAL * (NDIM * NGLLY * NGLLZ * nspec2D_xmax_crust_mantle)
        if (SIMULATION_TYPE == 3) then
          open(unit=52,file=trim(prname)//'absorb_xmax.bin',status='old',action='read',form='unformatted',access='direct', &
                recl=reclen_xmax_crust_mantle+2*4)
        else
          open(unit=52,file=trim(prname)//'absorb_xmax.bin',status='unknown',form='unformatted',access='direct', &
                recl=reclen_xmax_crust_mantle+2*4)
        endif
      endif

      if (nspec2D_ymin_crust_mantle > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_ymin_crust_mantle(NDIM,NGLLX,NGLLZ,nspec2D_ymin_crust_mantle))
        reclen_ymin_crust_mantle = CUSTOM_REAL * (NDIM * NGLLX * NGLLZ * nspec2D_ymin_crust_mantle)
        if (SIMULATION_TYPE == 3) then
          open(unit=53,file=trim(prname)//'absorb_ymin.bin',status='old',action='read',form='unformatted',access='direct',&
                recl=reclen_ymin_crust_mantle+2*4)
        else
          open(unit=53,file=trim(prname)//'absorb_ymin.bin',status='unknown',form='unformatted',access='direct',&
                recl=reclen_ymin_crust_mantle+2*4)
        endif
      endif

      if (nspec2D_ymax_crust_mantle > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_ymax_crust_mantle(NDIM,NGLLX,NGLLZ,nspec2D_ymax_crust_mantle))
        reclen_ymax_crust_mantle = CUSTOM_REAL * (NDIM * NGLLX * NGLLZ * nspec2D_ymax_crust_mantle)
        if (SIMULATION_TYPE == 3) then
          open(unit=54,file=trim(prname)//'absorb_ymax.bin',status='old',action='read',form='unformatted',access='direct',&
                recl=reclen_ymax_crust_mantle+2*4)
        else
          open(unit=54,file=trim(prname)//'absorb_ymax.bin',status='unknown',form='unformatted',access='direct',&
                recl=reclen_ymax_crust_mantle+2*4)
        endif
      endif

  endif

! -- Boundary Mesh for crust and mantle ---

  if (SAVE_BOUNDARY_MESH .and. SIMULATION_TYPE == 3) then
    open(unit=27,file=prname(1:len_trim(prname))//'boundary_disc.bin',status='old',form='unformatted')
    read(27) njunk1,njunk2,njunk3
    if (njunk1 /= NSPEC2D_MOHO .and. njunk2 /= NSPEC2D_400 .and. njunk3 /= NSPEC2D_670) &
               call exit_mpi(myrank, 'Error reading ibelm_disc.bin file')
    read(27) ibelm_moho_top
    read(27) ibelm_moho_bot
    read(27) ibelm_400_top
    read(27) ibelm_400_bot
    read(27) ibelm_670_top
    read(27) ibelm_670_bot
    read(27) normal_moho
    read(27) normal_400
    read(27) normal_670
    close(27)

    k_top = 1
    k_bot = NGLLZ

    ! initialization
    moho_kl = 0.; d400_kl = 0.; d670_kl = 0.; cmb_kl = 0.; icb_kl = 0.

  endif

! read parameters to couple fluid and solid regions
!
!---- outer core
!

! create name of database
  call create_name_database(prname,myrank,IREGION_OUTER_CORE,LOCAL_PATH)

! boundary parameters

! Stacey put back
  open(unit=27,file=prname(1:len_trim(prname))//'boundary.bin',status='unknown',form='unformatted')
  read(27) nspec2D_xmin_outer_core
  read(27) nspec2D_xmax_outer_core
  read(27) nspec2D_ymin_outer_core
  read(27) nspec2D_ymax_outer_core
  read(27) njunk1
  read(27) njunk2

  read(27) ibelm_xmin_outer_core
  read(27) ibelm_xmax_outer_core
  read(27) ibelm_ymin_outer_core
  read(27) ibelm_ymax_outer_core
  read(27) ibelm_bottom_outer_core
  read(27) ibelm_top_outer_core

  read(27) normal_xmin_outer_core
  read(27) normal_xmax_outer_core
  read(27) normal_ymin_outer_core
  read(27) normal_ymax_outer_core
  read(27) normal_bottom_outer_core
  read(27) normal_top_outer_core

  read(27) jacobian2D_xmin_outer_core
  read(27) jacobian2D_xmax_outer_core
  read(27) jacobian2D_ymin_outer_core
  read(27) jacobian2D_ymax_outer_core
  read(27) jacobian2D_bottom_outer_core
  read(27) jacobian2D_top_outer_core
  close(27)

! read arrays for Stacey conditions

  if(ABSORBING_CONDITIONS) then
      open(unit=27,file=prname(1:len_trim(prname))//'stacey.bin',status='unknown',form='unformatted')
      read(27) nimin_outer_core
      read(27) nimax_outer_core
      read(27) njmin_outer_core
      read(27) njmax_outer_core
      read(27) nkmin_xi_outer_core
      read(27) nkmin_eta_outer_core
      close(27)

      if (nspec2D_xmin_outer_core > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_xmin_outer_core(NGLLY,NGLLZ,nspec2D_xmin_outer_core))
        reclen_xmin_outer_core = CUSTOM_REAL * (NGLLY * NGLLZ * nspec2D_xmin_outer_core)
        if (SIMULATION_TYPE == 3) then
          open(unit=61,file=trim(prname)//'absorb_xmin.bin',status='old',action='read',form='unformatted',access='direct', &
                recl=reclen_xmin_outer_core+2*4)
        else
          open(unit=61,file=trim(prname)//'absorb_xmin.bin',status='unknown',form='unformatted',access='direct',&
                recl=reclen_xmin_outer_core+2*4)
        endif
      endif

      if (nspec2D_xmax_outer_core > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_xmax_outer_core(NGLLY,NGLLZ,nspec2D_xmax_outer_core))
        reclen_xmax_outer_core = CUSTOM_REAL * (NGLLY * NGLLZ * nspec2D_xmax_outer_core)
        if (SIMULATION_TYPE == 3) then
          open(unit=62,file=trim(prname)//'absorb_xmax.bin',status='old',action='read',form='unformatted',access='direct', &
                recl=reclen_xmax_outer_core+2*4)
        else
          open(unit=62,file=trim(prname)//'absorb_xmax.bin',status='unknown',form='unformatted',access='direct', &
                recl=reclen_xmax_outer_core+2*4)
        endif
      endif

      if (nspec2D_ymin_outer_core > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_ymin_outer_core(NGLLX,NGLLZ,nspec2D_ymin_outer_core))
        reclen_ymin_outer_core = CUSTOM_REAL * (NGLLX * NGLLZ * nspec2D_ymin_outer_core)
        if (SIMULATION_TYPE == 3) then
          open(unit=63,file=trim(prname)//'absorb_ymin.bin',status='old',action='read',form='unformatted',access='direct',&
                recl=reclen_ymin_outer_core+2*4)
        else
          open(unit=63,file=trim(prname)//'absorb_ymin.bin',status='unknown',form='unformatted',access='direct',&
                recl=reclen_ymin_outer_core+2*4)
        endif
      endif

      if (nspec2D_ymax_outer_core > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_ymax_outer_core(NGLLX,NGLLZ,nspec2D_ymax_outer_core))
        reclen_ymax_outer_core = CUSTOM_REAL * (NGLLX * NGLLZ * nspec2D_ymax_outer_core)
        if (SIMULATION_TYPE == 3) then
          open(unit=64,file=trim(prname)//'absorb_ymax.bin',status='old',action='read',form='unformatted',access='direct',&
                recl=reclen_ymax_outer_core+2*4)
        else
          open(unit=64,file=trim(prname)//'absorb_ymax.bin',status='unknown',form='unformatted',access='direct',&
                recl=reclen_ymax_outer_core+2*4)
        endif
      endif

      if (NSPEC2D_BOTTOM(IREGION_OUTER_CORE) > 0 .and. &
         (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD)))then
        allocate(absorb_zmin_outer_core(NGLLX,NGLLY,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)))
        reclen_zmin = CUSTOM_REAL * (NGLLX * NGLLY * NSPEC2D_BOTTOM(IREGION_OUTER_CORE))
         if (SIMULATION_TYPE == 3) then
         open(unit=65,file=trim(prname)//'absorb_zmin.bin',status='old',action='read',form='unformatted',access='direct',&
                recl=reclen_zmin+2*4)
        else
          open(unit=65,file=trim(prname)//'absorb_zmin.bin',status='unknown',form='unformatted',access='direct',&
                recl=reclen_zmin+2*4)
        endif
      endif
  endif

!
!---- inner core
!

! create name of database
  call create_name_database(prname,myrank,IREGION_INNER_CORE,LOCAL_PATH)

! read info for vertical edges for central cube matching in inner core
  open(unit=27,file=prname(1:len_trim(prname))//'boundary.bin',status='old',action='read',form='unformatted')
  read(27) nspec2D_xmin_inner_core
  read(27) nspec2D_xmax_inner_core
  read(27) nspec2D_ymin_inner_core
  read(27) nspec2D_ymax_inner_core
  read(27) njunk1
  read(27) njunk2

! boundary parameters
  read(27) ibelm_xmin_inner_core
  read(27) ibelm_xmax_inner_core
  read(27) ibelm_ymin_inner_core
  read(27) ibelm_ymax_inner_core
  read(27) ibelm_bottom_inner_core
  read(27) ibelm_top_inner_core
  close(27)

!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
! ---- source array

  if (SIMULATION_TYPE == 1  .or. SIMULATION_TYPE == 3) then

  allocate(sourcearrays(NSOURCES,NDIM,NGLLX,NGLLY,NGLLZ))
  do isource = 1,NSOURCES

!   check that the source slice number is okay
    if(islice_selected_source(isource) < 0 .or. islice_selected_source(isource) > NPROCTOT-1) &
      call exit_MPI(myrank,'something is wrong with the source slice number')

!   compute source arrays in source slice
    if(myrank == islice_selected_source(isource)) then
      call compute_arrays_source(ispec_selected_source(isource), &
             xi_source(isource),eta_source(isource),gamma_source(isource),sourcearray, &
             Mxx(isource),Myy(isource),Mzz(isource),Mxy(isource),Mxz(isource),Myz(isource), &
             xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle, &
             etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
             gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle, &
             xigll,yigll,zigll,NSPEC_CRUST_MANTLE)
      sourcearrays(isource,:,:,:,:) = sourcearray(:,:,:,:)
    endif
  enddo
  endif

  if (SIMULATION_TYPE == 2 .or. SIMULATION_TYPE == 3) then
    nadj_rec_local = 0
    do irec = 1,nrec
      if(myrank == islice_selected_rec(irec))then
        if(islice_selected_rec(irec) < 0 .or. islice_selected_rec(irec) > NPROCTOT-1) &
          call exit_MPI(myrank,'something is wrong with the source slice number in adjoint simulation')
        nadj_rec_local = nadj_rec_local + 1
      endif
    enddo

    NSTEP_SUB_ADJ = ceiling( dble(NSTEP)/dble(NTSTEP_BETWEEN_READ_ADJSRC) )
    allocate(iadj_vec(NSTEP))
    iadj_block = 1  !counts blocks
    do it=1,NSTEP
       iadj_vec(it) = NSTEP-it+1  ! default is for reversing entire record
    enddo

    if(nadj_rec_local > 0) then
     ! allocate adjoint source arrays
     allocate(adj_sourcearray(NTSTEP_BETWEEN_READ_ADJSRC,NDIM,NGLLX,NGLLY,NGLLZ))
     allocate(adj_sourcearrays(nadj_rec_local,NTSTEP_BETWEEN_READ_ADJSRC,NDIM,NGLLX,NGLLY,NGLLZ))

     ! allocate and initialize indexing arrays
     allocate(iadjsrc(NSTEP_SUB_ADJ,2))
     allocate(iadjsrc_len(NSTEP_SUB_ADJ))
     iadjsrc(:,:) = 0
     iadjsrc_len(:) = 0

     do it=1,NSTEP

       it_sub_adj = ceiling( dble(it)/dble(NTSTEP_BETWEEN_READ_ADJSRC) ) !block number

       if(mod(it-1,NTSTEP_BETWEEN_READ_ADJSRC) == 0) then !we are at the edge of a block
         iadjsrc(iadj_block,1) = NSTEP-it_sub_adj*NTSTEP_BETWEEN_READ_ADJSRC+1
         iadjsrc(iadj_block,2) = NSTEP-(it_sub_adj-1)*NTSTEP_BETWEEN_READ_ADJSRC
         if(iadjsrc(iadj_block,1) < 0) iadjsrc(iadj_block,1) = 1         ! final adj src array
         iadjsrc_len(iadj_block) = iadjsrc(iadj_block,2)-iadjsrc(iadj_block,1)+1
         iadj_block = iadj_block+1
       endif

       iadj_vec(it) = iadjsrc_len(it_sub_adj) - mod(it-1,NTSTEP_BETWEEN_READ_ADJSRC)
     enddo

    endif

  endif

!--- select local receivers

! count number of receivers located in this slice
  nrec_local = 0
  if (SIMULATION_TYPE == 1 .or. SIMULATION_TYPE == 3) then
    nrec_simulation = nrec
    do irec = 1,nrec
      if(myrank == islice_selected_rec(irec)) nrec_local = nrec_local + 1
    enddo
  else
    nrec_simulation = NSOURCES
    do isource = 1, NSOURCES
      if(myrank == islice_selected_source(isource)) nrec_local = nrec_local + 1
    enddo
  endif

  if (nrec_local > 0) then

! allocate Lagrange interpolators for receivers
  allocate(hxir_store(nrec_local,NGLLX))
  allocate(hetar_store(nrec_local,NGLLY))
  allocate(hgammar_store(nrec_local,NGLLZ))

! define local to global receiver numbering mapping
  allocate(number_receiver_global(nrec_local))
  irec_local = 0
  if (SIMULATION_TYPE == 1 .or. SIMULATION_TYPE == 3) then
    do irec = 1,nrec
      if(myrank == islice_selected_rec(irec)) then
        irec_local = irec_local + 1
        number_receiver_global(irec_local) = irec
      endif
    enddo
  else
    do isource = 1,NSOURCES
      if(myrank == islice_selected_source(isource)) then
        irec_local = irec_local + 1
        number_receiver_global(irec_local) = isource
      endif
    enddo
  endif

! define and store Lagrange interpolators at all the receivers
  if (SIMULATION_TYPE == 1 .or. SIMULATION_TYPE == 3) then
  do irec_local = 1,nrec_local
    irec = number_receiver_global(irec_local)
    call lagrange_any(xi_receiver(irec),NGLLX,xigll,hxir,hpxir)
    call lagrange_any(eta_receiver(irec),NGLLY,yigll,hetar,hpetar)
    call lagrange_any(gamma_receiver(irec),NGLLZ,zigll,hgammar,hpgammar)
    hxir_store(irec_local,:) = hxir(:)
    hetar_store(irec_local,:) = hetar(:)
    hgammar_store(irec_local,:) = hgammar(:)
  enddo
  else
  do irec_local = 1,nrec_local
    irec = number_receiver_global(irec_local)
    call lagrange_any(xi_source(irec),NGLLX,xigll,hxir,hpxir)
    call lagrange_any(eta_source(irec),NGLLY,yigll,hetar,hpetar)
    call lagrange_any(gamma_source(irec),NGLLZ,zigll,hgammar,hpgammar)
    hxir_store(irec_local,:) = hxir(:)
    hetar_store(irec_local,:) = hetar(:)
    hgammar_store(irec_local,:) = hgammar(:)
  enddo
  endif

  endif ! nrec_local

! check that the sum of the number of receivers in each slice is nrec
  call MPI_REDUCE(nrec_local,nrec_tot_found,1,MPI_INTEGER,MPI_SUM,0, &
                          MPI_COMM_WORLD,ier)
  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'found a total of ',nrec_tot_found,' receivers in all the slices'
    if(nrec_tot_found /= nrec_simulation) then
      call exit_MPI(myrank,'problem when dispatching the receivers')
    else
      write(IMAIN,*) 'this total is okay'
    endif
  endif

  if(myrank == 0) then

  close(IOVTK)

  write(IMAIN,*)
  write(IMAIN,*) 'Total number of samples for seismograms = ',NSTEP
  write(IMAIN,*)

  write(IMAIN,*)
  write(IMAIN,*) 'Reference radius of the Earth used is ',R_EARTH_KM,' km'
  write(IMAIN,*)

  if(NSOURCES > 1) write(IMAIN,*) 'Using ',NSOURCES,' point sources'

  write(IMAIN,*)
  if(ELLIPTICITY_VAL) then
    write(IMAIN,*) 'incorporating ellipticity'
  else
    write(IMAIN,*) 'no ellipticity'
  endif

  write(IMAIN,*)
  if(TOPOGRAPHY) then
    write(IMAIN,*) 'incorporating surface topography'
  else
    write(IMAIN,*) 'no surface topography'
  endif

  write(IMAIN,*)
  if(ISOTROPIC_3D_MANTLE) then
    write(IMAIN,*) 'incorporating 3-D lateral variations'
  else
    write(IMAIN,*) 'no 3-D lateral variations'
  endif

  write(IMAIN,*)
  if(CRUSTAL) then
    write(IMAIN,*) 'incorporating crustal variations'
  else
    write(IMAIN,*) 'no crustal variations'
  endif

  write(IMAIN,*)
  if(ONE_CRUST) then
    write(IMAIN,*) 'using one layer only in PREM crust'
  else
    write(IMAIN,*) 'using unmodified 1D crustal model with two layers'
  endif

  write(IMAIN,*)
  if(GRAVITY_VAL) then
    write(IMAIN,*) 'incorporating self-gravitation (Cowling approximation)'
  else
    write(IMAIN,*) 'no self-gravitation'
  endif

  write(IMAIN,*)
  if(ROTATION_VAL) then
    write(IMAIN,*) 'incorporating rotation'
  else
    write(IMAIN,*) 'no rotation'
  endif

  write(IMAIN,*)
  if(TRANSVERSE_ISOTROPY_VAL) then
    write(IMAIN,*) 'incorporating transverse isotropy'
  else
    write(IMAIN,*) 'no transverse isotropy'
  endif

  write(IMAIN,*)
  if(ATTENUATION_VAL) then
    write(IMAIN,*) 'incorporating attenuation using ',N_SLS,' standard linear solids'
    if(ATTENUATION_3D_VAL) write(IMAIN,*) 'using 3D attenuation'
  else
    write(IMAIN,*) 'no attenuation'
  endif

  write(IMAIN,*)
  if(OCEANS) then
    write(IMAIN,*) 'incorporating the oceans using equivalent load'
  else
    write(IMAIN,*) 'no oceans'
  endif

  write(IMAIN,*)
  if(ANISOTROPIC_INNER_CORE_VAL) then
    write(IMAIN,*) 'incorporating anisotropic inner core'
  else
    write(IMAIN,*) 'no inner-core anisotropy'
  endif

  write(IMAIN,*)
  if(ANISOTROPIC_3D_MANTLE_VAL) then
    write(IMAIN,*) 'incorporating anisotropic mantle'
  else
    write(IMAIN,*) 'no general mantle anisotropy'
  endif
  write(IMAIN,*)
  write(IMAIN,*)
  write(IMAIN,*)

  endif

! synchronize all the processes before assembling the mass matrix
! to make sure all the nodes have finished to read their databases
  call MPI_BARRIER(MPI_COMM_WORLD,ier)
    if(myrank==0) write(IMAIN,*) 'barrier done'

! the mass matrix needs to be assembled with MPI here once and for all

! ocean load
  if (OCEANS) then
    call assemble_MPI_scalar(myrank,rmass_ocean_load,NGLOB_CRUST_MANTLE, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_crust_mantle,iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
            npoin2D_faces_crust_mantle,npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
            iboolfaces_crust_mantle,iboolcorner_crust_mantle, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NGLOB1D_RADIAL(IREGION_CRUST_MANTLE), &
            NGLOB2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NGLOB2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NGLOB2DMAX_XY,NCHUNKS)
  endif

! crust and mantle
  call assemble_MPI_scalar(myrank,rmass_crust_mantle,NGLOB_CRUST_MANTLE, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_crust_mantle,iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
            npoin2D_faces_crust_mantle,npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
            iboolfaces_crust_mantle,iboolcorner_crust_mantle, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NGLOB1D_RADIAL(IREGION_CRUST_MANTLE), &
            NGLOB2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NGLOB2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NGLOB2DMAX_XY,NCHUNKS)
  if(myrank==0) write(IMAIN,*) 'assemble MPI scalar CM done'
! outer core
  call assemble_MPI_scalar(myrank,rmass_outer_core,NGLOB_OUTER_CORE, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_outer_core,iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core, &
            npoin2D_faces_outer_core,npoin2D_xi_outer_core,npoin2D_eta_outer_core, &
            iboolfaces_outer_core,iboolcorner_outer_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NGLOB1D_RADIAL(IREGION_OUTER_CORE), &
            NGLOB2DMAX_XMIN_XMAX(IREGION_OUTER_CORE),NGLOB2DMAX_YMIN_YMAX(IREGION_OUTER_CORE),NGLOB2DMAX_XY,NCHUNKS)
  if(myrank==0) write(IMAIN,*) 'assemble MPI scalar OC done'
! inner core
  call assemble_MPI_scalar(myrank,rmass_inner_core,NGLOB_INNER_CORE, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_inner_core,iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core, &
            npoin2D_faces_inner_core,npoin2D_xi_inner_core,npoin2D_eta_inner_core, &
            iboolfaces_inner_core,iboolcorner_inner_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NGLOB1D_RADIAL(IREGION_INNER_CORE), &
            NGLOB2DMAX_XMIN_XMAX(IREGION_INNER_CORE),NGLOB2DMAX_YMIN_YMAX(IREGION_INNER_CORE),NGLOB2DMAX_XY,NCHUNKS)

  if(myrank == 0) write(IMAIN,*) 'end assembling MPI mass matrix'

!
!--- handle the communications with the central cube if it was included in the mesh
!
  if(INCLUDE_CENTRAL_CUBE) then

    if(myrank == 0) write(IMAIN,*) 'including central cube'

! compute number of messages to expect in cube as well as their size
    call comp_central_cube_buffer_size(iproc_xi,iproc_eta,ichunk,NPROC_XI,NPROC_ETA,NSPEC2D_BOTTOM(IREGION_INNER_CORE), &
                nb_msgs_theor_in_cube,npoin2D_cube_from_slices)

! this value is used for dynamic memory allocation, therefore make sure it is never zero
    if(nb_msgs_theor_in_cube > 0) then
      non_zero_nb_msgs_theor_in_cube = nb_msgs_theor_in_cube
    else
      non_zero_nb_msgs_theor_in_cube = 1
    endif

! allocate buffers for cube and slices
    allocate(sender_from_slices_to_cube(non_zero_nb_msgs_theor_in_cube))
    allocate(buffer_all_cube_from_slices(non_zero_nb_msgs_theor_in_cube,npoin2D_cube_from_slices,NDIM))
    allocate(buffer_slices(npoin2D_cube_from_slices,NDIM))
    allocate(ibool_central_cube(non_zero_nb_msgs_theor_in_cube,npoin2D_cube_from_slices))

! create buffers to assemble with the central cube
    call create_central_cube_buffers(myrank,iproc_xi,iproc_eta,ichunk, &
       NPROC_XI,NPROC_ETA,NCHUNKS,NSPEC_INNER_CORE,NGLOB_INNER_CORE, &
       NSPEC2DMAX_XMIN_XMAX(IREGION_INNER_CORE),NSPEC2DMAX_YMIN_YMAX(IREGION_INNER_CORE), &
       NSPEC2D_BOTTOM(IREGION_INNER_CORE), &
       addressing,ibool_inner_core,idoubling_inner_core, &
       xstore_inner_core,ystore_inner_core,zstore_inner_core, &
       nspec2D_xmin_inner_core,nspec2D_xmax_inner_core,nspec2D_ymin_inner_core,nspec2D_ymax_inner_core, &
       ibelm_xmin_inner_core,ibelm_xmax_inner_core,ibelm_ymin_inner_core,ibelm_ymax_inner_core,ibelm_bottom_inner_core, &
       nb_msgs_theor_in_cube,non_zero_nb_msgs_theor_in_cube,npoin2D_cube_from_slices, &
       receiver_cube_from_slices,sender_from_slices_to_cube,ibool_central_cube,buffer_slices,buffer_all_cube_from_slices)

    if(myrank == 0) write(IMAIN,*) 'done including central cube'

! the mass matrix to assemble is a scalar, not a vector
    ndim_assemble = 1

! use these buffers to assemble the inner core mass matrix with the central cube
    call assemble_MPI_central_cube(ichunk,nb_msgs_theor_in_cube, sender_from_slices_to_cube, &
     npoin2D_cube_from_slices, buffer_all_cube_from_slices, buffer_slices, ibool_central_cube, &
     receiver_cube_from_slices, ibool_inner_core, idoubling_inner_core, NSPEC_INNER_CORE, &
     ibelm_bottom_inner_core, NSPEC2D_BOTTOM(IREGION_INNER_CORE),NGLOB_INNER_CORE,rmass_inner_core,ndim_assemble)

! suppress fictitious mass matrix elements in central cube
! because the slices do not compute all their spectral elements in the cube
    where(rmass_inner_core(:) <= 0.) rmass_inner_core = 1.

  endif   ! end of handling the communications with the central cube

! check that all the mass matrices are positive
  if(minval(rmass_crust_mantle) <= 0. .or. minval(rmass_inner_core) <= 0. .or. minval(rmass_outer_core) <= 0.) &
       call exit_MPI(myrank,'negative mass matrix term for at least one region')

  if(OCEANS) then
    if(minval(rmass_ocean_load) <= 0.) call exit_MPI(myrank,'negative mass matrix term for the oceans')
  endif

! for efficiency, invert final mass matrix once and for all on each slice
  if(OCEANS) rmass_ocean_load = 1._CUSTOM_REAL / rmass_ocean_load
  rmass_crust_mantle = 1._CUSTOM_REAL / rmass_crust_mantle
  rmass_outer_core = 1._CUSTOM_REAL / rmass_outer_core
  rmass_inner_core = 1._CUSTOM_REAL / rmass_inner_core

! change x, y, z to r, theta and phi once and for all
! IMPROVE dangerous: old name kept (xstore ystore zstore) for new values

! convert in the crust and mantle
    do iglob = 1,NGLOB_CRUST_MANTLE
      call xyz_2_rthetaphi(xstore_crust_mantle(iglob), &
    ystore_crust_mantle(iglob),zstore_crust_mantle(iglob),rval,thetaval,phival)
      xstore_crust_mantle(iglob) = rval
      ystore_crust_mantle(iglob) = thetaval
      zstore_crust_mantle(iglob) = phival
    enddo

! convert in the outer core
    do iglob = 1,NGLOB_OUTER_CORE
      call xyz_2_rthetaphi(xstore_outer_core(iglob), &
    ystore_outer_core(iglob),zstore_outer_core(iglob),rval,thetaval,phival)
      xstore_outer_core(iglob) = rval
      ystore_outer_core(iglob) = thetaval
      zstore_outer_core(iglob) = phival
    enddo

! convert in the inner core
    do iglob = 1,NGLOB_INNER_CORE
      call xyz_2_rthetaphi(xstore_inner_core(iglob), &
    ystore_inner_core(iglob),zstore_inner_core(iglob),rval,thetaval,phival)
      xstore_inner_core(iglob) = rval
      ystore_inner_core(iglob) = thetaval
      zstore_inner_core(iglob) = phival
    enddo

  if(ATTENUATION_VAL) then

! get and store PREM attenuation model

! ATTENUATION_3D get values from mesher
     if(ATTENUATION_3D_VAL) then
        ! CRUST_MANTLE ATTENUATION
        call create_name_database(prname, myrank, IREGION_CRUST_MANTLE, LOCAL_PATH)
        call get_attenuation_model_3D(myrank, prname, omsb_crust_mantle_dble, &
             factor_common_crust_mantle_dble, factor_scale_crust_mantle_dble, tau_sigma_dble, NSPEC_CRUST_MANTLE)
        ! INNER_CORE ATTENUATION
        call create_name_database(prname, myrank, IREGION_INNER_CORE, LOCAL_PATH)
        call get_attenuation_model_3D(myrank, prname, omsb_inner_core_dble, &
             factor_common_inner_core_dble, factor_scale_inner_core_dble, tau_sigma_dble, NSPEC_INNER_CORE)
     else ! ATTENUATION = .true. .AND. ATTENUATION_3D = .false.
        call create_name_database(prname, myrank, IREGION_CRUST_MANTLE, LOCAL_PATH)
        call get_attenuation_model_1D(myrank, prname, IREGION_CRUST_MANTLE, tau_sigma_dble, &
             omsb_crust_mantle_dble, factor_common_crust_mantle_dble,  &
             factor_scale_crust_mantle_dble, NRAD_ATTENUATION,1,1,1, AM_V)
        omsb_inner_core_dble(:,:,:,1:min(ATT4,ATT5)) = omsb_crust_mantle_dble(:,:,:,1:min(ATT4,ATT5))
        factor_scale_inner_core_dble(:,:,:,1:min(ATT4,ATT5))    = factor_scale_crust_mantle_dble(:,:,:,1:min(ATT4,ATT5))
        factor_common_inner_core_dble(:,:,:,:,1:min(ATT4,ATT5)) = factor_common_crust_mantle_dble(:,:,:,:,1:min(ATT4,ATT5))
        ! Tell the Attenuation Code about the IDOUBLING regions within the Mesh
        call set_attenuation_regions_1D(RICB, RCMB, R670, R220, R80, AM_V)
     endif ! ATTENUATION_3D

   if(CUSTOM_REAL == SIZE_REAL) then
      factor_scale_crust_mantle       = sngl(factor_scale_crust_mantle_dble)
      one_minus_sum_beta_crust_mantle = sngl(omsb_crust_mantle_dble)
      factor_common_crust_mantle      = sngl(factor_common_crust_mantle_dble)

      factor_scale_inner_core         = sngl(factor_scale_inner_core_dble)
      one_minus_sum_beta_inner_core   = sngl(omsb_inner_core_dble)
      factor_common_inner_core        = sngl(factor_common_inner_core_dble)
   else
      factor_scale_crust_mantle       = factor_scale_crust_mantle_dble
      one_minus_sum_beta_crust_mantle = omsb_crust_mantle_dble
      factor_common_crust_mantle      = factor_common_crust_mantle_dble

      factor_scale_inner_core         = factor_scale_inner_core_dble
      one_minus_sum_beta_inner_core   = omsb_inner_core_dble
      factor_common_inner_core        = factor_common_inner_core_dble
   endif

! if attenuation is on, shift PREM to right frequency
! rescale mu in PREM to average frequency for attenuation
! the formulas to implement the scaling can be found for instance in
! Liu, H. P., Anderson, D. L. and Kanamori, H., Velocity dispersion due to
! anelasticity: implications for seismology and mantle composition,
! Geophys. J. R. Astron. Soc., vol. 47, pp. 41-58 (1976)
! and in Aki, K. and Richards, P. G., Quantitative seismology, theory and methods,
! W. H. Freeman, (1980), second edition, sections 5.5 and 5.5.2, eq. (5.81) p. 170

! rescale in crust and mantle

    do ispec = 1,NSPEC_CRUST_MANTLE
      do k=1,NGLLZ
        do j=1,NGLLY
          do i=1,NGLLX

! ATTENUATION_3D get scale_factor
            if(ATTENUATION_3D_VAL) then
              ! tau_mu and tau_sigma need to reference a point in the mesh
              scale_factor = factor_scale_crust_mantle(i,j,k,ispec)
            else
              iglob   = ibool_crust_mantle(i,j,k,ispec)
              dist_cr = xstore_crust_mantle(iglob)
              call get_attenuation_index(idoubling_crust_mantle(ispec), dble(dist_cr), iregion_selected, .FALSE., AM_V)
              scale_factor = factor_scale_crust_mantle(1,1,1,iregion_selected)
            endif ! ATTENUATION_3D

    if(ANISOTROPIC_3D_MANTLE_VAL) then
      scale_factor_minus_one = scale_factor - 1.
      mul = c44store_crust_mantle(i,j,k,ispec)
      c11store_crust_mantle(i,j,k,ispec) = c11store_crust_mantle(i,j,k,ispec) &
              + FOUR_THIRDS * scale_factor_minus_one * mul
      c12store_crust_mantle(i,j,k,ispec) = c12store_crust_mantle(i,j,k,ispec) &
              - TWO_THIRDS * scale_factor_minus_one * mul
      c13store_crust_mantle(i,j,k,ispec) = c13store_crust_mantle(i,j,k,ispec) &
              - TWO_THIRDS * scale_factor_minus_one * mul
      c22store_crust_mantle(i,j,k,ispec) = c22store_crust_mantle(i,j,k,ispec) &
              + FOUR_THIRDS * scale_factor_minus_one * mul
      c23store_crust_mantle(i,j,k,ispec) = c23store_crust_mantle(i,j,k,ispec) &
              - TWO_THIRDS * scale_factor_minus_one * mul
      c33store_crust_mantle(i,j,k,ispec) = c33store_crust_mantle(i,j,k,ispec) &
              + FOUR_THIRDS * scale_factor_minus_one * mul
      c44store_crust_mantle(i,j,k,ispec) = c44store_crust_mantle(i,j,k,ispec) &
              + scale_factor_minus_one * mul
      c55store_crust_mantle(i,j,k,ispec) = c55store_crust_mantle(i,j,k,ispec) &
              + scale_factor_minus_one * mul
      c66store_crust_mantle(i,j,k,ispec) = c66store_crust_mantle(i,j,k,ispec) &
              + scale_factor_minus_one * mul
    else
      muvstore_crust_mantle(i,j,k,ispec) = muvstore_crust_mantle(i,j,k,ispec) * scale_factor
      if(TRANSVERSE_ISOTROPY_VAL .and. (idoubling_crust_mantle(ispec) == IFLAG_220_80 &
      .or. idoubling_crust_mantle(ispec) == IFLAG_80_MOHO)) &
        muhstore_crust_mantle(i,j,k,ispec) = muhstore_crust_mantle(i,j,k,ispec) * scale_factor
    endif

          enddo
        enddo
      enddo
    enddo ! END DO CRUST MANTLE

! rescale in inner core

    do ispec = 1,NSPEC_INNER_CORE
      do k=1,NGLLZ
        do j=1,NGLLY
          do i=1,NGLLX

            if(ATTENUATION_3D_VAL) then
               scale_factor_minus_one = factor_scale_inner_core(i,j,k,ispec) - 1.0
            else
               iglob   = ibool_inner_core(i,j,k,ispec)
               dist_cr = xstore_inner_core(iglob)
               call get_attenuation_index(idoubling_inner_core(ispec), dble(dist_cr), iregion_selected, .TRUE., AM_V)
               scale_factor_minus_one = factor_scale_inner_core(1,1,1,iregion_selected) - 1.
            endif

        if(ANISOTROPIC_INNER_CORE_VAL) then
          mul = muvstore_inner_core(i,j,k,ispec)
          c11store_inner_core(i,j,k,ispec) = c11store_inner_core(i,j,k,ispec) &
                  + FOUR_THIRDS * scale_factor_minus_one * mul
          c12store_inner_core(i,j,k,ispec) = c12store_inner_core(i,j,k,ispec) &
                  - TWO_THIRDS * scale_factor_minus_one * mul
          c13store_inner_core(i,j,k,ispec) = c13store_inner_core(i,j,k,ispec) &
                  - TWO_THIRDS * scale_factor_minus_one * mul
          c33store_inner_core(i,j,k,ispec) = c33store_inner_core(i,j,k,ispec) &
                  + FOUR_THIRDS * scale_factor_minus_one * mul
          c44store_inner_core(i,j,k,ispec) = c44store_inner_core(i,j,k,ispec) &
                  + scale_factor_minus_one * mul
        endif

            if(ATTENUATION_3D_VAL) then
               muvstore_inner_core(i,j,k,ispec) = muvstore_inner_core(i,j,k,ispec) * factor_scale_inner_core(i,j,k,ispec)
            else
               muvstore_inner_core(i,j,k,ispec) = muvstore_inner_core(i,j,k,ispec) * factor_scale_inner_core(1,1,1,iregion_selected)
            endif

          enddo
        enddo
      enddo
    enddo ! END DO INNER CORE

  endif ! END IF(ATTENUATION)

! allocate seismogram array
  if (nrec_local > 0) then
    if (SIMULATION_TYPE == 1 .or. SIMULATION_TYPE == 3) then
      allocate(seismograms(NDIM,nrec_local,NTSTEP_BETWEEN_OUTPUT_SEISMOS))
    else
      allocate(seismograms(9,nrec_local,NTSTEP_BETWEEN_OUTPUT_SEISMOS))
    endif
! initialize seismograms
    seismograms(:,:,:) = 0._CUSTOM_REAL
    nit_written = 0
  endif

! initialize arrays to zero

  displ_crust_mantle(:,:) = 0._CUSTOM_REAL
  veloc_crust_mantle(:,:) = 0._CUSTOM_REAL
  accel_crust_mantle(:,:) = 0._CUSTOM_REAL

  displ_outer_core(:) = 0._CUSTOM_REAL
  veloc_outer_core(:) = 0._CUSTOM_REAL
  accel_outer_core(:) = 0._CUSTOM_REAL

  displ_inner_core(:,:) = 0._CUSTOM_REAL
  veloc_inner_core(:,:) = 0._CUSTOM_REAL
  accel_inner_core(:,:) = 0._CUSTOM_REAL

! put negligible initial value to avoid very slow underflow trapping
  if(FIX_UNDERFLOW_PROBLEM) then
    displ_crust_mantle(:,:) = VERYSMALLVAL
    displ_outer_core(:) = VERYSMALLVAL
    displ_inner_core(:,:) = VERYSMALLVAL
  endif

  if (SIMULATION_TYPE == 3) then

    rho_kl_crust_mantle(:,:,:,:) = 0._CUSTOM_REAL
    beta_kl_crust_mantle(:,:,:,:) = 0._CUSTOM_REAL
    alpha_kl_crust_mantle(:,:,:,:) = 0._CUSTOM_REAL

    rho_kl_outer_core(:,:,:,:) = 0._CUSTOM_REAL
    alpha_kl_outer_core(:,:,:,:) = 0._CUSTOM_REAL

    rho_kl_inner_core(:,:,:,:) = 0._CUSTOM_REAL
    beta_kl_inner_core(:,:,:,:) = 0._CUSTOM_REAL
    alpha_kl_inner_core(:,:,:,:) = 0._CUSTOM_REAL

    div_displ_outer_core(:,:,:,:) = 0._CUSTOM_REAL
    b_div_displ_outer_core(:,:,:,:) = 0._CUSTOM_REAL

  endif

! store g, rho and dg/dr=dg using normalized radius in lookup table every 100 m
! get density and velocity from PREM model using dummy doubling flag
! this assumes that the gravity perturbations are small and smooth
! and that we can neglect the 3D model and use PREM every 100 m in all cases
! this is probably a rather reasonable assumption
  if(GRAVITY_VAL) then
    call make_gravity(nspl_gravity,rspl_gravity,gspl,gspl2,ONE_CRUST)
    do int_radius = 1,NRAD_GRAVITY
      radius = dble(int_radius) / (R_EARTH_KM * 10.d0)
      call spline_evaluation(rspl_gravity,gspl,gspl2,nspl_gravity,radius,g)
      idoubling = 0

! use PREM density profile to calculate gravity (fine for other 1D models)
      call prem_iso(myrank,radius,rho,drhodr,vp,vs,Qkappa,Qmu,idoubling,.false., &
          ONE_CRUST,.false.,RICB,RCMB,RTOPDDOUBLEPRIME, &
          R600,R670,R220,R771,R400,R80,RMOHO,RMIDDLE_CRUST,ROCEAN)

      dg = 4.0d0*rho - 2.0d0*g/radius
      minus_gravity_table(int_radius) = - g
      minus_deriv_gravity_table(int_radius) = - dg
      density_table(int_radius) = rho
      minus_rho_g_over_kappa_fluid(int_radius) = - g / vp**2
    enddo

! make sure fluid array is only assigned in outer core between 1222 and 3478 km
! lookup table is defined every 100 m
    do int_radius = 1,NRAD_GRAVITY
      radius_km = dble(int_radius) / 10.d0
      if(radius_km > RCMB/1000.d0 - 3.d0) &
        minus_rho_g_over_kappa_fluid(int_radius) = minus_rho_g_over_kappa_fluid(nint((RCMB/1000.d0 - 3.d0)*10.d0))
      if(radius_km < RICB/1000.d0 + 3.d0) &
        minus_rho_g_over_kappa_fluid(int_radius) = minus_rho_g_over_kappa_fluid(nint((RICB/1000.d0 + 3.d0)*10.d0))
    enddo

! compute gravity value at CMB and ICB once and for all
    radius = RCMB / R_EARTH
    call spline_evaluation(rspl_gravity,gspl,gspl2,nspl_gravity,radius,g_cmb_dble)

    radius = RICB / R_EARTH
    call spline_evaluation(rspl_gravity,gspl,gspl2,nspl_gravity,radius,g_icb_dble)

! distinguish between single and double precision for reals
    if(CUSTOM_REAL == SIZE_REAL) then
      minus_g_cmb = sngl(- g_cmb_dble)
      minus_g_icb = sngl(- g_icb_dble)
    else
      minus_g_cmb = - g_cmb_dble
      minus_g_icb = - g_icb_dble
    endif

   else

 ! tabulate d ln(rho)/dr needed for the no gravity fluid potential
     do int_radius = 1,NRAD_GRAVITY
       radius = dble(int_radius) / (R_EARTH_KM * 10.d0)
       idoubling = 0
       call prem_iso(myrank,radius,rho,drhodr,vp,vs,Qkappa,Qmu,idoubling,.false., &
           ONE_CRUST,.false.,RICB,RCMB,RTOPDDOUBLEPRIME, &
           R600,R670,R220,R771,R400,R80,RMOHO,RMIDDLE_CRUST,ROCEAN)
       d_ln_density_dr_table(int_radius) = drhodr/rho
     enddo

   endif


! allocate files to save movies
  if(MOVIE_SURFACE) then
    nmovie_points = NGLLX * NGLLY * NSPEC2D_TOP(IREGION_CRUST_MANTLE)
    allocate(store_val_x(nmovie_points))
    allocate(store_val_y(nmovie_points))
    allocate(store_val_z(nmovie_points))
    allocate(store_val_ux(nmovie_points))
    allocate(store_val_uy(nmovie_points))
    allocate(store_val_uz(nmovie_points))

    allocate(store_val_x_all(nmovie_points,0:NPROCTOT-1))
    allocate(store_val_y_all(nmovie_points,0:NPROCTOT-1))
    allocate(store_val_z_all(nmovie_points,0:NPROCTOT-1))
    allocate(store_val_ux_all(nmovie_points,0:NPROCTOT-1))
    allocate(store_val_uy_all(nmovie_points,0:NPROCTOT-1))
    allocate(store_val_uz_all(nmovie_points,0:NPROCTOT-1))
  endif

  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) '           time step: ',sngl(DT),' s'
    write(IMAIN,*) 'number of time steps: ',NSTEP
    write(IMAIN,*) 'total simulated time: ',sngl(((NSTEP-1)*DT-t0)/60.d0),' minutes'
    write(IMAIN,*) 'start time:',sngl(-t0),' seconds'
    write(IMAIN,*)
  endif

! define constants for the time integration
! scaling to make displacement in meters and velocity in meters per second
  scale_t = ONE/dsqrt(PI*GRAV*RHOAV)
  scale_displ = R_EARTH
  scale_veloc = scale_displ / scale_t

! distinguish between single and double precision for reals
  if(CUSTOM_REAL == SIZE_REAL) then
    deltat = sngl(DT/scale_t)
  else
    deltat = DT/scale_t
  endif
  deltatover2 = 0.5d0*deltat
  deltatsqover2 = 0.5d0*deltat*deltat

  if (SIMULATION_TYPE == 3) then
    if(CUSTOM_REAL == SIZE_REAL) then
      b_deltat = - sngl(DT/scale_t)
    else
      b_deltat = - DT/scale_t
    endif
    b_deltatover2 = 0.5d0*b_deltat
    b_deltatsqover2 = 0.5d0*b_deltat*b_deltat
  endif

! non-dimensionalized rotation rate of the Earth times two
  if(ROTATION_VAL) then
! distinguish between single and double precision for reals
    if (SIMULATION_TYPE == 1) then
    if(CUSTOM_REAL == SIZE_REAL) then
      two_omega_earth = sngl(2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t))
    else
      two_omega_earth = 2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t)
    endif
    else
    if(CUSTOM_REAL == SIZE_REAL) then
      two_omega_earth = - sngl(2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t))
    else
      two_omega_earth = - 2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t)
    endif
    endif
    A_array_rotation = 0.
    B_array_rotation = 0.
    if (SIMULATION_TYPE == 3) then
      if(CUSTOM_REAL == SIZE_REAL) then
        b_two_omega_earth = sngl(2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t))
      else
        b_two_omega_earth = 2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t)
      endif
    endif
  else
    two_omega_earth = 0._CUSTOM_REAL
    if (SIMULATION_TYPE == 3) b_two_omega_earth = 0._CUSTOM_REAL
  endif

! precompute Runge-Kutta coefficients if attenuation
  if(ATTENUATION_VAL) then
     call attenuation_memory_values(tau_sigma_dble, deltat, alphaval_dble, betaval_dble, gammaval_dble)
     if(CUSTOM_REAL == SIZE_REAL) then
        alphaval = sngl(alphaval_dble)
        betaval  = sngl(betaval_dble)
        gammaval = sngl(gammaval_dble)
     else
        alphaval = alphaval_dble
        betaval  = betaval_dble
        gammaval = gammaval_dble
     endif
     if (SIMULATION_TYPE == 3) then
       call attenuation_memory_values(tau_sigma_dble, b_deltat, alphaval_dble, betaval_dble, gammaval_dble)
       if(CUSTOM_REAL == SIZE_REAL) then
         b_alphaval = sngl(alphaval_dble)
         b_betaval  = sngl(betaval_dble)
         b_gammaval = sngl(gammaval_dble)
       else
         b_alphaval = alphaval_dble
         b_betaval  = betaval_dble
         b_gammaval = gammaval_dble
       endif
     endif
  endif

  if (SAVE_STRAIN) then
    eps_trace_over_3_crust_mantle(:,:,:,:) = 0._CUSTOM_REAL
    epsilondev_crust_mantle(:,:,:,:,:) = 0._CUSTOM_REAL
    eps_trace_over_3_inner_core(:,:,:,:) = 0._CUSTOM_REAL
    epsilondev_inner_core(:,:,:,:,:) = 0._CUSTOM_REAL
    if(FIX_UNDERFLOW_PROBLEM) then
      eps_trace_over_3_crust_mantle(:,:,:,:) = VERYSMALLVAL
      epsilondev_crust_mantle(:,:,:,:,:) = VERYSMALLVAL
      eps_trace_over_3_inner_core(:,:,:,:) = VERYSMALLVAL
      epsilondev_inner_core(:,:,:,:,:) = VERYSMALLVAL
    endif
  endif

! clear memory variables if attenuation
  if(ATTENUATION_VAL) then
    if (NSPEC_CRUST_MANTLE_ATTENUAT /= NSPEC_CRUST_MANTLE) &
       call exit_MPI(myrank, 'NSPEC_CRUST_MANTLE_ATTENUAT /= NSPEC_CRUST_MANTLE, exit')
    if (NSPEC_INNER_CORE_ATTENUATION /= NSPEC_INNER_CORE) &
       call exit_MPI(myrank, 'NSPEC_INNER_CORE_ATTENUATION /= NSPEC_INNER_CORE, exit')

    R_memory_crust_mantle(:,:,:,:,:,:) = 0._CUSTOM_REAL
    R_memory_inner_core(:,:,:,:,:,:) = 0._CUSTOM_REAL
    if(FIX_UNDERFLOW_PROBLEM) then
      R_memory_crust_mantle(:,:,:,:,:,:) = VERYSMALLVAL
      R_memory_inner_core(:,:,:,:,:,:) = VERYSMALLVAL
    endif

  endif

! get information about event name and location for SAC seismograms
  call get_event_info_parallel(myrank,yr_SAC,jda_SAC,ho_SAC,mi_SAC,sec_SAC,t_cmt_SAC, &
                 elat_SAC,elon_SAC,depth_SAC,mb_SAC,ename_SAC,cmt_lat_SAC,cmt_lon_SAC,cmt_depth_SAC,cmt_hdur_SAC,NSOURCES_SAC)

! define correct time steps if restart files
  if(NUMBER_OF_RUNS < 1 .or. NUMBER_OF_RUNS > 3) stop 'number of restart runs can be 1, 2 or 3'
  if(NUMBER_OF_THIS_RUN < 1 .or. NUMBER_OF_THIS_RUN > NUMBER_OF_RUNS) stop 'incorrect run number'
  if (SIMULATION_TYPE /= 1 .and. NUMBER_OF_RUNS /= 1) stop 'Only 1 run for SIMULATION_TYPE = 2/3'

  if(NUMBER_OF_RUNS == 3) then
    if(NUMBER_OF_THIS_RUN == 1) then
      it_begin = 1
      it_end = NSTEP/3
    else if(NUMBER_OF_THIS_RUN == 2) then
      it_begin = NSTEP/3 + 1
      it_end = 2*(NSTEP/3)
    else
      it_begin = 2*(NSTEP/3) + 1
      it_end = NSTEP
    endif

  else if(NUMBER_OF_RUNS == 2) then
    if(NUMBER_OF_THIS_RUN == 1) then
      it_begin = 1
      it_end = NSTEP/2
    else
      it_begin = NSTEP/2 + 1
      it_end = NSTEP
    endif

  else
    it_begin = 1
    it_end = NSTEP
  endif

! read files back from local disk or MT tape system if restart file
  if(NUMBER_OF_THIS_RUN > 1) then
    write(outputname,"('dump_all_arrays',i6.6)") myrank
    open(unit=55,file=trim(LOCAL_PATH)//'/'//outputname,status='old',action='read',form='unformatted')
    read(55) displ_crust_mantle
    read(55) veloc_crust_mantle
    read(55) accel_crust_mantle
    read(55) displ_inner_core
    read(55) veloc_inner_core
    read(55) accel_inner_core
    read(55) displ_outer_core
    read(55) veloc_outer_core
    read(55) accel_outer_core
    read(55) R_memory_crust_mantle
    read(55) R_memory_inner_core
    read(55) epsilondev_crust_mantle
    read(55) epsilondev_inner_core
    read(55) A_array_rotation
    read(55) B_array_rotation
    close(55)
  endif

  if (SIMULATION_TYPE == 3) then
    write(outputname,'(a,i6.6,a)') 'proc',myrank,'_save_forward_arrays.bin'
    open(unit=55,file=trim(LOCAL_PATH)//'/'//outputname,status='old',action='read',form='unformatted')
    read(55) b_displ_crust_mantle
    read(55) b_veloc_crust_mantle
    read(55) b_accel_crust_mantle
    read(55) b_displ_inner_core
    read(55) b_veloc_inner_core
    read(55) b_accel_inner_core
    read(55) b_displ_outer_core
    read(55) b_veloc_outer_core
    read(55) b_accel_outer_core
    if (ATTENUATION_VAL) then
      read(55) b_R_memory_crust_mantle
      read(55) b_R_memory_inner_core
    endif
    read(55) b_epsilondev_crust_mantle
    read(55) b_epsilondev_inner_core
    if (ROTATION_VAL) then
      read(55) b_A_array_rotation
      read(55) b_B_array_rotation
    endif
    close(55)

  endif

!
!   s t a r t   t i m e   i t e r a t i o n s
!

! synchronize all processes to make sure everybody is ready to start time loop
  call MPI_BARRIER(MPI_COMM_WORLD,ier)
  if(myrank == 0) write(IMAIN,*) 'All processes are synchronized before time loop'

  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'Starting time iteration loop...'
    write(IMAIN,*)
  endif

! create an empty file to monitor the start of the simulation
  if(myrank == 0) then
    open(unit=IOUT,file=trim(OUTPUT_FILES)//'/starttimeloop.txt',status='unknown')
    write(IOUT,*) 'hello, starting time loop'
    close(IOUT)
  endif

! get MPI starting time
  time_start = MPI_WTIME()


! initialize variables for writing seismograms
  seismo_offset = it_begin-1
  seismo_current = 0

! *********************************************************
! ************* MAIN LOOP OVER THE TIME STEPS *************
! *********************************************************

  do it=it_begin,it_end

! update position in seismograms
    seismo_current = seismo_current + 1

! mantle
  do i=1,NGLOB_CRUST_MANTLE
    displ_crust_mantle(:,i) = displ_crust_mantle(:,i) + deltat*veloc_crust_mantle(:,i) + deltatsqover2*accel_crust_mantle(:,i)
    veloc_crust_mantle(:,i) = veloc_crust_mantle(:,i) + deltatover2*accel_crust_mantle(:,i)
  enddo

! outer core
  do i=1,NGLOB_OUTER_CORE
    displ_outer_core(i) = displ_outer_core(i) + deltat*veloc_outer_core(i) + deltatsqover2*accel_outer_core(i)
    veloc_outer_core(i) = veloc_outer_core(i) + deltatover2*accel_outer_core(i)
  enddo

! inner core
  do i=1,NGLOB_INNER_CORE
    displ_inner_core(:,i) = displ_inner_core(:,i) + deltat*veloc_inner_core(:,i) + deltatsqover2*accel_inner_core(:,i)
    veloc_inner_core(:,i) = veloc_inner_core(:,i) + deltatover2*accel_inner_core(:,i)
  enddo

! backward field
  if (SIMULATION_TYPE == 3) then
  do i=1,NGLOB_CRUST_MANTLE
    b_displ_crust_mantle(:,i) = b_displ_crust_mantle(:,i) + b_deltat*b_veloc_crust_mantle(:,i) + &
         b_deltatsqover2*b_accel_crust_mantle(:,i)
    b_veloc_crust_mantle(:,i) = b_veloc_crust_mantle(:,i) + b_deltatover2*b_accel_crust_mantle(:,i)
  enddo
  do i=1,NGLOB_OUTER_CORE
    b_displ_outer_core(i) = b_displ_outer_core(i) + b_deltat*b_veloc_outer_core(i) + b_deltatsqover2*b_accel_outer_core(i)
    b_veloc_outer_core(i) = b_veloc_outer_core(i) + b_deltatover2*b_accel_outer_core(i)
  enddo
  do i=1,NGLOB_INNER_CORE
    b_displ_inner_core(:,i) = b_displ_inner_core(:,i) + b_deltat*b_veloc_inner_core(:,i) + b_deltatsqover2*b_accel_inner_core(:,i)
    b_veloc_inner_core(:,i) = b_veloc_inner_core(:,i) + b_deltatover2*b_accel_inner_core(:,i)
  enddo
  endif

! compute the maximum of the norm of the displacement
! in all the slices using an MPI reduction
! and output timestamp file to check that simulation is running fine
  if(mod(it,NTSTEP_BETWEEN_OUTPUT_INFO) == 0 .or. it == 5 .or. it == NSTEP) then

! compute maximum of norm of displacement in each slice
    Usolidnorm = max( &
        maxval(sqrt(displ_crust_mantle(1,:)**2 + &
          displ_crust_mantle(2,:)**2 + displ_crust_mantle(3,:)**2)), &
        maxval(sqrt(displ_inner_core(1,:)**2 + displ_inner_core(2,:)**2 + displ_inner_core(3,:)**2)))

    Ufluidnorm = maxval(abs(displ_outer_core))

! compute the maximum of the maxima for all the slices using an MPI reduction
    call MPI_REDUCE(Usolidnorm,Usolidnorm_all,1,CUSTOM_MPI_TYPE,MPI_MAX,0, &
                          MPI_COMM_WORLD,ier)
    call MPI_REDUCE(Ufluidnorm,Ufluidnorm_all,1,CUSTOM_MPI_TYPE,MPI_MAX,0, &
                          MPI_COMM_WORLD,ier)
    if (SIMULATION_TYPE == 3) then
      b_Usolidnorm = max( &
                 maxval(sqrt(b_displ_crust_mantle(1,:)**2 + &
                 b_displ_crust_mantle(2,:)**2 + b_displ_crust_mantle(3,:)**2)), &
                 maxval(sqrt(b_displ_inner_core(1,:)**2 + b_displ_inner_core(2,:)**2 + b_displ_inner_core(3,:)**2)))

      b_Ufluidnorm = maxval(abs(b_displ_outer_core))

! compute the maximum of the maxima for all the slices using an MPI reduction
      call MPI_REDUCE(b_Usolidnorm,b_Usolidnorm_all,1,CUSTOM_MPI_TYPE,MPI_MAX,0, &
                 MPI_COMM_WORLD,ier)
      call MPI_REDUCE(b_Ufluidnorm,b_Ufluidnorm_all,1,CUSTOM_MPI_TYPE,MPI_MAX,0, &
                 MPI_COMM_WORLD,ier)

    endif

    if(myrank == 0) then

      write(IMAIN,*) 'Time step # ',it
      write(IMAIN,*) 'Time: ',sngl(((it-1)*DT-t0)/60.d0),' minutes'

! rescale maximum displacement to correct dimensions
      Usolidnorm_all = Usolidnorm_all * sngl(scale_displ)
      write(IMAIN,*) 'Max norm displacement vector U in solid in all slices (m) = ',Usolidnorm_all
      write(IMAIN,*) 'Max non-dimensional potential Ufluid in fluid in all slices = ',Ufluidnorm_all
      if (SIMULATION_TYPE == 3) then
      b_Usolidnorm_all = b_Usolidnorm_all * sngl(scale_displ)
      write(IMAIN,*) 'Max norm displacement vector U in solid in all slices for back prop.(m) = ',b_Usolidnorm_all
      write(IMAIN,*) 'Max non-dimensional potential Ufluid in fluid in all slices for back prop.= ',b_Ufluidnorm_all
      endif

! elapsed time since beginning of the simulation
      tCPU = MPI_WTIME() - time_start
      int_tCPU = int(tCPU)
      ihours = int_tCPU / 3600
      iminutes = (int_tCPU - 3600*ihours) / 60
      iseconds = int_tCPU - 3600*ihours - 60*iminutes
      write(IMAIN,*) 'Elapsed time in seconds = ',tCPU
      write(IMAIN,"(' Elapsed time in hh:mm:ss = ',i4,' h ',i2.2,' m ',i2.2,' s')") ihours,iminutes,iseconds
      write(IMAIN,*) 'Mean elapsed time per time step in seconds = ',tCPU/dble(it)

! compute estimated remaining simulation time
      t_remain = (NSTEP - it) * (tCPU/dble(it))
      int_t_remain = int(t_remain)
      ihours_remain = int_t_remain / 3600
      iminutes_remain = (int_t_remain - 3600*ihours_remain) / 60
      iseconds_remain = int_t_remain - 3600*ihours_remain - 60*iminutes_remain
      write(IMAIN,*) 'Time steps done = ',it,' out of ',NSTEP
      write(IMAIN,*) 'Time steps remaining = ',NSTEP - it
      write(IMAIN,*) 'Estimated remaining time in seconds = ',t_remain
      write(IMAIN,"(' Estimated remaining time in hh:mm:ss = ',i4,' h ',i2.2,' m ',i2.2,' s')") &
               ihours_remain,iminutes_remain,iseconds_remain

! compute estimated total simulation time
      t_total = t_remain + tCPU
      int_t_total = int(t_total)
      ihours_total = int_t_total / 3600
      iminutes_total = (int_t_total - 3600*ihours_total) / 60
      iseconds_total = int_t_total - 3600*ihours_total - 60*iminutes_total
      write(IMAIN,*) 'Estimated total run time in seconds = ',t_total
      write(IMAIN,"(' Estimated total run time in hh:mm:ss = ',i4,' h ',i2.2,' m ',i2.2,' s')") &
               ihours_total,iminutes_total,iseconds_total
      write(IMAIN,*) 'We have done ',sngl(100.d0*dble(it)/dble(NSTEP)),'% of that'
      write(IMAIN,*)

! write time stamp file to give information about progression of simulation
      write(outputname,"('/timestamp',i6.6)") it

      open(unit=IOUT,file=trim(OUTPUT_FILES)//outputname,status='unknown')

      write(IOUT,*) 'Time step # ',it
      write(IOUT,*) 'Time: ',sngl(((it-1)*DT-t0)/60.d0),' minutes'
      write(IOUT,*)
      write(IOUT,*) 'Max norm displacement vector U in solid in all slices (m) = ',Usolidnorm_all
      write(IOUT,*) 'Max non-dimensional potential Ufluid in fluid in all slices = ',Ufluidnorm_all
      write(IOUT,*)

      if (SIMULATION_TYPE == 3) then
        write(IOUT,*) 'Max norm displacement vector U in solid in all slices for back prop.(m) = ',b_Usolidnorm_all
        write(IOUT,*) 'Max non-dimensional potential Ufluid in fluid in all slices for back prop.= ',b_Ufluidnorm_all
        write(IOUT,*)
      endif

      write(IOUT,*) 'Elapsed time in seconds = ',tCPU
      write(IOUT,"(' Elapsed time in hh:mm:ss = ',i4,' h ',i2.2,' m ',i2.2,' s')") ihours,iminutes,iseconds
      write(IOUT,*) 'Mean elapsed time per time step in seconds = ',tCPU/dble(it)
      write(IOUT,*)

      write(IOUT,*) 'Time steps done = ',it,' out of ',NSTEP
      write(IOUT,*) 'Time steps remaining = ',NSTEP - it
      write(IOUT,*) 'Estimated remaining time in seconds = ',t_remain
      write(IOUT,"(' Estimated remaining time in hh:mm:ss = ',i4,' h ',i2.2,' m ',i2.2,' s')") &
               ihours_remain,iminutes_remain,iseconds_remain
      write(IOUT,*)

      write(IOUT,*) 'Estimated total run time in seconds = ',t_total
      write(IOUT,"(' Estimated total run time in hh:mm:ss = ',i4,' h ',i2.2,' m ',i2.2,' s')") &
               ihours_total,iminutes_total,iseconds_total
      write(IOUT,*) 'We have done ',sngl(100.d0*dble(it)/dble(NSTEP)),'% of that'

      close(IOUT)

! check stability of the code, exit if unstable
      if(Usolidnorm_all > STABILITY_THRESHOLD) call exit_MPI(myrank,'code became unstable and blew up in solid')
      if(Ufluidnorm_all > STABILITY_THRESHOLD) call exit_MPI(myrank,'code became unstable and blew up in fluid')
      if (SIMULATION_TYPE == 3) then
        if(b_Usolidnorm_all > STABILITY_THRESHOLD) call exit_MPI(myrank,'code became unstable and blew up in solid for back prop.')
        if(b_Ufluidnorm_all > STABILITY_THRESHOLD) call exit_MPI(myrank,'code became unstable and blew up in fluid for back prop.')
      endif
    endif
  endif

! ****************************************************
!   big loop over all spectral elements in the fluid
! ****************************************************

! compute internal forces in the fluid region
  if(CUSTOM_REAL == SIZE_REAL) then
    time = sngl((dble(it-1)*DT-t0)/scale_t)
  else
    time = (dble(it-1)*DT-t0)/scale_t
  endif

! accel_outer_core, div_displ_outer_core are initialized to zero in the following subroutine.
  call compute_forces_outer_core(time,deltat,two_omega_earth, &
         A_array_rotation,B_array_rotation,d_ln_density_dr_table, &
         minus_rho_g_over_kappa_fluid,displ_outer_core,accel_outer_core,div_displ_outer_core, &
         xstore_outer_core,ystore_outer_core,zstore_outer_core, &
         xix_outer_core,xiy_outer_core,xiz_outer_core, &
         etax_outer_core,etay_outer_core,etaz_outer_core, &
         gammax_outer_core,gammay_outer_core,gammaz_outer_core, &
         hprime_xx,hprime_yy,hprime_zz,hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
         wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube, &
         ibool_outer_core)

  if (SIMULATION_TYPE == 3) then
    call compute_forces_outer_core(time,b_deltat,b_two_omega_earth, &
         b_A_array_rotation,b_B_array_rotation,d_ln_density_dr_table, &
         minus_rho_g_over_kappa_fluid,b_displ_outer_core,b_accel_outer_core,b_div_displ_outer_core, &
         xstore_outer_core,ystore_outer_core,zstore_outer_core, &
         xix_outer_core,xiy_outer_core,xiz_outer_core, &
         etax_outer_core,etay_outer_core,etaz_outer_core, &
         gammax_outer_core,gammay_outer_core,gammaz_outer_core, &
         hprime_xx,hprime_yy,hprime_zz,hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
         wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube, &
         ibool_outer_core)
  endif

! Stacey
  if(NCHUNKS_VAL /= 6 .and. ABSORBING_CONDITIONS) then

!   xmin
! if two chunks exclude this face for one of them
  if(NCHUNKS_VAL == 1 .or. ichunk == CHUNK_AC) then

    if (SIMULATION_TYPE == 3 .and. nspec2D_xmin_outer_core > 0)  then
      read(61,rec=NSTEP-it+1) reclen1,absorb_xmin_outer_core,reclen2
      if (reclen1 /= reclen_xmin_outer_core .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_xmin_outer_core')
    endif

    do ispec2D=1,nspec2D_xmin_outer_core

      ispec=ibelm_xmin_outer_core(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_xi_outer_core(1,ispec2D) == 0 .or. njmin_outer_core(1,ispec2D) == 0) cycle

      i=1
      do k=nkmin_xi_outer_core(1,ispec2D),NGLLZ
        do j=njmin_outer_core(1,ispec2D),njmax_outer_core(1,ispec2D)
          iglob=ibool_outer_core(i,j,k,ispec)

          sn = veloc_outer_core(iglob)/vp_outer_core(i,j,k,ispec)

          weight = jacobian2D_xmin_outer_core(j,k,ispec2D)*wgllwgll_yz(j,k)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn

          if (SIMULATION_TYPE == 3) then
            b_accel_outer_core(iglob) = b_accel_outer_core(iglob) - absorb_xmin_outer_core(j,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_xmin_outer_core(j,k,ispec2D) = weight*sn
          endif
        enddo
      enddo
    enddo

    if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_xmin_outer_core > 0 ) &
               write(61,rec=it) reclen_xmin_outer_core,absorb_xmin_outer_core,reclen_xmin_outer_core

  endif

!   xmax
! if two chunks exclude this face for one of them
  if(NCHUNKS_VAL == 1 .or. ichunk == CHUNK_AB) then

    if (SIMULATION_TYPE == 3 .and. nspec2D_xmax_outer_core > 0)  then
      read(62,rec=NSTEP-it+1) reclen1,absorb_xmax_outer_core,reclen2
      if (reclen1 /= reclen_xmax_outer_core .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_xmax_outer_core')
    endif

    do ispec2D=1,nspec2D_xmax_outer_core

      ispec=ibelm_xmax_outer_core(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_xi_outer_core(2,ispec2D) == 0 .or. njmin_outer_core(2,ispec2D) == 0) cycle

      i=NGLLX
      do k=nkmin_xi_outer_core(2,ispec2D),NGLLZ
        do j=njmin_outer_core(2,ispec2D),njmax_outer_core(2,ispec2D)
          iglob=ibool_outer_core(i,j,k,ispec)

          sn = veloc_outer_core(iglob)/vp_outer_core(i,j,k,ispec)

          weight = jacobian2D_xmax_outer_core(j,k,ispec2D)*wgllwgll_yz(j,k)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn

          if (SIMULATION_TYPE == 3) then
            b_accel_outer_core(iglob) = b_accel_outer_core(iglob) - absorb_xmax_outer_core(j,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_xmax_outer_core(j,k,ispec2D) = weight*sn
          endif

        enddo
      enddo
    enddo

    if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_xmax_outer_core > 0 ) &
               write(62,rec=it) reclen_xmax_outer_core,absorb_xmax_outer_core,reclen_xmax_outer_core

  endif

!   ymin
    if (SIMULATION_TYPE == 3 .and. nspec2D_ymin_outer_core > 0)  then
      read(63,rec=NSTEP-it+1) reclen1,absorb_ymin_outer_core,reclen2
      if (reclen1 /= reclen_ymin_outer_core .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_ymin_outer_core')
    endif

    do ispec2D=1,nspec2D_ymin_outer_core

      ispec=ibelm_ymin_outer_core(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_eta_outer_core(1,ispec2D) == 0 .or. nimin_outer_core(1,ispec2D) == 0) cycle

      j=1
      do k=nkmin_eta_outer_core(1,ispec2D),NGLLZ
        do i=nimin_outer_core(1,ispec2D),nimax_outer_core(1,ispec2D)
          iglob=ibool_outer_core(i,j,k,ispec)

          sn = veloc_outer_core(iglob)/vp_outer_core(i,j,k,ispec)

          weight=jacobian2D_ymin_outer_core(i,k,ispec2D)*wgllwgll_xz(i,k)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn

          if (SIMULATION_TYPE == 3) then
            b_accel_outer_core(iglob) = b_accel_outer_core(iglob) - absorb_ymin_outer_core(i,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_ymin_outer_core(i,k,ispec2D) = weight*sn
          endif

        enddo
      enddo
    enddo

    if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_ymin_outer_core > 0 ) &
       write(63,rec=it) reclen_ymin_outer_core,absorb_ymin_outer_core,reclen_ymin_outer_core


!   ymax
    if (SIMULATION_TYPE == 3 .and. nspec2D_ymax_outer_core > 0)  then
      read(64,rec=NSTEP-it+1) reclen1,absorb_ymax_outer_core,reclen2
      if (reclen1 /= reclen_ymax_outer_core .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_ymax_outer_core')
    endif
    do ispec2D=1,nspec2D_ymax_outer_core

      ispec=ibelm_ymax_outer_core(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_eta_outer_core(2,ispec2D) == 0 .or. nimin_outer_core(2,ispec2D) == 0) cycle

      j=NGLLY
      do k=nkmin_eta_outer_core(2,ispec2D),NGLLZ
        do i=nimin_outer_core(2,ispec2D),nimax_outer_core(2,ispec2D)
          iglob=ibool_outer_core(i,j,k,ispec)

          sn = veloc_outer_core(iglob)/vp_outer_core(i,j,k,ispec)

          weight=jacobian2D_ymax_outer_core(i,k,ispec2D)*wgllwgll_xz(i,k)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn

          if (SIMULATION_TYPE == 3) then
            b_accel_outer_core(iglob) = b_accel_outer_core(iglob) - absorb_ymax_outer_core(i,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_ymax_outer_core(i,k,ispec2D) = weight*sn
          endif

        enddo
      enddo
    enddo

    if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_ymax_outer_core > 0 ) &
       write(64,rec=it) reclen_ymax_outer_core,absorb_ymax_outer_core,reclen_ymax_outer_core


! for surface elements exactly on the ICB
   if (SIMULATION_TYPE == 3 .and. NSPEC2D_BOTTOM(IREGION_OUTER_CORE)> 0)  then
      read(65,rec=NSTEP-it+1) reclen1,absorb_zmin_outer_core,reclen2
      if (reclen1 /= reclen_zmin .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_zmin_outer_core')
    endif

    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)

      ispec = ibelm_bottom_outer_core(ispec2D)

      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX
          iglob = ibool_outer_core(i,j,k,ispec)

          sn = veloc_outer_core(iglob)/vp_outer_core(i,j,k,ispec)

          weight = jacobian2D_bottom_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn

          if (SIMULATION_TYPE == 3) then
            b_accel_outer_core(iglob) = b_accel_outer_core(iglob) - absorb_zmin_outer_core(i,j,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_zmin_outer_core(i,j,ispec2D) = weight*sn
          endif

        enddo
      enddo
    enddo

    if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. NSPEC2D_BOTTOM(IREGION_OUTER_CORE) > 0 ) &
       write(65,rec=it) reclen_zmin,absorb_zmin_outer_core,reclen_zmin

  endif ! Stacey conditions


! ****************************************************
! **********  add matching with solid part  **********
! ****************************************************

! only for elements in first matching layer in the fluid

!---
!--- couple with mantle at the top of the outer core
!---

  if(ACTUALLY_COUPLE_FLUID_CMB) then

! for surface elements exactly on the CMB
    do ispec2D = 1,NSPEC2D_TOP(IREGION_OUTER_CORE)
      ispec = ibelm_top_outer_core(ispec2D)

! only for DOFs exactly on the CMB (top of these elements)
      k = NGLLZ
      do j = 1,NGLLY
        do i = 1,NGLLX

! get velocity on the solid side using pointwise matching
          ispec_selected = ibelm_bottom_crust_mantle(ispec2D)

! corresponding points are located at the bottom of the mantle
          k_corresp = 1
          iglob = ibool_crust_mantle(i,j,k_corresp,ispec_selected)

          displ_x = displ_crust_mantle(1,iglob)
          displ_y = displ_crust_mantle(2,iglob)
          displ_z = displ_crust_mantle(3,iglob)

! get global point number
          iglob = ibool_outer_core(i,j,k,ispec)

! get normal on the CMB
          nx = normal_top_outer_core(1,i,j,ispec2D)
          ny = normal_top_outer_core(2,i,j,ispec2D)
          nz = normal_top_outer_core(3,i,j,ispec2D)

! compute dot product
          displ_n = displ_x*nx + displ_y*ny + displ_z*nz

! formulation with generalized potential
          weight = jacobian2D_top_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel_outer_core(iglob) = accel_outer_core(iglob) + weight*displ_n

          if (SIMULATION_TYPE == 3) then
            iglob = ibool_crust_mantle(i,j,k_corresp,ispec_selected)
            displ_x = b_displ_crust_mantle(1,iglob)
            displ_y = b_displ_crust_mantle(2,iglob)
            displ_z = b_displ_crust_mantle(3,iglob)
            displ_n = displ_x*nx + displ_y*ny + displ_z*nz
            iglob = ibool_outer_core(i,j,k,ispec)
            b_accel_outer_core(iglob) = b_accel_outer_core(iglob) + weight*displ_n
          endif

        enddo
      enddo
    enddo

    endif

!---
!--- couple with inner core at the bottom of the outer core
!---

  if(ACTUALLY_COUPLE_FLUID_ICB .and. NCHUNKS_VAL == 6) then

! for surface elements exactly on the ICB
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)
      ispec = ibelm_bottom_outer_core(ispec2D)

! only for DOFs exactly on the ICB (bottom of these elements)
      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX

! get velocity on the solid side using pointwise matching
          ispec_selected = ibelm_top_inner_core(ispec2D)

! corresponding points are located at the bottom of the mantle
          k_corresp = NGLLZ
          iglob = ibool_inner_core(i,j,k_corresp,ispec_selected)

          displ_x = displ_inner_core(1,iglob)
          displ_y = displ_inner_core(2,iglob)
          displ_z = displ_inner_core(3,iglob)

! get global point number
          iglob = ibool_outer_core(i,j,k,ispec)

! get normal on the ICB
          nx = normal_bottom_outer_core(1,i,j,ispec2D)
          ny = normal_bottom_outer_core(2,i,j,ispec2D)
          nz = normal_bottom_outer_core(3,i,j,ispec2D)

! compute dot product
          displ_n = displ_x*nx + displ_y*ny + displ_z*nz

! formulation with generalized potential
          weight = jacobian2D_bottom_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*displ_n

          if (SIMULATION_TYPE == 3) then
            iglob = ibool_inner_core(i,j,k_corresp,ispec_selected)
            displ_x = b_displ_inner_core(1,iglob)
            displ_y = b_displ_inner_core(2,iglob)
            displ_z = b_displ_inner_core(3,iglob)
            displ_n = displ_x*nx + displ_y*ny + displ_z*nz
            iglob = ibool_outer_core(i,j,k,ispec)
            b_accel_outer_core(iglob) = b_accel_outer_core(iglob) - weight*displ_n
          endif

        enddo
      enddo
    enddo

  endif

! assemble all the contributions between slices using MPI

! outer core
  call assemble_MPI_scalar(myrank,accel_outer_core,NGLOB_OUTER_CORE, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_outer_core,iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core, &
            npoin2D_faces_outer_core,npoin2D_xi_outer_core,npoin2D_eta_outer_core, &
            iboolfaces_outer_core,iboolcorner_outer_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NGLOB1D_RADIAL(IREGION_OUTER_CORE), &
            NGLOB2DMAX_XMIN_XMAX(IREGION_OUTER_CORE),NGLOB2DMAX_YMIN_YMAX(IREGION_OUTER_CORE),NGLOB2DMAX_XY,NCHUNKS)

! multiply by the inverse of the mass matrix and update velocity
  do i=1,NGLOB_OUTER_CORE
    accel_outer_core(i) = accel_outer_core(i)*rmass_outer_core(i)
    veloc_outer_core(i) = veloc_outer_core(i) + deltatover2*accel_outer_core(i)
  enddo

  if (SIMULATION_TYPE == 3) then
  call assemble_MPI_scalar(myrank,b_accel_outer_core,NGLOB_OUTER_CORE, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_outer_core,iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core, &
            npoin2D_faces_outer_core,npoin2D_xi_outer_core,npoin2D_eta_outer_core, &
            iboolfaces_outer_core,iboolcorner_outer_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NGLOB1D_RADIAL(IREGION_OUTER_CORE), &
            NGLOB2DMAX_XMIN_XMAX(IREGION_OUTER_CORE),NGLOB2DMAX_YMIN_YMAX(IREGION_OUTER_CORE),NGLOB2DMAX_XY,NCHUNKS)

  do i=1,NGLOB_OUTER_CORE
    b_accel_outer_core(i) = b_accel_outer_core(i)*rmass_outer_core(i)
    b_veloc_outer_core(i) = b_veloc_outer_core(i) + b_deltatover2*b_accel_outer_core(i)
  enddo
  endif

! ****************************************************
!   big loop over all spectral elements in the solid
! ****************************************************

! compute internal forces in the solid regions

! for anisotropy and gravity, x y and z contain r theta and phi

  call compute_forces_crust_mantle(minus_gravity_table,density_table,minus_deriv_gravity_table, &
          displ_crust_mantle,accel_crust_mantle, &
          xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
          xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle, &
          etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
          gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle, &
          hprime_xx,hprime_yy,hprime_zz, &
          hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
          wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube, &
          kappavstore_crust_mantle,kappahstore_crust_mantle,muvstore_crust_mantle, &
          muhstore_crust_mantle,eta_anisostore_crust_mantle, &
          c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle, &
          c14store_crust_mantle,c15store_crust_mantle,c16store_crust_mantle, &
          c22store_crust_mantle,c23store_crust_mantle,c24store_crust_mantle, &
          c25store_crust_mantle,c26store_crust_mantle,c33store_crust_mantle, &
          c34store_crust_mantle,c35store_crust_mantle,c36store_crust_mantle, &
          c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
          c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
          ibool_crust_mantle,idoubling_crust_mantle, &
          R_memory_crust_mantle,epsilondev_crust_mantle,eps_trace_over_3_crust_mantle,one_minus_sum_beta_crust_mantle, &
          alphaval,betaval,gammaval,factor_common_crust_mantle, &
          size(factor_common_crust_mantle,2), size(factor_common_crust_mantle,3), &
          size(factor_common_crust_mantle,4), size(factor_common_crust_mantle,5),SAVE_STRAIN,AM_V)

  if (SIMULATION_TYPE == 3) then
! for anisotropy and gravity, x y and z contain r theta and phi
  call compute_forces_crust_mantle(minus_gravity_table,density_table,minus_deriv_gravity_table, &
          b_displ_crust_mantle,b_accel_crust_mantle, &
          xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
          xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle, &
          etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
          gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle, &
          hprime_xx,hprime_yy,hprime_zz, &
          hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
          wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube, &
          kappavstore_crust_mantle,kappahstore_crust_mantle,muvstore_crust_mantle, &
          muhstore_crust_mantle,eta_anisostore_crust_mantle, &
          c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle, &
          c14store_crust_mantle,c15store_crust_mantle,c16store_crust_mantle, &
          c22store_crust_mantle,c23store_crust_mantle,c24store_crust_mantle, &
          c25store_crust_mantle,c26store_crust_mantle,c33store_crust_mantle, &
          c34store_crust_mantle,c35store_crust_mantle,c36store_crust_mantle, &
          c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
          c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
          ibool_crust_mantle,idoubling_crust_mantle, &
          b_R_memory_crust_mantle,b_epsilondev_crust_mantle,b_eps_trace_over_3_crust_mantle,one_minus_sum_beta_crust_mantle, &
          b_alphaval,b_betaval,b_gammaval,factor_common_crust_mantle, &
          size(factor_common_crust_mantle,2), size(factor_common_crust_mantle,3), &
          size(factor_common_crust_mantle,4), size(factor_common_crust_mantle,5),SAVE_STRAIN,AM_V)
  endif


! Stacey
  if(NCHUNKS_VAL /= 6 .and. ABSORBING_CONDITIONS) then

! crust & mantle

!   xmin
! if two chunks exclude this face for one of them
  if(NCHUNKS_VAL == 1 .or. ichunk == CHUNK_AC) then

    if (SIMULATION_TYPE == 3 .and. nspec2D_xmin_crust_mantle > 0)  then
      read(51,rec=NSTEP-it+1) reclen1,absorb_xmin_crust_mantle,reclen2
      if (reclen1 /= reclen_xmin_crust_mantle .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_xmin')
    endif

    do ispec2D=1,nspec2D_xmin_crust_mantle

      ispec=ibelm_xmin_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_xi_crust_mantle(1,ispec2D) == 0 .or. njmin_crust_mantle(1,ispec2D) == 0) cycle

      i=1
      do k=nkmin_xi_crust_mantle(1,ispec2D),NGLLZ
        do j=njmin_crust_mantle(1,ispec2D),njmax_crust_mantle(1,ispec2D)
          iglob=ibool_crust_mantle(i,j,k,ispec)

          vx=veloc_crust_mantle(1,iglob)
          vy=veloc_crust_mantle(2,iglob)
          vz=veloc_crust_mantle(3,iglob)

          nx=normal_xmin_crust_mantle(1,j,k,ispec2D)
          ny=normal_xmin_crust_mantle(2,j,k,ispec2D)
          nz=normal_xmin_crust_mantle(3,j,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp_crust_mantle(i,j,k,ispec)*vn*nx+rho_vs_crust_mantle(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp_crust_mantle(i,j,k,ispec)*vn*ny+rho_vs_crust_mantle(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp_crust_mantle(i,j,k,ispec)*vn*nz+rho_vs_crust_mantle(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_xmin_crust_mantle(j,k,ispec2D)*wgllwgll_yz(j,k)

          accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
          accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
          accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

          if (SIMULATION_TYPE == 3) then
            b_accel_crust_mantle(:,iglob)=b_accel_crust_mantle(:,iglob) - absorb_xmin_crust_mantle(:,j,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_xmin_crust_mantle(1,j,k,ispec2D) = tx*weight
            absorb_xmin_crust_mantle(2,j,k,ispec2D) = ty*weight
            absorb_xmin_crust_mantle(3,j,k,ispec2D) = tz*weight
          endif
        enddo
      enddo
    enddo

    if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_xmin_crust_mantle > 0 ) &
               write(51,rec=it) reclen_xmin_crust_mantle,absorb_xmin_crust_mantle,reclen_xmin_crust_mantle

  endif

!   xmax
! if two chunks exclude this face for one of them
  if(NCHUNKS_VAL == 1 .or. ichunk == CHUNK_AB) then

    if (SIMULATION_TYPE == 3 .and. nspec2D_xmax_crust_mantle > 0)  then
      read(52,rec=NSTEP-it+1) reclen1,absorb_xmax_crust_mantle,reclen2
      if (reclen1 /= reclen_xmax_crust_mantle .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_xmax')
    endif

    do ispec2D=1,nspec2D_xmax_crust_mantle

      ispec=ibelm_xmax_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_xi_crust_mantle(2,ispec2D) == 0 .or. njmin_crust_mantle(2,ispec2D) == 0) cycle

      i=NGLLX
      do k=nkmin_xi_crust_mantle(2,ispec2D),NGLLZ
        do j=njmin_crust_mantle(2,ispec2D),njmax_crust_mantle(2,ispec2D)
          iglob=ibool_crust_mantle(i,j,k,ispec)

          vx=veloc_crust_mantle(1,iglob)
          vy=veloc_crust_mantle(2,iglob)
          vz=veloc_crust_mantle(3,iglob)

          nx=normal_xmax_crust_mantle(1,j,k,ispec2D)
          ny=normal_xmax_crust_mantle(2,j,k,ispec2D)
          nz=normal_xmax_crust_mantle(3,j,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp_crust_mantle(i,j,k,ispec)*vn*nx+rho_vs_crust_mantle(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp_crust_mantle(i,j,k,ispec)*vn*ny+rho_vs_crust_mantle(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp_crust_mantle(i,j,k,ispec)*vn*nz+rho_vs_crust_mantle(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_xmax_crust_mantle(j,k,ispec2D)*wgllwgll_yz(j,k)

          accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
          accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
          accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

          if (SIMULATION_TYPE == 3) then
            b_accel_crust_mantle(:,iglob)=b_accel_crust_mantle(:,iglob) - absorb_xmax_crust_mantle(:,j,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_xmax_crust_mantle(1,j,k,ispec2D) = tx*weight
            absorb_xmax_crust_mantle(2,j,k,ispec2D) = ty*weight
            absorb_xmax_crust_mantle(3,j,k,ispec2D) = tz*weight
          endif

        enddo
      enddo
    enddo

    if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_xmax_crust_mantle > 0 ) &
               write(52,rec=it) reclen_xmax_crust_mantle,absorb_xmax_crust_mantle,reclen_xmax_crust_mantle

  endif

!   ymin

    if (SIMULATION_TYPE == 3 .and. nspec2D_ymin_crust_mantle > 0)  then
      read(53,rec=NSTEP-it+1) reclen1,absorb_ymin_crust_mantle,reclen2
      if (reclen1 /= reclen_ymin_crust_mantle .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_ymin')
    endif
    do ispec2D=1,nspec2D_ymin_crust_mantle

      ispec=ibelm_ymin_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_eta_crust_mantle(1,ispec2D) == 0 .or. nimin_crust_mantle(1,ispec2D) == 0) cycle

      j=1
      do k=nkmin_eta_crust_mantle(1,ispec2D),NGLLZ
        do i=nimin_crust_mantle(1,ispec2D),nimax_crust_mantle(1,ispec2D)
          iglob=ibool_crust_mantle(i,j,k,ispec)

          vx=veloc_crust_mantle(1,iglob)
          vy=veloc_crust_mantle(2,iglob)
          vz=veloc_crust_mantle(3,iglob)

          nx=normal_ymin_crust_mantle(1,i,k,ispec2D)
          ny=normal_ymin_crust_mantle(2,i,k,ispec2D)
          nz=normal_ymin_crust_mantle(3,i,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp_crust_mantle(i,j,k,ispec)*vn*nx+rho_vs_crust_mantle(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp_crust_mantle(i,j,k,ispec)*vn*ny+rho_vs_crust_mantle(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp_crust_mantle(i,j,k,ispec)*vn*nz+rho_vs_crust_mantle(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_ymin_crust_mantle(i,k,ispec2D)*wgllwgll_xz(i,k)

          accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
          accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
          accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

          if (SIMULATION_TYPE == 3) then
            b_accel_crust_mantle(:,iglob)=b_accel_crust_mantle(:,iglob) - absorb_ymin_crust_mantle(:,i,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_ymin_crust_mantle(1,i,k,ispec2D) = tx*weight
            absorb_ymin_crust_mantle(2,i,k,ispec2D) = ty*weight
            absorb_ymin_crust_mantle(3,i,k,ispec2D) = tz*weight
          endif

        enddo
      enddo
    enddo
    if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_ymin_crust_mantle > 0 ) &
       write(53,rec=it) reclen_ymin_crust_mantle,absorb_ymin_crust_mantle,reclen_ymin_crust_mantle

!   ymax

    if (SIMULATION_TYPE == 3 .and. nspec2D_ymax_crust_mantle > 0)  then
      read(54,rec=NSTEP-it+1) reclen1,absorb_ymax_crust_mantle,reclen2
      if (reclen1 /= reclen_ymax_crust_mantle .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_ymax')
    endif
    do ispec2D=1,nspec2D_ymax_crust_mantle

      ispec=ibelm_ymax_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_eta_crust_mantle(2,ispec2D) == 0 .or. nimin_crust_mantle(2,ispec2D) == 0) cycle

      j=NGLLY
      do k=nkmin_eta_crust_mantle(2,ispec2D),NGLLZ
        do i=nimin_crust_mantle(2,ispec2D),nimax_crust_mantle(2,ispec2D)
          iglob=ibool_crust_mantle(i,j,k,ispec)

          vx=veloc_crust_mantle(1,iglob)
          vy=veloc_crust_mantle(2,iglob)
          vz=veloc_crust_mantle(3,iglob)

          nx=normal_ymax_crust_mantle(1,i,k,ispec2D)
          ny=normal_ymax_crust_mantle(2,i,k,ispec2D)
          nz=normal_ymax_crust_mantle(3,i,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp_crust_mantle(i,j,k,ispec)*vn*nx+rho_vs_crust_mantle(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp_crust_mantle(i,j,k,ispec)*vn*ny+rho_vs_crust_mantle(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp_crust_mantle(i,j,k,ispec)*vn*nz+rho_vs_crust_mantle(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_ymax_crust_mantle(i,k,ispec2D)*wgllwgll_xz(i,k)

          accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
          accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
          accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

          if (SIMULATION_TYPE == 3) then
            b_accel_crust_mantle(:,iglob)=b_accel_crust_mantle(:,iglob) - absorb_ymax_crust_mantle(:,i,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_ymax_crust_mantle(1,i,k,ispec2D) = tx*weight
            absorb_ymax_crust_mantle(2,i,k,ispec2D) = ty*weight
            absorb_ymax_crust_mantle(3,i,k,ispec2D) = tz*weight
          endif

        enddo
      enddo
    enddo
    if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_ymax_crust_mantle > 0 ) &
       write(54,rec=it) reclen_ymax_crust_mantle,absorb_ymax_crust_mantle,reclen_ymax_crust_mantle

  endif ! Stacey conditions

  call compute_forces_inner_core(minus_gravity_table,density_table,minus_deriv_gravity_table, &
          displ_inner_core,accel_inner_core, &
          xstore_inner_core,ystore_inner_core,zstore_inner_core, &
          xix_inner_core,xiy_inner_core,xiz_inner_core, &
          etax_inner_core,etay_inner_core,etaz_inner_core, &
          gammax_inner_core,gammay_inner_core,gammaz_inner_core, &
          hprime_xx,hprime_yy,hprime_zz,hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
          wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube, &
          kappavstore_inner_core,muvstore_inner_core,ibool_inner_core,idoubling_inner_core, &
          c11store_inner_core,c33store_inner_core,c12store_inner_core,c13store_inner_core,c44store_inner_core, &
          R_memory_inner_core,epsilondev_inner_core, eps_trace_over_3_inner_core,&
          one_minus_sum_beta_inner_core, &
          alphaval,betaval,gammaval, &
          factor_common_inner_core, &
          size(factor_common_inner_core,2), size(factor_common_inner_core,3), &
          size(factor_common_inner_core,4), size(factor_common_inner_core,5),SAVE_STRAIN,AM_V)

  if (SIMULATION_TYPE == 3) then
  call compute_forces_inner_core(minus_gravity_table,density_table,minus_deriv_gravity_table, &
          b_displ_inner_core,b_accel_inner_core, &
          xstore_inner_core,ystore_inner_core,zstore_inner_core, &
          xix_inner_core,xiy_inner_core,xiz_inner_core, &
          etax_inner_core,etay_inner_core,etaz_inner_core, &
          gammax_inner_core,gammay_inner_core,gammaz_inner_core, &
          hprime_xx,hprime_yy,hprime_zz,hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
          wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube, &
          kappavstore_inner_core,muvstore_inner_core,ibool_inner_core,idoubling_inner_core, &
          c11store_inner_core,c33store_inner_core,c12store_inner_core,c13store_inner_core,c44store_inner_core, &
          b_R_memory_inner_core,b_epsilondev_inner_core, b_eps_trace_over_3_inner_core,&
          one_minus_sum_beta_inner_core, &
          b_alphaval,b_betaval,b_gammaval, &
          factor_common_inner_core, &
          size(factor_common_inner_core,2), size(factor_common_inner_core,3), &
          size(factor_common_inner_core,4), size(factor_common_inner_core,5),SAVE_STRAIN,AM_V)
  endif

! add the sources
  if (SIMULATION_TYPE == 1) then
  do isource = 1,NSOURCES

! add only if this proc carries the source
    if(myrank == islice_selected_source(isource)) then

      stf = comp_source_time_function(dble(it-1)*DT-t0-t_cmt(isource),hdur_gaussian(isource))

!     distinguish between single and double precision for reals
      if(CUSTOM_REAL == SIZE_REAL) then
        stf_used = sngl(stf)
      else
        stf_used = stf
      endif

!     add source array
      do k=1,NGLLZ
        do j=1,NGLLY
          do i=1,NGLLX
            iglob = ibool_crust_mantle(i,j,k,ispec_selected_source(isource))
            accel_crust_mantle(:,iglob) = accel_crust_mantle(:,iglob) + sourcearrays(isource,:,i,j,k)*stf_used
          enddo
        enddo
      enddo

    endif

  enddo
  endif

  if (SIMULATION_TYPE == 2 .or. SIMULATION_TYPE == 3) then
! figure out if we need to read in a chunk of the adjoint source at this timestep
        it_sub_adj = ceiling( dble(it)/dble(NTSTEP_BETWEEN_READ_ADJSRC) )   !chunk_number
        ibool_read_adj_arrays = (((it == it_begin) .or. (mod(it-1,NTSTEP_BETWEEN_READ_ADJSRC) == 0)) .and. (nadj_rec_local > 0))

        if(ibool_read_adj_arrays) then
           irec_local = 0
           do irec = 1, nrec
! check that the source slice number is okay
              if(islice_selected_rec(irec) < 0 .or. islice_selected_rec(irec) > NPROCTOT-1) then
                 if(islice_selected_rec(irec) < 0) call exit_MPI(myrank,'islice < 0')
                 if(islice_selected_rec(irec) > NPROCTOT-1) call exit_MPI(myrank,'islice > NPROCTOT-1')
                 call exit_MPI(myrank,'now: something is wrong with the source slice number in adjoint simulation')
              endif
! compute source arrays
              if(myrank == islice_selected_rec(irec)) then
                 irec_local = irec_local + 1
                 adj_source_file = trim(station_name(irec))//'.'//trim(network_name(irec))
                 call comp_subarrays_adjoint_src(myrank,adj_source_file, &
                      xi_receiver(irec),eta_receiver(irec),gamma_receiver(irec), &
                      nu(:,:,irec),adj_sourcearray, xigll,yigll,zigll,iadjsrc_len(it_sub_adj), &
                      iadjsrc,it_sub_adj,NSTEP_SUB_ADJ,NTSTEP_BETWEEN_READ_ADJSRC)
                 adj_sourcearrays(irec_local,:,:,:,:,:) = adj_sourcearray(:,:,:,:,:)
              endif
           enddo
           if(irec_local /= nadj_rec_local) &
                call exit_MPI(myrank,'irec_local /= nadj_rec_local in adjoint simulation')
        endif

    irec_local = 0
    do irec = 1,nrec
!

!   add the source (only if this proc carries the source)
      if(myrank == islice_selected_rec(irec)) then
        irec_local = irec_local + 1

!     add source array
        do k=1,NGLLZ
          do j=1,NGLLY
            do i=1,NGLLX
              iglob = ibool_crust_mantle(i,j,k,ispec_selected_rec(irec))
              accel_crust_mantle(:,iglob) = accel_crust_mantle(:,iglob) + adj_sourcearrays(irec_local,iadj_vec(it),:,i,j,k)
            enddo
          enddo
        enddo
      endif

    enddo

  endif

  if (SIMULATION_TYPE == 3) then
  do isource = 1,NSOURCES

!   add the source (only if this proc carries the source)
    if(myrank == islice_selected_source(isource)) then

      stf = comp_source_time_function(dble(NSTEP-it+1)*DT-t0-t_cmt(isource),hdur_gaussian(isource))

!     distinguish between single and double precision for reals
      if(CUSTOM_REAL == SIZE_REAL) then
        stf_used = sngl(stf)
      else
        stf_used = stf
      endif

!     add source array
      do k=1,NGLLZ
        do j=1,NGLLY
          do i=1,NGLLX
            iglob = ibool_crust_mantle(i,j,k,ispec_selected_source(isource))
            b_accel_crust_mantle(:,iglob) = b_accel_crust_mantle(:,iglob) + sourcearrays(isource,:,i,j,k)*stf_used
          enddo
        enddo
      enddo

    endif

  enddo
  endif



! ****************************************************
! **********  add matching with fluid part  **********
! ****************************************************

! only for elements in first matching layer in the solid

!---
!--- couple with outer core at the bottom of the mantle
!---

  if(ACTUALLY_COUPLE_FLUID_CMB) then

! for surface elements exactly on the CMB
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_CRUST_MANTLE)

      ispec = ibelm_bottom_crust_mantle(ispec2D)

! only for DOFs exactly on the CMB (bottom of these elements)
      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX

! get velocity potential on the fluid side using pointwise matching
          ispec_selected = ibelm_top_outer_core(ispec2D)
          k_corresp = NGLLZ

! get normal at the CMB
          nx = normal_top_outer_core(1,i,j,ispec2D)
          ny = normal_top_outer_core(2,i,j,ispec2D)
          nz = normal_top_outer_core(3,i,j,ispec2D)

! get global point number
! corresponding points are located at the top of the outer core
          iglob = ibool_outer_core(i,j,NGLLZ,ispec_selected)
          iglob_mantle = ibool_crust_mantle(i,j,k,ispec)

! compute pressure, taking gravity into account
          if(GRAVITY_VAL) then
            pressure = RHO_TOP_OC * (- accel_outer_core(iglob) &
               + minus_g_cmb *(displ_crust_mantle(1,iglob_mantle)*nx &
               + displ_crust_mantle(2,iglob_mantle)*ny + displ_crust_mantle(3,iglob_mantle)*nz))
          else
            pressure = - RHO_TOP_OC * accel_outer_core(iglob)
          endif

! formulation with generalized potential
          weight = jacobian2D_top_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel_crust_mantle(1,iglob_mantle) = accel_crust_mantle(1,iglob_mantle) + weight*nx*pressure
          accel_crust_mantle(2,iglob_mantle) = accel_crust_mantle(2,iglob_mantle) + weight*ny*pressure
          accel_crust_mantle(3,iglob_mantle) = accel_crust_mantle(3,iglob_mantle) + weight*nz*pressure

          if (SIMULATION_TYPE == 3) then
          if(GRAVITY_VAL) then
            pressure = RHO_TOP_OC * (- b_accel_outer_core(iglob) &
               + minus_g_cmb *(b_displ_crust_mantle(1,iglob_mantle)*nx &
               + b_displ_crust_mantle(2,iglob_mantle)*ny + b_displ_crust_mantle(3,iglob_mantle)*nz))
          else
            pressure = - RHO_TOP_OC * b_accel_outer_core(iglob)
          endif
          b_accel_crust_mantle(1,iglob_mantle) = b_accel_crust_mantle(1,iglob_mantle) + weight*nx*pressure
          b_accel_crust_mantle(2,iglob_mantle) = b_accel_crust_mantle(2,iglob_mantle) + weight*ny*pressure
          b_accel_crust_mantle(3,iglob_mantle) = b_accel_crust_mantle(3,iglob_mantle) + weight*nz*pressure
          endif

        enddo
      enddo
    enddo

  endif

!---
!--- couple with outer core at the top of the inner core
!---

  if(ACTUALLY_COUPLE_FLUID_ICB .and. NCHUNKS_VAL == 6) then

! for surface elements exactly on the ICB
    do ispec2D = 1,NSPEC2D_TOP(IREGION_INNER_CORE)

      ispec = ibelm_top_inner_core(ispec2D)

! only for DOFs exactly on the ICB (top of these elements)
      k = NGLLZ
      do j = 1,NGLLY
        do i = 1,NGLLX

! get velocity potential on the fluid side using pointwise matching
          ispec_selected = ibelm_bottom_outer_core(ispec2D)
          k_corresp = 1

! get normal at the ICB
          nx = normal_bottom_outer_core(1,i,j,ispec2D)
          ny = normal_bottom_outer_core(2,i,j,ispec2D)
          nz = normal_bottom_outer_core(3,i,j,ispec2D)

! get global point number
! corresponding points are located at the bottom of the outer core
          iglob = ibool_outer_core(i,j,k_corresp,ispec_selected)
          iglob_inner_core = ibool_inner_core(i,j,k,ispec)

! compute pressure, taking gravity into account
          if(GRAVITY_VAL) then
            pressure = RHO_BOTTOM_OC * (- accel_outer_core(iglob) &
               + minus_g_icb *(displ_inner_core(1,iglob_inner_core)*nx &
               + displ_inner_core(2,iglob_inner_core)*ny + displ_inner_core(3,iglob_inner_core)*nz))
          else
            pressure = - RHO_BOTTOM_OC * accel_outer_core(iglob)
          endif

! formulation with generalized potential
          weight = jacobian2D_bottom_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel_inner_core(1,iglob_inner_core) = accel_inner_core(1,iglob_inner_core) - weight*nx*pressure
          accel_inner_core(2,iglob_inner_core) = accel_inner_core(2,iglob_inner_core) - weight*ny*pressure
          accel_inner_core(3,iglob_inner_core) = accel_inner_core(3,iglob_inner_core) - weight*nz*pressure

          if (SIMULATION_TYPE == 3) then
          if(GRAVITY_VAL) then
            pressure = RHO_BOTTOM_OC * (- b_accel_outer_core(iglob) &
               + minus_g_cmb *(b_displ_inner_core(1,iglob_inner_core)*nx &
               + b_displ_inner_core(2,iglob_inner_core)*ny + b_displ_inner_core(3,iglob_inner_core)*nz))
          else
            pressure = - RHO_BOTTOM_OC * b_accel_outer_core(iglob)
          endif
          b_accel_inner_core(1,iglob_inner_core) = b_accel_inner_core(1,iglob_inner_core) - weight*nx*pressure
          b_accel_inner_core(2,iglob_inner_core) = b_accel_inner_core(2,iglob_inner_core) - weight*ny*pressure
          b_accel_inner_core(3,iglob_inner_core) = b_accel_inner_core(3,iglob_inner_core) - weight*nz*pressure
          endif

        enddo
      enddo
    enddo

    endif

! assemble all the contributions between slices using MPI

! crust/mantle and inner core handled in the same call
! in order to reduce the number of MPI messages by 2
  call assemble_MPI_vector(myrank, &
!!!!!!!!!!!!!!!!!!!!!!
            accel_crust_mantle,NGLOB_CRUST_MANTLE, &
            accel_inner_core,NGLOB_INNER_CORE, &
!!!!!!!!!!!!!!!!!!!!!!
            iproc_xi,iproc_eta,ichunk,addressing, &
!!!!!!!!!!!!!!!!!!!!!!
            iboolleft_xi_crust_mantle,iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
            npoin2D_faces_crust_mantle,npoin2D_xi_crust_mantle(1),npoin2D_eta_crust_mantle(1), &
            iboolfaces_crust_mantle,iboolcorner_crust_mantle, &
            iboolleft_xi_inner_core,iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core, &
            npoin2D_faces_inner_core,npoin2D_xi_inner_core(1),npoin2D_eta_inner_core(1), &
            iboolfaces_inner_core,iboolcorner_inner_core, &
!!!!!!!!!!!!!!!!!!!!!!
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_vector,buffer_received_faces_vector, &
            buffer_send_chunkcorners_vector,buffer_recv_chunkcorners_vector, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA, &
!!!!!!!!!!!!!!!!!!!!!!
            NGLOB1D_RADIAL(IREGION_CRUST_MANTLE), &
            NGLOB2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NGLOB2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE), &
            NGLOB1D_RADIAL(IREGION_INNER_CORE), &
            NGLOB2DMAX_XMIN_XMAX(IREGION_INNER_CORE),NGLOB2DMAX_YMIN_YMAX(IREGION_INNER_CORE), &
!!!!!!!!!!!!!!!!!!!!!!
            NGLOB2DMAX_XY,NCHUNKS)

!---
!---  use buffers to assemble forces with the central cube
!---

  if(INCLUDE_CENTRAL_CUBE) then

   call assemble_MPI_central_cube(ichunk,nb_msgs_theor_in_cube, sender_from_slices_to_cube, &
     npoin2D_cube_from_slices, buffer_all_cube_from_slices, buffer_slices, ibool_central_cube, &
     receiver_cube_from_slices, ibool_inner_core, idoubling_inner_core, NSPEC_INNER_CORE, &
     ibelm_bottom_inner_core, NSPEC2D_BOTTOM(IREGION_INNER_CORE),NGLOB_INNER_CORE,accel_inner_core,NDIM)

  endif   ! end of assembling forces with the central cube

  do i=1,NGLOB_CRUST_MANTLE
    accel_crust_mantle(1,i) = accel_crust_mantle(1,i)*rmass_crust_mantle(i) &
               + two_omega_earth*veloc_crust_mantle(2,i)
    accel_crust_mantle(2,i) = accel_crust_mantle(2,i)*rmass_crust_mantle(i) &
               - two_omega_earth*veloc_crust_mantle(1,i)
    accel_crust_mantle(3,i) = accel_crust_mantle(3,i)*rmass_crust_mantle(i)
  enddo

  if (SIMULATION_TYPE == 3) then

! assemble all the contributions between slices using MPI

! crust/mantle and inner core handled in the same call
! in order to reduce the number of MPI messages by 2
  call assemble_MPI_vector(myrank, &
!!!!!!!!!!!!!!!!!!!!!!
            b_accel_crust_mantle,NGLOB_CRUST_MANTLE, &
            b_accel_inner_core,NGLOB_INNER_CORE, &
!!!!!!!!!!!!!!!!!!!!!!
            iproc_xi,iproc_eta,ichunk,addressing, &
!!!!!!!!!!!!!!!!!!!!!!
            iboolleft_xi_crust_mantle,iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
            npoin2D_faces_crust_mantle,npoin2D_xi_crust_mantle(1),npoin2D_eta_crust_mantle(1), &
            iboolfaces_crust_mantle,iboolcorner_crust_mantle, &
            iboolleft_xi_inner_core,iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core, &
            npoin2D_faces_inner_core,npoin2D_xi_inner_core(1),npoin2D_eta_inner_core(1), &
            iboolfaces_inner_core,iboolcorner_inner_core, &
!!!!!!!!!!!!!!!!!!!!!!
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_vector,buffer_received_faces_vector, &
            buffer_send_chunkcorners_vector,buffer_recv_chunkcorners_vector, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA, &
!!!!!!!!!!!!!!!!!!!!!!
            NGLOB1D_RADIAL(IREGION_CRUST_MANTLE), &
            NGLOB2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NGLOB2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE), &
            NGLOB1D_RADIAL(IREGION_INNER_CORE), &
            NGLOB2DMAX_XMIN_XMAX(IREGION_INNER_CORE),NGLOB2DMAX_YMIN_YMAX(IREGION_INNER_CORE), &
!!!!!!!!!!!!!!!!!!!!!!
            NGLOB2DMAX_XY,NCHUNKS)

!---
!---  use buffers to assemble forces with the central cube
!---

  if(INCLUDE_CENTRAL_CUBE) then

   call assemble_MPI_central_cube(ichunk,nb_msgs_theor_in_cube, sender_from_slices_to_cube, &
     npoin2D_cube_from_slices, buffer_all_cube_from_slices, buffer_slices, ibool_central_cube, &
     receiver_cube_from_slices, ibool_inner_core, idoubling_inner_core, NSPEC_INNER_CORE, &
     ibelm_bottom_inner_core, NSPEC2D_BOTTOM(IREGION_INNER_CORE),NGLOB_INNER_CORE,b_accel_inner_core,NDIM)

  endif   ! end of assembling forces with the central cube

  do i=1,NGLOB_CRUST_MANTLE
    b_accel_crust_mantle(1,i) = b_accel_crust_mantle(1,i)*rmass_crust_mantle(i) &
               + b_two_omega_earth*b_veloc_crust_mantle(2,i)
    b_accel_crust_mantle(2,i) = b_accel_crust_mantle(2,i)*rmass_crust_mantle(i) &
               - b_two_omega_earth*b_veloc_crust_mantle(1,i)
    b_accel_crust_mantle(3,i) = b_accel_crust_mantle(3,i)*rmass_crust_mantle(i)
  enddo

  endif

  if(OCEANS) then

!   initialize the updates
    updated_dof_ocean_load(:) = .false.

! for surface elements exactly at the top of the crust (ocean bottom)
    do ispec2D = 1,NSPEC2D_TOP(IREGION_CRUST_MANTLE)

      ispec = ibelm_top_crust_mantle(ispec2D)

! only for DOFs exactly at the top of the crust (ocean bottom)
      k = NGLLZ

      do j = 1,NGLLY
        do i = 1,NGLLX

! get global point number
          iglob = ibool_crust_mantle(i,j,k,ispec)

! only update once
          if(.not. updated_dof_ocean_load(iglob)) then

! get normal
            nx = normal_top_crust_mantle(1,i,j,ispec2D)
            ny = normal_top_crust_mantle(2,i,j,ispec2D)
            nz = normal_top_crust_mantle(3,i,j,ispec2D)

! make updated component of right-hand side
! we divide by rmass_crust_mantle() which is 1 / M
! we use the total force which includes the Coriolis term above
            force_normal_comp = (accel_crust_mantle(1,iglob)*nx + &
                 accel_crust_mantle(2,iglob)*ny + &
                 accel_crust_mantle(3,iglob)*nz) / rmass_crust_mantle(iglob)

            additional_term = (rmass_ocean_load(iglob) - rmass_crust_mantle(iglob)) * force_normal_comp

            accel_crust_mantle(1,iglob) = accel_crust_mantle(1,iglob) + additional_term * nx
            accel_crust_mantle(2,iglob) = accel_crust_mantle(2,iglob) + additional_term * ny
            accel_crust_mantle(3,iglob) = accel_crust_mantle(3,iglob) + additional_term * nz

            if (SIMULATION_TYPE == 3) then
              b_force_normal_comp = (b_accel_crust_mantle(1,iglob)*nx + &
                 b_accel_crust_mantle(2,iglob)*ny + &
                 b_accel_crust_mantle(3,iglob)*nz) / rmass_crust_mantle(iglob)

              b_additional_term = (rmass_ocean_load(iglob) - rmass_crust_mantle(iglob)) * b_force_normal_comp

              b_accel_crust_mantle(1,iglob) = b_accel_crust_mantle(1,iglob) + b_additional_term * nx
              b_accel_crust_mantle(2,iglob) = b_accel_crust_mantle(2,iglob) + b_additional_term * ny
              b_accel_crust_mantle(3,iglob) = b_accel_crust_mantle(3,iglob) + b_additional_term * nz
            endif

!           done with this point
            updated_dof_ocean_load(iglob) = .true.

          endif

        enddo
      enddo
    enddo
  endif

  do i=1,NGLOB_CRUST_MANTLE
    veloc_crust_mantle(:,i) = veloc_crust_mantle(:,i) + deltatover2*accel_crust_mantle(:,i)
  enddo

  do i=1,NGLOB_INNER_CORE
    accel_inner_core(1,i) = accel_inner_core(1,i)*rmass_inner_core(i) &
             + two_omega_earth*veloc_inner_core(2,i)
    accel_inner_core(2,i) = accel_inner_core(2,i)*rmass_inner_core(i) &
             - two_omega_earth*veloc_inner_core(1,i)
    accel_inner_core(3,i) = accel_inner_core(3,i)*rmass_inner_core(i)

    veloc_inner_core(:,i) = veloc_inner_core(:,i) + deltatover2*accel_inner_core(:,i)
  enddo

  if (SIMULATION_TYPE == 3) then
    do i=1,NGLOB_CRUST_MANTLE
      b_veloc_crust_mantle(:,i) = b_veloc_crust_mantle(:,i) + b_deltatover2*b_accel_crust_mantle(:,i)
    enddo
    do i=1,NGLOB_INNER_CORE
      b_accel_inner_core(1,i) = b_accel_inner_core(1,i)*rmass_inner_core(i) &
         + b_two_omega_earth*b_veloc_inner_core(2,i)
      b_accel_inner_core(2,i) = b_accel_inner_core(2,i)*rmass_inner_core(i) &
         - b_two_omega_earth*b_veloc_inner_core(1,i)
      b_accel_inner_core(3,i) = b_accel_inner_core(3,i)*rmass_inner_core(i)

      b_veloc_inner_core(:,i) = b_veloc_inner_core(:,i) + b_deltatover2*b_accel_inner_core(:,i)
    enddo
  endif

! write the seismograms with time shift

! store the seismograms only if there is at least one receiver located in this slice
  if (nrec_local > 0) then

  do irec_local = 1,nrec_local

! get global number of that receiver
    irec = number_receiver_global(irec_local)

! perform the general interpolation using Lagrange polynomials
    uxd = ZERO
    uyd = ZERO
    uzd = ZERO

    if (SIMULATION_TYPE == 1) then
      do k = 1,NGLLZ
        do j = 1,NGLLY
          do i = 1,NGLLX

            iglob = ibool_crust_mantle(i,j,k,ispec_selected_rec(irec))

            hlagrange = hxir_store(irec_local,i)*hetar_store(irec_local,j)*hgammar_store(irec_local,k)

            uxd = uxd + dble(displ_crust_mantle(1,iglob))*hlagrange
            uyd = uyd + dble(displ_crust_mantle(2,iglob))*hlagrange
            uzd = uzd + dble(displ_crust_mantle(3,iglob))*hlagrange

          enddo
        enddo
      enddo
! store North, East and Vertical components

! distinguish between single and double precision for reals
      if(CUSTOM_REAL == SIZE_REAL) then
        seismograms(:,irec_local,seismo_current) = sngl(scale_displ*(nu(:,1,irec)*uxd + &
                   nu(:,2,irec)*uyd + nu(:,3,irec)*uzd))
      else
        seismograms(:,irec_local,seismo_current) = scale_displ*(nu(:,1,irec)*uxd + &
                   nu(:,2,irec)*uyd + nu(:,3,irec)*uzd)
      endif

    else if (SIMULATION_TYPE == 2) then

      eps_trace = ZERO
      dxx = ZERO
      dyy = ZERO
      dxy = ZERO
      dxz = ZERO
      dyz = ZERO

      do k = 1,NGLLZ
        do j = 1,NGLLY
          do i = 1,NGLLX

            iglob = ibool_crust_mantle(i,j,k,ispec_selected_source(irec))

            hlagrange = hxir_store(irec_local,i)*hetar_store(irec_local,j)*hgammar_store(irec_local,k)

            uxd = uxd + dble(displ_crust_mantle(1,iglob))*hlagrange
            uyd = uyd + dble(displ_crust_mantle(2,iglob))*hlagrange
            uzd = uzd + dble(displ_crust_mantle(3,iglob))*hlagrange

            eps_trace = eps_trace + dble(eps_trace_over_3_crust_mantle(i,j,k,ispec_selected_source(irec)))*hlagrange
            dxx = dxx + dble(epsilondev_crust_mantle(1,i,j,k,ispec_selected_source(irec)))*hlagrange
            dyy = dyy + dble(epsilondev_crust_mantle(2,i,j,k,ispec_selected_source(irec)))*hlagrange
            dxy = dxy + dble(epsilondev_crust_mantle(3,i,j,k,ispec_selected_source(irec)))*hlagrange
            dxz = dxz + dble(epsilondev_crust_mantle(4,i,j,k,ispec_selected_source(irec)))*hlagrange
            dyz = dyz + dble(epsilondev_crust_mantle(5,i,j,k,ispec_selected_source(irec)))*hlagrange

          enddo
        enddo
      enddo

      eps_loc(1,1) = eps_trace + dxx
      eps_loc(2,2) = eps_trace + dyy
      eps_loc(3,3) = eps_trace - dxx - dyy
      eps_loc(1,2) = dxy
      eps_loc(1,3) = dxz
      eps_loc(2,3) = dyz
      eps_loc(2,1) = dxy
      eps_loc(3,1) = dxz
      eps_loc(3,2) = dyz

      eps_loc_new(:,:) = eps_loc(:,:)
! LQY -- rotate to the local cartesian coordinates (e-n-z)
      eps_loc_new(:,:) = matmul(matmul(nu_source(:,:,irec),eps_loc(:,:)), transpose(nu_source(:,:,irec)))

! distinguish between single and double precision for reals
      if (CUSTOM_REAL == SIZE_REAL) then
        seismograms(1,irec_local,it-nit_written) = sngl(eps_loc_new(1,1))
        seismograms(2,irec_local,it-nit_written) = sngl(eps_loc_new(2,2))
        seismograms(3,irec_local,it-nit_written) = sngl(eps_loc_new(3,3))
        seismograms(4,irec_local,it-nit_written) = sngl(eps_loc_new(1,2))
        seismograms(5,irec_local,it-nit_written) = sngl(eps_loc_new(1,3))
        seismograms(6,irec_local,it-nit_written) = sngl(eps_loc_new(2,3))
        seismograms(7:9,irec_local,it-nit_written) = sngl(scale_displ*(nu_source(:,1,irec)*uxd + &
                    nu_source(:,2,irec)*uyd + nu_source(:,3,irec)*uzd))
     else
        seismograms(1,irec_local,it-nit_written) = eps_loc_new(1,1)
        seismograms(2,irec_local,it-nit_written) = eps_loc_new(2,2)
        seismograms(3,irec_local,it-nit_written) = eps_loc_new(3,3)
        seismograms(4,irec_local,it-nit_written) = eps_loc_new(1,2)
        seismograms(5,irec_local,it-nit_written) = eps_loc_new(1,3)
        seismograms(6,irec_local,it-nit_written) = eps_loc_new(2,3)
        seismograms(7:9,irec_local,it-nit_written) = scale_displ*(nu_source(:,1,irec)*uxd + &
                    nu_source(:,2,irec)*uyd + nu_source(:,3,irec)*uzd)
      endif

    else  if (SIMULATION_TYPE == 3) then

      do k = 1,NGLLZ
        do j = 1,NGLLY
          do i = 1,NGLLX

            iglob = ibool_crust_mantle(i,j,k,ispec_selected_rec(irec))

            hlagrange = hxir_store(irec_local,i)*hetar_store(irec_local,j)*hgammar_store(irec_local,k)

            uxd = uxd + dble(b_displ_crust_mantle(1,iglob))*hlagrange
            uyd = uyd + dble(b_displ_crust_mantle(2,iglob))*hlagrange
            uzd = uzd + dble(b_displ_crust_mantle(3,iglob))*hlagrange

          enddo
        enddo
        enddo
! store North, East and Vertical components

! distinguish between single and double precision for reals
        if(CUSTOM_REAL == SIZE_REAL) then
          seismograms(:,irec_local,seismo_current) = sngl(scale_displ*(nu(:,1,irec)*uxd + &
             nu(:,2,irec)*uyd + nu(:,3,irec)*uzd))
        else
          seismograms(:,irec_local,seismo_current) = scale_displ*(nu(:,1,irec)*uxd + &
             nu(:,2,irec)*uyd + nu(:,3,irec)*uzd)
        endif

      endif

    enddo

  endif ! nrec_local

! write the current seismograms
  if(seismo_current == NTSTEP_BETWEEN_OUTPUT_SEISMOS) then
    if (SIMULATION_TYPE == 1 .or. SIMULATION_TYPE == 3) then
        call write_seismograms(myrank,seismograms,number_receiver_global,station_name, &
              network_name,stlat,stlon,stele,nrec,nrec_local,DT,t0,it_end, &
              yr_SAC,jda_SAC,ho_SAC,mi_SAC,sec_SAC,t_cmt_SAC, &
              elat_SAC,elon_SAC,depth_SAC,mb_SAC,ename_SAC,cmt_lat_SAC,cmt_lon_SAC,&
              cmt_depth_SAC,cmt_hdur_SAC,NSOURCES_SAC,NPROCTOT, &
              OUTPUT_SEISMOS_ASCII_TEXT,OUTPUT_SEISMOS_SAC_ALPHANUM, &
              OUTPUT_SEISMOS_SAC_BINARY,ROTATE_SEISMOGRAMS_RT,NTSTEP_BETWEEN_OUTPUT_SEISMOS, &
              seismo_offset,seismo_current,WRITE_SEISMOGRAMS_BY_MASTER, &
              SAVE_ALL_SEISMOS_IN_ONE_FILE,USE_BINARY_FOR_LARGE_FILE)
    if(myrank==0) write(IMAIN,*)
    if(myrank==0) write(IMAIN,*) ' Total number of time steps written: ', it-it_begin
    if(myrank==0) write(IMAIN,*)
    else
      call write_adj_seismograms(seismograms,number_receiver_global, &
        nrec_local,it,nit_written,DT,NSTEP,NTSTEP_BETWEEN_OUTPUT_SEISMOS,t0,LOCAL_PATH)
        nit_written = it
    endif
    seismo_offset = seismo_offset + seismo_current
    seismo_current = 0
  endif

! kernel calculations
  if (SIMULATION_TYPE == 3) then

! crust_mantle
    do ispec = 1, NSPEC_CRUST_MANTLE
      do k = 1, NGLLZ
        do j = 1, NGLLY
          do i = 1, NGLLX
            iglob = ibool_crust_mantle(i,j,k,ispec)

            rho_kl_crust_mantle(i,j,k,ispec) =  rho_kl_crust_mantle(i,j,k,ispec) &
               + deltat * (accel_crust_mantle(1,iglob) * b_displ_crust_mantle(1,iglob) &
               + accel_crust_mantle(2,iglob) * b_displ_crust_mantle(2,iglob) &
               + accel_crust_mantle(3,iglob) * b_displ_crust_mantle(3,iglob) )

            epsilondev_loc(:) = epsilondev_crust_mantle(:,i,j,k,ispec)
            b_epsilondev_loc(:) = b_epsilondev_crust_mantle(:,i,j,k,ispec)
            beta_kl_crust_mantle(i,j,k,ispec) =  beta_kl_crust_mantle(i,j,k,ispec) &
               + deltat * (epsilondev_loc(1)*b_epsilondev_loc(1) + epsilondev_loc(2)*b_epsilondev_loc(2) &
               + (epsilondev_loc(1)+epsilondev_loc(2)) * (b_epsilondev_loc(1)+b_epsilondev_loc(2)) &
                + 2 * (epsilondev_loc(3)*b_epsilondev_loc(3) + epsilondev_loc(4)*b_epsilondev_loc(4) + &
                epsilondev_loc(5)*b_epsilondev_loc(5)) )

            alpha_kl_crust_mantle(i,j,k,ispec) = alpha_kl_crust_mantle(i,j,k,ispec) &
               + deltat * (9 * eps_trace_over_3_crust_mantle(i,j,k,ispec) * b_eps_trace_over_3_crust_mantle(i,j,k,ispec))
          enddo
        enddo
      enddo
    enddo

! outer_core -- compute the actual displacement and acceleration (NDIM,NGLOBMAX_OUTER_CORE)
    do ispec = 1, NSPEC_OUTER_CORE
      do k = 1, NGLLZ
        do j = 1, NGLLY
          do i = 1, NGLLX
            iglob = ibool_outer_core(i,j,k,ispec)

            xixl = xix_outer_core(i,j,k,ispec)
            xiyl = xiy_outer_core(i,j,k,ispec)
            xizl = xiz_outer_core(i,j,k,ispec)
            etaxl = etax_outer_core(i,j,k,ispec)
            etayl = etay_outer_core(i,j,k,ispec)
            etazl = etaz_outer_core(i,j,k,ispec)
            gammaxl = gammax_outer_core(i,j,k,ispec)
            gammayl = gammay_outer_core(i,j,k,ispec)
            gammazl = gammaz_outer_core(i,j,k,ispec)

            tempx1l = 0._CUSTOM_REAL
            tempx2l = 0._CUSTOM_REAL
            tempx3l = 0._CUSTOM_REAL

            do l=1,NGLLX
              tempx1l = tempx1l + b_displ_outer_core(ibool_outer_core(l,j,k,ispec)) * hprime_xx(i,l)
            enddo

            do l=1,NGLLY
              tempx2l = tempx2l + b_displ_outer_core(ibool_outer_core(i,l,k,ispec)) * hprime_yy(j,l)
            enddo

            do l=1,NGLLZ
              tempx3l = tempx3l +  b_displ_outer_core(ibool_outer_core(i,j,l,ispec)) * hprime_zz(k,l)
            enddo

            b_vector_displ_outer_core(1,iglob) = xixl*tempx1l + etaxl*tempx2l + gammaxl*tempx3l
            b_vector_displ_outer_core(2,iglob) = xiyl*tempx1l + etayl*tempx2l + gammayl*tempx3l
            b_vector_displ_outer_core(3,iglob) = xizl*tempx1l + etazl*tempx2l + gammazl*tempx3l

            tempx1l = 0._CUSTOM_REAL
            tempx2l = 0._CUSTOM_REAL
            tempx3l = 0._CUSTOM_REAL

            do l=1,NGLLX
              tempx1l = tempx1l + accel_outer_core(ibool_outer_core(l,j,k,ispec)) * hprime_xx(i,l)
            enddo

            do l=1,NGLLY
              tempx2l = tempx2l + accel_outer_core(ibool_outer_core(i,l,k,ispec)) * hprime_yy(j,l)
            enddo

            do l=1,NGLLZ
              tempx3l = tempx3l + accel_outer_core(ibool_outer_core(i,j,l,ispec)) * hprime_zz(k,l)
            enddo

            vector_accel_outer_core(1,iglob) = xixl*tempx1l + etaxl*tempx2l + gammaxl*tempx3l
            vector_accel_outer_core(2,iglob) = xiyl*tempx1l + etayl*tempx2l + gammayl*tempx3l
            vector_accel_outer_core(3,iglob) = xizl*tempx1l + etazl*tempx2l + gammazl*tempx3l

            tempx1l = 0._CUSTOM_REAL
            tempx2l = 0._CUSTOM_REAL
            tempx3l = 0._CUSTOM_REAL

            do l=1,NGLLX
              tempx1l = tempx1l + displ_outer_core(ibool_outer_core(l,j,k,ispec)) * hprime_xx(i,l)
            enddo

            do l=1,NGLLY
              tempx2l = tempx2l + displ_outer_core(ibool_outer_core(i,l,k,ispec)) * hprime_yy(j,l)
            enddo

            do l=1,NGLLZ
              tempx3l = tempx3l + displ_outer_core(ibool_outer_core(i,j,l,ispec)) * hprime_zz(k,l)
            enddo

            vector_displ_outer_core(1,iglob) = xixl*tempx1l + etaxl*tempx2l + gammaxl*tempx3l
            vector_displ_outer_core(2,iglob) = xiyl*tempx1l + etayl*tempx2l + gammayl*tempx3l
            vector_displ_outer_core(3,iglob) = xizl*tempx1l + etazl*tempx2l + gammazl*tempx3l

            rho_kl_outer_core(i,j,k,ispec) = rho_kl_outer_core(i,j,k,ispec) &
               + deltat * dot_product(vector_accel_outer_core(:,iglob), b_vector_displ_outer_core(:,iglob))

            kappal = rhostore_outer_core(i,j,k,ispec)/kappavstore_outer_core(i,j,k,ispec)
            div_displ_outer_core(i,j,k,ispec) = div_displ_outer_core(i,j,k,ispec) + kappal * accel_outer_core(iglob)
            b_div_displ_outer_core(i,j,k,ispec) = b_div_displ_outer_core(i,j,k,ispec) + kappal * b_accel_outer_core(iglob)

            alpha_kl_outer_core(i,j,k,ispec) = alpha_kl_outer_core(i,j,k,ispec) &
               + deltat * div_displ_outer_core(i,j,k,ispec) * b_div_displ_outer_core(i,j,k,ispec)

          enddo
        enddo
      enddo
    enddo

! inner_core
    do ispec = 1, NSPEC_INNER_CORE
      do k = 1, NGLLZ
        do j = 1, NGLLY
          do i = 1, NGLLX
            iglob = ibool_inner_core(i,j,k,ispec)

            rho_kl_inner_core(i,j,k,ispec) =  rho_kl_inner_core(i,j,k,ispec) &
               + deltat * (accel_inner_core(1,iglob) * b_displ_inner_core(1,iglob) &
               + accel_inner_core(2,iglob) * b_displ_inner_core(2,iglob) &
               + accel_inner_core(3,iglob) * b_displ_inner_core(3,iglob) )

            epsilondev_loc(:) = epsilondev_inner_core(:,i,j,k,ispec)
            b_epsilondev_loc(:) = b_epsilondev_inner_core(:,i,j,k,ispec)
            beta_kl_inner_core(i,j,k,ispec) =  beta_kl_inner_core(i,j,k,ispec) &
               + deltat * (epsilondev_loc(1)*b_epsilondev_loc(1) + epsilondev_loc(2)*b_epsilondev_loc(2) &
                  + (epsilondev_loc(1)+epsilondev_loc(2)) * (b_epsilondev_loc(1)+b_epsilondev_loc(2)) &
                  + 2 * (epsilondev_loc(3)*b_epsilondev_loc(3) + epsilondev_loc(4)*b_epsilondev_loc(4) &
                  + epsilondev_loc(5)*b_epsilondev_loc(5)) )

            alpha_kl_inner_core(i,j,k,ispec) = alpha_kl_inner_core(i,j,k,ispec) &
               + deltat * (9 * eps_trace_over_3_inner_core(i,j,k,ispec) * b_eps_trace_over_3_inner_core(i,j,k,ispec))
          enddo
        enddo
      enddo
    enddo


! --- Boundary Kernels ------
    if (SAVE_BOUNDARY_MESH) then
      fluid_solid_boundary = .false.
      iregion_code = IREGION_CRUST_MANTLE

      ! Moho
      if (.not. SUPPRESS_CRUSTAL_MESH .and. HONOR_1D_SPHERICAL_MOHO) then
      call compute_boundary_kernel(displ_crust_mantle,accel_crust_mantle,b_displ_crust_mantle,nspec_crust_mantle,iregion_code, &
                 ystore_crust_mantle,zstore_crust_mantle,ibool_crust_mantle,idoubling_crust_mantle, &
                 xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle,etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle,&
                 gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,hprime_xx,hprime_yy,hprime_zz, &
                 rhostore_crust_mantle,kappavstore_crust_mantle,muvstore_crust_mantle, &
                 kappahstore_crust_mantle,muhstore_crust_mantle,eta_anisostore_crust_mantle, &
                 c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle,c14store_crust_mantle, &
                 c15store_crust_mantle,c16store_crust_mantle,c22store_crust_mantle, &
                 c23store_crust_mantle,c24store_crust_mantle,c25store_crust_mantle,c26store_crust_mantle, &
                 c33store_crust_mantle,c34store_crust_mantle,c35store_crust_mantle, &
                 c36store_crust_mantle,c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
                 c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
                 k_top,ibelm_moho_top,normal_moho,moho_kl_top,fluid_solid_boundary,NSPEC2D_MOHO)

      call compute_boundary_kernel(displ_crust_mantle,accel_crust_mantle,b_displ_crust_mantle,nspec_crust_mantle,iregion_code, &
                 ystore_crust_mantle,zstore_crust_mantle,ibool_crust_mantle,idoubling_crust_mantle, &
                 xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle,etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle,&
                 gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,hprime_xx,hprime_yy,hprime_zz, &
                 rhostore_crust_mantle,kappavstore_crust_mantle,muvstore_crust_mantle, &
                 kappahstore_crust_mantle,muhstore_crust_mantle,eta_anisostore_crust_mantle, &
                 c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle,c14store_crust_mantle, &
                 c15store_crust_mantle,c16store_crust_mantle,c22store_crust_mantle, &
                 c23store_crust_mantle,c24store_crust_mantle,c25store_crust_mantle,c26store_crust_mantle, &
                 c33store_crust_mantle,c34store_crust_mantle,c35store_crust_mantle, &
                 c36store_crust_mantle,c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
                 c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
                 k_bot,ibelm_moho_bot,normal_moho,moho_kl_bot,fluid_solid_boundary,NSPEC2D_MOHO)

      moho_kl = moho_kl + (moho_kl_top - moho_kl_bot) * deltat
      endif

      ! 400
      call compute_boundary_kernel(displ_crust_mantle,accel_crust_mantle,b_displ_crust_mantle,nspec_crust_mantle,iregion_code, &
                 ystore_crust_mantle,zstore_crust_mantle,ibool_crust_mantle,idoubling_crust_mantle, &
                 xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle,etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle,&
                 gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,hprime_xx,hprime_yy,hprime_zz, &
                 rhostore_crust_mantle,kappavstore_crust_mantle,muvstore_crust_mantle, &
                 kappahstore_crust_mantle,muhstore_crust_mantle,eta_anisostore_crust_mantle, &
                 c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle,c14store_crust_mantle, &
                 c15store_crust_mantle,c16store_crust_mantle,c22store_crust_mantle, &
                 c23store_crust_mantle,c24store_crust_mantle,c25store_crust_mantle,c26store_crust_mantle, &
                 c33store_crust_mantle,c34store_crust_mantle,c35store_crust_mantle, &
                 c36store_crust_mantle,c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
                 c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
                 k_top,ibelm_400_top,normal_400,d400_kl_top,fluid_solid_boundary,NSPEC2D_400)

      call compute_boundary_kernel(displ_crust_mantle,accel_crust_mantle,b_displ_crust_mantle,nspec_crust_mantle,iregion_code, &
                 ystore_crust_mantle,zstore_crust_mantle,ibool_crust_mantle,idoubling_crust_mantle, &
                 xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle,etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle,&
                 gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,hprime_xx,hprime_yy,hprime_zz, &
                 rhostore_crust_mantle,kappavstore_crust_mantle,muvstore_crust_mantle, &
                 kappahstore_crust_mantle,muhstore_crust_mantle,eta_anisostore_crust_mantle, &
                 c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle,c14store_crust_mantle, &
                 c15store_crust_mantle,c16store_crust_mantle,c22store_crust_mantle, &
                 c23store_crust_mantle,c24store_crust_mantle,c25store_crust_mantle,c26store_crust_mantle, &
                 c33store_crust_mantle,c34store_crust_mantle,c35store_crust_mantle, &
                 c36store_crust_mantle,c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
                 c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
                 k_bot,ibelm_400_bot,normal_400,d400_kl_bot,fluid_solid_boundary,NSPEC2D_400)

      d400_kl = d400_kl + (d400_kl_top - d400_kl_bot) * deltat

      ! 670
      call compute_boundary_kernel(displ_crust_mantle,accel_crust_mantle,b_displ_crust_mantle,nspec_crust_mantle,iregion_code, &
                 ystore_crust_mantle,zstore_crust_mantle,ibool_crust_mantle,idoubling_crust_mantle, &
                 xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle,etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle,&
                 gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,hprime_xx,hprime_yy,hprime_zz, &
                 rhostore_crust_mantle,kappavstore_crust_mantle,muvstore_crust_mantle, &
                 kappahstore_crust_mantle,muhstore_crust_mantle,eta_anisostore_crust_mantle, &
                 c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle,c14store_crust_mantle, &
                 c15store_crust_mantle,c16store_crust_mantle,c22store_crust_mantle, &
                 c23store_crust_mantle,c24store_crust_mantle,c25store_crust_mantle,c26store_crust_mantle, &
                 c33store_crust_mantle,c34store_crust_mantle,c35store_crust_mantle, &
                 c36store_crust_mantle,c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
                 c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
                 k_top,ibelm_670_top,normal_670,d670_kl_top,fluid_solid_boundary,NSPEC2D_670)

      call compute_boundary_kernel(displ_crust_mantle,accel_crust_mantle,b_displ_crust_mantle,nspec_crust_mantle,iregion_code, &
                 ystore_crust_mantle,zstore_crust_mantle,ibool_crust_mantle,idoubling_crust_mantle, &
                 xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle,etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle,&
                 gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,hprime_xx,hprime_yy,hprime_zz, &
                 rhostore_crust_mantle,kappavstore_crust_mantle,muvstore_crust_mantle, &
                 kappahstore_crust_mantle,muhstore_crust_mantle,eta_anisostore_crust_mantle, &
                 c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle,c14store_crust_mantle, &
                 c15store_crust_mantle,c16store_crust_mantle,c22store_crust_mantle, &
                 c23store_crust_mantle,c24store_crust_mantle,c25store_crust_mantle,c26store_crust_mantle, &
                 c33store_crust_mantle,c34store_crust_mantle,c35store_crust_mantle, &
                 c36store_crust_mantle,c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
                 c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
                 k_bot,ibelm_670_bot,normal_670,d670_kl_bot,fluid_solid_boundary,NSPEC2D_670)

      d670_kl = d670_kl + (d670_kl_top - d670_kl_bot) * deltat

      ! CMB
      fluid_solid_boundary = .true.
      iregion_code = IREGION_CRUST_MANTLE
      call compute_boundary_kernel(displ_crust_mantle,accel_crust_mantle,b_displ_crust_mantle,nspec_crust_mantle,iregion_code, &
                 ystore_crust_mantle,zstore_crust_mantle,ibool_crust_mantle,idoubling_crust_mantle, &
                 xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle,etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle,&
                 gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,hprime_xx,hprime_yy,hprime_zz, &
                 rhostore_crust_mantle,kappavstore_crust_mantle, muvstore_crust_mantle, &
                 kappahstore_crust_mantle,muhstore_crust_mantle,eta_anisostore_crust_mantle, &
                 c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle,c14store_crust_mantle, &
                 c15store_crust_mantle,c16store_crust_mantle,c22store_crust_mantle, &
                 c23store_crust_mantle,c24store_crust_mantle,c25store_crust_mantle,c26store_crust_mantle, &
                 c33store_crust_mantle,c34store_crust_mantle,c35store_crust_mantle, &
                 c36store_crust_mantle,c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
                 c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
                 k_top,ibelm_bottom_crust_mantle,normal_top_outer_core,cmb_kl_top,fluid_solid_boundary,NSPEC2D_CMB)

      iregion_code = IREGION_OUTER_CORE
      call compute_boundary_kernel(vector_displ_outer_core,vector_accel_outer_core,b_vector_displ_outer_core,nspec_outer_core, &
                 iregion_code,ystore_outer_core,zstore_outer_core,ibool_outer_core,idoubling_outer_core, &
                 xix_outer_core,xiy_outer_core,xiz_outer_core,etax_outer_core,etay_outer_core,etaz_outer_core,&
                 gammax_outer_core,gammay_outer_core,gammaz_outer_core,hprime_xx,hprime_yy,hprime_zz, &
                 rhostore_outer_core,kappavstore_outer_core,dummy_array, &
                 dummy_array,dummy_array,dummy_array, &
                 dummy_array,dummy_array,dummy_array,dummy_array, &
                 dummy_array,dummy_array,dummy_array, &
                 dummy_array,dummy_array,dummy_array,dummy_array, &
                 dummy_array,dummy_array,dummy_array, &
                 dummy_array,dummy_array,dummy_array,dummy_array, &
                 dummy_array,dummy_array,dummy_array, &
                 k_bot,ibelm_top_outer_core,normal_top_outer_core,cmb_kl_bot,fluid_solid_boundary,NSPEC2D_CMB)

      cmb_kl = cmb_kl + (cmb_kl_top - cmb_kl_bot) * deltat

      ! ICB
      fluid_solid_boundary = .true.
      call compute_boundary_kernel(vector_displ_outer_core,vector_accel_outer_core,b_vector_displ_outer_core,nspec_outer_core, &
                 iregion_code,ystore_outer_core,zstore_outer_core,ibool_outer_core,idoubling_outer_core, &
                 xix_outer_core,xiy_outer_core,xiz_outer_core,etax_outer_core,etay_outer_core,etaz_outer_core,&
                 gammax_outer_core,gammay_outer_core,gammaz_outer_core,hprime_xx,hprime_yy,hprime_zz, &
                 rhostore_outer_core,kappavstore_outer_core,dummy_array, &
                 dummy_array,dummy_array,dummy_array, &
                 dummy_array,dummy_array,dummy_array,dummy_array, &
                 dummy_array,dummy_array,dummy_array, &
                 dummy_array,dummy_array,dummy_array,dummy_array, &
                 dummy_array,dummy_array,dummy_array, &
                 dummy_array,dummy_array,dummy_array,dummy_array, &
                 dummy_array,dummy_array,dummy_array, &
                 k_top,ibelm_bottom_outer_core,normal_bottom_outer_core,icb_kl_top,fluid_solid_boundary,NSPEC2D_ICB)

      iregion_code = IREGION_INNER_CORE
      call compute_boundary_kernel(displ_inner_core,accel_inner_core,b_displ_inner_core,nspec_inner_core,iregion_code, &
                 ystore_inner_core,zstore_inner_core,ibool_inner_core,idoubling_inner_core, &
                 xix_inner_core,xiy_inner_core,xiz_inner_core,etax_inner_core,etay_inner_core,etaz_inner_core,&
                 gammax_inner_core,gammay_inner_core,gammaz_inner_core,hprime_xx,hprime_yy,hprime_zz, &
                 rhostore_inner_core,kappavstore_inner_core,muvstore_inner_core, &
                 dummy_array,dummy_array,dummy_array, &
                 c11store_inner_core,c12store_inner_core,c13store_inner_core,dummy_array, &
                 dummy_array,dummy_array,dummy_array, &
                 dummy_array,dummy_array,dummy_array,dummy_array, &
                 c33store_inner_core,dummy_array,dummy_array, &
                 dummy_array,c44store_inner_core,dummy_array,dummy_array, &
                 dummy_array,dummy_array,dummy_array, &
                 k_bot,ibelm_top_inner_core,normal_bottom_outer_core,icb_kl_bot,fluid_solid_boundary,NSPEC2D_ICB)

      icb_kl = icb_kl + (icb_kl_top - icb_kl_bot) * deltat

    endif

  endif ! end computing kernels


! save movie on surface
  if(MOVIE_SURFACE .and. mod(it,NTSTEP_BETWEEN_FRAMES) == 0) then

! save velocity here to avoid static offset on displacement for movies

! get coordinates of surface mesh and surface displacement
    ipoin = 0
    do ispec2D = 1,NSPEC2D_TOP(IREGION_CRUST_MANTLE)
      ispec = ibelm_top_crust_mantle(ispec2D)
      k = NGLLZ

! loop on all the points inside the element
      do j = 1,NGLLY
        do i = 1,NGLLX
          ipoin = ipoin + 1
          iglob = ibool_crust_mantle(i,j,k,ispec)
          store_val_x(ipoin) = xstore_crust_mantle(iglob)
          store_val_y(ipoin) = ystore_crust_mantle(iglob)
          store_val_z(ipoin) = zstore_crust_mantle(iglob)
          store_val_ux(ipoin) = veloc_crust_mantle(1,iglob)*scale_veloc
          store_val_uy(ipoin) = veloc_crust_mantle(2,iglob)*scale_veloc
          store_val_uz(ipoin) = veloc_crust_mantle(3,iglob)*scale_veloc
        enddo
      enddo

    enddo

! gather info on master proc
    ispec = nmovie_points
    call MPI_GATHER(store_val_x,ispec,CUSTOM_MPI_TYPE,store_val_x_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_y,ispec,CUSTOM_MPI_TYPE,store_val_y_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_z,ispec,CUSTOM_MPI_TYPE,store_val_z_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_ux,ispec,CUSTOM_MPI_TYPE,store_val_ux_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_uy,ispec,CUSTOM_MPI_TYPE,store_val_uy_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_uz,ispec,CUSTOM_MPI_TYPE,store_val_uz_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)

! save movie data to disk in home directory
    if(myrank == 0) then
      write(outputname,"('/moviedata',i6.6)") it
      open(unit=IOUT,file=trim(OUTPUT_FILES)//outputname,status='unknown',form='unformatted')
      write(IOUT) store_val_x_all
      write(IOUT) store_val_y_all
      write(IOUT) store_val_z_all
      write(IOUT) store_val_ux_all
      write(IOUT) store_val_uy_all
      write(IOUT) store_val_uz_all
      close(IOUT)
    endif

  endif

! save movie in full 3D mesh
  if(MOVIE_VOLUME .and. mod(it,NTSTEP_BETWEEN_FRAMES) == 0) then

! div
    write(outputname,"('proc',i6.6,'_crust_mantle_div_displ_it',i6.6,'.bin')") myrank,it
    open(unit=27,file=trim(LOCAL_PATH)//trim(outputname),status='unknown',form='unformatted')
    write(27) eps_trace_over_3_crust_mantle
    close(27)

! we use div s = - p / kappa = rhostore_outer_core * accel_outer_core / kappavstore_outer_core
    allocate(div_s_outer_core(NGLLX,NGLLY,NGLLZ,NSPEC_OUTER_CORE))
    do ispec = 1, NSPEC_OUTER_CORE
      do k = 1, NGLLZ
        do j = 1, NGLLY
          do i = 1, NGLLX
            iglob = ibool_outer_core(i,j,k,ispec)
            rhol = rhostore_outer_core(i,j,k,ispec)
            kappal = kappavstore_outer_core(i,j,k,ispec)
            div_s_outer_core(i,j,k,ispec) = rhol * accel_outer_core(iglob) / kappal
          enddo
        enddo
      enddo
    enddo

    write(outputname,"('proc',i6.6,'_outer_core_div_displ_it',i6.6,'.bin')") myrank,it
    open(unit=27,file=trim(LOCAL_PATH)//trim(outputname),status='unknown',form='unformatted')
    write(27)  div_s_outer_core
    close(27)

    deallocate(div_s_outer_core)

    write(outputname,"('proc',i6.6,'_inner_core_div_displ_proc_it',i6.6,'.bin')") myrank,it
    open(unit=27,file=trim(LOCAL_PATH)//trim(outputname),status='unknown',form='unformatted')
    write(27) eps_trace_over_3_inner_core
    close(27)

! epsilondev

    write(outputname,"('proc',i6.6,'_crust_mantle_epsdev_displ_it',i6.6,'.bin')") myrank,it
    open(unit=27,file=trim(LOCAL_PATH)//trim(outputname),status='unknown',form='unformatted')
    write(27) epsilondev_crust_mantle
    close(27)

    write(outputname,"('proc',i6.6,'inner_core_epsdev_displ_it',i6.6,'.bin')") myrank,it
    open(unit=27,file=trim(LOCAL_PATH)//trim(outputname),status='unknown',form='unformatted')
    write(27) epsilondev_inner_core
    close(27)

  endif

!---- end of time iteration loop
!
  enddo   ! end of main time loop

! write the final seismograms
  if (SIMULATION_TYPE == 1 .or. SIMULATION_TYPE == 3) then
    call write_seismograms(myrank,seismograms,number_receiver_global,station_name, &
        network_name,stlat,stlon,stele,nrec,nrec_local,DT,t0,it_end, &
        yr_SAC,jda_SAC,ho_SAC,mi_SAC,sec_SAC,t_cmt_SAC, &
        elat_SAC,elon_SAC,depth_SAC,mb_SAC,ename_SAC,cmt_lat_SAC,cmt_lon_SAC, &
        cmt_depth_SAC,cmt_hdur_SAC,NSOURCES_SAC,NPROCTOT, &
        OUTPUT_SEISMOS_ASCII_TEXT,OUTPUT_SEISMOS_SAC_ALPHANUM, &
        OUTPUT_SEISMOS_SAC_BINARY,ROTATE_SEISMOGRAMS_RT,NTSTEP_BETWEEN_OUTPUT_SEISMOS, &
        seismo_offset,seismo_current,WRITE_SEISMOGRAMS_BY_MASTER, &
        SAVE_ALL_SEISMOS_IN_ONE_FILE,USE_BINARY_FOR_LARGE_FILE)
    if(myrank==0) write(IMAIN,*)
    if(myrank==0) write(IMAIN,*) ' Total number of time steps written: ', it-it_begin
    if(myrank==0) write(IMAIN,*)
    else
    if (nrec_local > 0) then
      call write_adj_seismograms(seismograms,number_receiver_global, &
        nrec_local,it,nit_written,DT,NSTEP,NTSTEP_BETWEEN_OUTPUT_SEISMOS,t0,LOCAL_PATH)
    endif
  endif

! save files to local disk or MT tape system if restart file
  if(NUMBER_OF_RUNS > 1 .and. NUMBER_OF_THIS_RUN < NUMBER_OF_RUNS) then
    write(outputname,"('dump_all_arrays',i6.6)") myrank
    open(unit=55,file=trim(LOCAL_PATH)//'/'//outputname,status='unknown',form='unformatted')
    write(55) displ_crust_mantle
    write(55) veloc_crust_mantle
    write(55) accel_crust_mantle
    write(55) displ_inner_core
    write(55) veloc_inner_core
    write(55) accel_inner_core
    write(55) displ_outer_core
    write(55) veloc_outer_core
    write(55) accel_outer_core
    write(55) R_memory_crust_mantle
    write(55) R_memory_inner_core
    write(55) epsilondev_crust_mantle
    write(55) epsilondev_inner_core
    write(55) A_array_rotation
    write(55) B_array_rotation
    close(55)
  endif

! save last frame of the forward simulation
  if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
    write(outputname,'(a,i6.6,a)') 'proc',myrank,'_save_forward_arrays.bin'
    open(unit=55,file=trim(LOCAL_PATH)//'/'//outputname,status='unknown',form='unformatted')
    write(55) displ_crust_mantle
    write(55) veloc_crust_mantle
    write(55) accel_crust_mantle
    write(55) displ_inner_core
    write(55) veloc_inner_core
    write(55) accel_inner_core
    write(55) displ_outer_core
    write(55) veloc_outer_core
    write(55) accel_outer_core
    if (ATTENUATION_VAL) then
      write(55) R_memory_crust_mantle
      write(55) R_memory_inner_core
    endif
    write(55) epsilondev_crust_mantle
    write(55) epsilondev_inner_core
    if (ROTATION_VAL) then
      write(55) A_array_rotation
      write(55) B_array_rotation
    endif
    close(55)
  endif

! dump kernel arrays
  if (SIMULATION_TYPE == 3) then
    scale_kl = scale_t/scale_displ * 1.d9
! crust_mantle
    do ispec = 1, NSPEC_CRUST_MANTLE
      do k = 1, NGLLZ
        do j = 1, NGLLY
          do i = 1, NGLLX
            rhol = rhostore_crust_mantle(i,j,k,ispec)
            mul = muvstore_crust_mantle(i,j,k,ispec)
            kappal = kappavstore_crust_mantle(i,j,k,ispec)
            rho_kl = - rhol * rho_kl_crust_mantle(i,j,k,ispec)
            alpha_kl = - kappal * alpha_kl_crust_mantle(i,j,k,ispec)
            beta_kl =  - 2 * mul * beta_kl_crust_mantle(i,j,k,ispec)
            rho_kl_crust_mantle(i,j,k,ispec) = (rho_kl + alpha_kl + beta_kl) * scale_kl
            beta_kl_crust_mantle(i,j,k,ispec) = 2 * (beta_kl - FOUR_THIRDS * mul * alpha_kl / kappal) * scale_kl
            alpha_kl_crust_mantle(i,j,k,ispec) = 2 * (1 +  FOUR_THIRDS * mul / kappal) * alpha_kl * scale_kl
          enddo
        enddo
      enddo
    enddo

    call create_name_database(prname,myrank,IREGION_CRUST_MANTLE,LOCAL_PATH)
    open(unit=27,file=trim(prname)//'rho_kernel.bin',status='unknown',form='unformatted')
    write(27) rho_kl_crust_mantle
    close(27)
    open(unit=27,file=trim(prname)//'alpha_kernel.bin',status='unknown',form='unformatted')
    write(27) alpha_kl_crust_mantle
    close(27)
    open(unit=27,file=trim(prname)//'beta_kernel.bin',status='unknown',form='unformatted')
    write(27) beta_kl_crust_mantle
    close(27)

! outer_core
    do ispec = 1, NSPEC_OUTER_CORE
      do k = 1, NGLLZ
        do j = 1, NGLLY
          do i = 1, NGLLX
            rhol = rhostore_outer_core(i,j,k,ispec)
            kappal = kappavstore_outer_core(i,j,k,ispec)
            rho_kl = - rhol * rho_kl_outer_core(i,j,k,ispec)
            alpha_kl = - kappal * alpha_kl_outer_core(i,j,k,ispec)
            rho_kl_outer_core(i,j,k,ispec) = (rho_kl + alpha_kl) * scale_kl
            alpha_kl_outer_core(i,j,k,ispec) = 2 * alpha_kl * scale_kl
          enddo
        enddo
      enddo
    enddo

    call create_name_database(prname,myrank,IREGION_OUTER_CORE,LOCAL_PATH)
    open(unit=27,file=trim(prname)//'rho_kernel.bin',status='unknown',form='unformatted')
    write(27) rho_kl_outer_core
    close(27)
    open(unit=27,file=trim(prname)//'alpha_kernel.bin',status='unknown',form='unformatted')
    write(27) alpha_kl_outer_core
    close(27)

! inner_core
   do ispec = 1, NSPEC_INNER_CORE
      do k = 1, NGLLZ
        do j = 1, NGLLY
          do i = 1, NGLLX
            rhol = rhostore_inner_core(i,j,k,ispec)
            mul = muvstore_inner_core(i,j,k,ispec)
            kappal = kappavstore_inner_core(i,j,k,ispec)
            rho_kl = -rhol * rho_kl_inner_core(i,j,k,ispec)
            alpha_kl = -kappal * alpha_kl_inner_core(i,j,k,ispec)
            beta_kl =  - 2 * mul * beta_kl_inner_core(i,j,k,ispec)
            rho_kl_inner_core(i,j,k,ispec) = (rho_kl + alpha_kl + beta_kl) * scale_kl
            beta_kl_inner_core(i,j,k,ispec) = 2 * (beta_kl - FOUR_THIRDS * mul * alpha_kl / kappal) * scale_kl
            alpha_kl_inner_core(i,j,k,ispec) = 2 * (1 +  FOUR_THIRDS * mul / kappal) * alpha_kl * scale_kl
          enddo
        enddo
      enddo
    enddo

    call create_name_database(prname,myrank,IREGION_INNER_CORE,LOCAL_PATH)
    open(unit=27,file=trim(prname)//'rho_kernel.bin',status='unknown',form='unformatted')
    write(27) rho_kl_inner_core
    close(27)
    open(unit=27,file=trim(prname)//'alpha_kernel.bin',status='unknown',form='unformatted')
    write(27) alpha_kl_inner_core
    close(27)
    open(unit=27,file=trim(prname)//'beta_kernel.bin',status='unknown',form='unformatted')
    write(27) beta_kl_inner_core
    close(27)

! Boundary Kernel
    if (SAVE_BOUNDARY_MESH) then
      call create_name_database(prname,myrank,IREGION_CRUST_MANTLE,LOCAL_PATH)
      if (.not. SUPPRESS_CRUSTAL_MESH .and. HONOR_1D_SPHERICAL_MOHO) then
      open(unit=27,file=trim(prname)//'moho_kernel.bin',status='unknown',form='unformatted')
      write(27) moho_kl
      close(27)
      endif
      open(unit=27,file=trim(prname)//'d400_kernel.bin',status='unknown',form='unformatted')
      write(27) d400_kl
      close(27)
      open(unit=27,file=trim(prname)//'d670_kernel.bin',status='unknown',form='unformatted')
      write(27) d670_kl
      close(27)
      open(unit=27,file=trim(prname)//'CMB_kernel.bin',status='unknown',form='unformatted')
      write(27) cmb_kl
      close(27)
      call create_name_database(prname,myrank,IREGION_OUTER_CORE,LOCAL_PATH)
      open(unit=27,file=trim(prname)//'ICB_kernel.bin',status='unknown',form='unformatted')
      write(27) icb_kl
      close(27)
    endif

  endif

! if running on MareNostrum in Barcelona
  if(RUN_ON_MARENOSTRUM_BARCELONA) then

! synchronize all the processes to make sure everybody has finished
    call MPI_BARRIER(MPI_COMM_WORLD,ier)

! suppress the local directory to leave space for future runs with a different rank number
    write(system_command,"('rm -r -f /scratch/komatits_new_proc',i4.4)") myrank
    call system(system_command)

  endif

! close the main output file
  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'End of the simulation'
    write(IMAIN,*)
    close(IMAIN)
  endif

! synchronize all the processes to make sure everybody has finished
  call MPI_BARRIER(MPI_COMM_WORLD,ier)

  end subroutine specfem3D

