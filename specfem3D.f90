!=====================================================================
!
!          S p e c f e m 3 D  G l o b e  V e r s i o n  3 . 6
!          --------------------------------------------------
!
!                 Dimitri Komatitsch and Jeroen Tromp
!    Seismological Laboratory - California Institute of Technology
!       (c) California Institute of Technology September 2006
!
!    A signed non-commercial agreement is required to use this program.
!   Please check http://www.gps.caltech.edu/research/jtromp for details.
!           Free for non-commercial academic research ONLY.
!      This program is distributed WITHOUT ANY WARRANTY whatsoever.
!      Do not redistribute this program without written permission.
!
!=====================================================================
!
! Copyright September 2006, by the California Institute of Technology.
! ALL RIGHTS RESERVED. United States Government Sponsorship Acknowledged.
!
! Any commercial use must be negotiated with the Office of Technology
! Transfer at the California Institute of Technology. This software may be
! subject to U.S. export control laws and regulations. By accepting
! this software, the user agrees to comply with all applicable U.S. export laws
! and regulations, including the International Traffic and Arms Regulations,
! 22 C.F.R. 120-130 and the Export Administration Regulations,
! 15 C.F.R. 730-744. User has the responsibility to obtain export licenses,
! or other export authority as may be required before exporting such
! information to foreign countries or providing access to foreign nationals.
! In no event shall the California Institute of Technology be liable to any
! party for direct, indirect, special, incidental or consequential damages,
! including lost profits, arising out of the use of this software and its
! documentation, even if the California Institute of Technology has been
! advised of the possibility of such damage.
!
! The California Institute of Technology specifically disclaims any
! warranties, including the implied warranties or merchantability and fitness
! for a particular purpose. The software and documentation provided hereunder
! is on an "as is" basis, and the California Institute of Technology has no
! obligations to provide maintenance, support, updates, enhancements or
! modifications.
!

  subroutine specfem3D

  implicit none

! standard include of the MPI library
  include 'mpif.h'

  include "constants.h"
  include "precision.h"

! include values created by the mesher
  include "OUTPUT_FILES/values_from_mesher.h"

!=======================================================================!
!                                                                       !
!   specfem3D is a 3-D spectral-element solver for the Earth.           !
!   It uses a mesh generated by program meshfem3D                       !
!                                                                       !
!=======================================================================!
!
! If you use this code for your own research, please cite some of these articles:
!
! @ARTICLE{KoRiTr02,
! author={D. Komatitsch and J. Ritsema and J. Tromp},
! year=2002,
! title={The Spectral-Element Method, {B}eowulf Computing, and Global Seismology},
! journal={Science},
! volume=298,
! number=5599,
! pages={1737-1742},
! doi={10.1126/science.1076024}}
!
! @ARTICLE{KoTr02a,
! author={D. Komatitsch and J. Tromp},
! year=2002,
! title={Spectral-Element Simulations of Global Seismic Wave Propagation{-I. V}alidation},
! journal={Geophys. J. Int.},
! volume=149,
! number=2,
! pages={390-412},
! doi={10.1046/j.1365-246X.2002.01653.x}}
!
! @ARTICLE{KoTr02b,
! author={D. Komatitsch and J. Tromp},
! year=2002,
! title={Spectral-Element Simulations of Global Seismic Wave Propagation{-II. 3-D} Models, Oceans, Rotation, and Self-Gravitation},
! journal={Geophys. J. Int.},
! volume=150,
! pages={303-318},
! number=1,
! doi={10.1046/j.1365-246X.2002.01716.x}}
!
! @ARTICLE{KoTr99,
! author={D. Komatitsch and J. Tromp},
! year=1999,
! title={Introduction to the spectral-element method for 3-{D} seismic wave propagation},
! journal={Geophys. J. Int.},
! volume=139,
! number=3,
! pages={806-822},
! doi={10.1046/j.1365-246x.1999.00967.x}}
!
! @ARTICLE{KoVi98,
! author={D. Komatitsch and J. P. Vilotte},
! title={The spectral-element method: an efficient tool to simulate the seismic response of 2{D} and 3{D} geological structures},
! journal={Bull. Seismol. Soc. Am.},
! year=1998,
! volume=88,
! number=2,
! pages={368-392}}
!
! If you use the kernel capabilities of the code, please cite
!
! @ARTICLE{LiTr06,
! author={Qinya Liu and Jeroen Tromp},
! title={Finite-frequency kernels based on adjoint methods},
! journal={Bull. Seismol. Soc. Am.},
! year=2006,
! volume=96,
! number=6,
! pages={2383-2397},
! doi={10.1785/0120060041}}
!
! If you use 3-D model S20RTS, please cite
!
! @ARTICLE{RiVa00,
! author={J. Ritsema and H. J. {Van Heijst}},
! year=2000,
! title={Seismic imaging of structural heterogeneity in {E}arth's mantle: Evidence for large-scale mantle flow},
! journal={Science Progress},
! volume=83,
! pages={243-259}}
!
! Reference frame - convention:
! ----------------------------
!
! The code uses the following convention for the reference frame:
!
!  - X axis is East
!  - Y axis is North
!  - Z axis is up
!
! Note that this convention is different from both the Aki-Richards convention
! and the Harvard CMT convention.
!
! Let us recall that the Aki-Richards convention is:
!
!  - X axis is North
!  - Y axis is East
!  - Z axis is down
!
! and that the Harvard CMT convention is:
!
!  - X axis is South
!  - Y axis is East
!  - Z axis is up
!
! To report bugs or suggest improvements to the code, please send an email
! to Jeroen Tromp <jtromp AT caltech.edu> and/or use our online
! bug tracking system at http://www.geodynamics.org/roundup .
!
! Evolution of the code:
! ---------------------
!
! v. 3.6 Many people, many affiliations, September 2006:
!      adjoint and kernel calculations, fixed IASP91 model,
!      added AK135 and 1066a, fixed topography/bathymetry routine,
!      new attenuation routines, faster and better I/Os on very large
!      systems, many small improvements and bug fixes, new "configure"
!      script, new Pyre version, new user's manual etc.
! v. 3.5 Dimitri Komatitsch, Brian Savage and Jeroen Tromp, Caltech, July 2004:
!      any size of chunk, 3D attenuation, case of two chunks,
!      more precise topography/bathymetry model, new Par_file structure
! v. 3.4 Dimitri Komatitsch and Jeroen Tromp, Caltech, August 2003:
!      merged global and regional codes, no iterations in fluid, better movies
! v. 3.3 Dimitri Komatitsch, Caltech, September 2002:
!      flexible mesh doubling in outer core, inlined code, OpenDX support
! v. 3.2 Jeroen Tromp, Caltech, July 2002:
!      multiple sources and flexible PREM reading
! v. 3.1 Dimitri Komatitsch, Caltech, June 2002:
!      vectorized loops in solver and merged central cube
! v. 3.0 Dimitri Komatitsch and Jeroen Tromp, Caltech, May 2002:
!   ported to SGI and Compaq, double precision solver, more general anisotropy
! v. 2.3 Dimitri Komatitsch and Jeroen Tromp, Caltech, August 2001:
!                       gravity, rotation, oceans and 3-D models
! v. 2.2 Dimitri Komatitsch and Jeroen Tromp, Caltech, March 2001:
!                       final MPI package
! v. 2.0 Dimitri Komatitsch, Harvard, January 2000: MPI code for the globe
! v. 1.0 Dimitri Komatitsch, Mexico, June 1999: first MPI code for a chunk
! Jeroen Tromp, Harvard, July 1998: first chunk solver using OpenMP on Sun
! Dimitri Komatitsch, IPG Paris, December 1996: first 3-D solver for the CM5
!
! From Dahlen and Tromp (1998):
! ----------------------------
!
! Gravity is approximated by solving eq (3.259) without the Phi_E' term
! The ellipsoidal reference model is that of section 14.1
! The transversely isotropic expression for PREM is that of eq (8.190)
!
! the potential in the outer core is called displ_outer_core for simplicity
!

! attenuation_model_variables --- have to be checked : may be in OUTPUT_FILES/values_from_mesher.h ...
  type attenuation_model_variables
    sequence
    double precision min_period, max_period
    double precision                          :: QT_c_source        ! Source Frequency
    double precision, dimension(:), pointer   :: Qtau_s             ! tau_sigma
    double precision, dimension(:), pointer   :: QrDisc             ! Discontinutitues Defined
    double precision, dimension(:), pointer   :: Qr                 ! Radius
    integer, dimension(:), pointer            :: interval_Q         ! Steps
    double precision, dimension(:), pointer   :: Qmu                ! Shear Attenuation
    double precision, dimension(:,:), pointer :: Qtau_e             ! tau_epsilon
    double precision, dimension(:), pointer   :: Qomsb, Qomsb2      ! one_minus_sum_beta
    double precision, dimension(:,:), pointer :: Qfc, Qfc2          ! factor_common
    double precision, dimension(:), pointer   :: Qsf, Qsf2          ! scale_factor
    integer, dimension(:), pointer            :: Qrmin              ! Max and Mins of idoubling
    integer, dimension(:), pointer            :: Qrmax              ! Max and Mins of idoubling
    integer                                   :: Qn                 ! Number of points
  end type attenuation_model_variables

  type (attenuation_model_variables) AM_V
! attenuation_model_variables

! memory variables and standard linear solids for attenuation
  double precision, dimension(N_SLS) :: tau_sigma_dble
  double precision, dimension(:,:,:,:), allocatable   :: omsb_crust_mantle_dble, factor_scale_crust_mantle_dble
  double precision, dimension(:,:,:,:), allocatable   :: omsb_inner_core_dble, factor_scale_inner_core_dble
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable   :: one_minus_sum_beta_crust_mantle, factor_scale_crust_mantle
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable   :: one_minus_sum_beta_inner_core, factor_scale_inner_core

  real(kind=CUSTOM_REAL) mul, kappal, rhol

  double precision, dimension(N_SLS) :: alphaval_dble, betaval_dble, gammaval_dble
  real(kind=CUSTOM_REAL), dimension(N_SLS) :: alphaval, betaval, gammaval
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:), allocatable :: factor_common_crust_mantle
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:), allocatable :: factor_common_inner_core
  double precision, dimension(:,:,:,:,:), allocatable :: factor_common_crust_mantle_dble
  double precision, dimension(:,:,:,:,:), allocatable :: factor_common_inner_core_dble

  double precision scale_factor,scale_factor_minus_one
  real(kind=CUSTOM_REAL) dist_cr

  real(kind=CUSTOM_REAL), dimension(5,N_SLS,NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE_ATTENUAT) :: R_memory_crust_mantle
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:),allocatable :: epsilondev_crust_mantle
  real(kind=CUSTOM_REAL), dimension(:,:,:,:),allocatable :: eps_trace_over_3_crust_mantle
  real(kind=CUSTOM_REAL), dimension(5) :: epsilondev_loc

  real(kind=CUSTOM_REAL), dimension(5,N_SLS,NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE_ATTENUATION) :: R_memory_inner_core
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:),allocatable :: epsilondev_inner_core
  real(kind=CUSTOM_REAL), dimension(:,:,:,:),allocatable :: eps_trace_over_3_inner_core

! ADJOINT
  real(kind=CUSTOM_REAL), dimension(N_SLS) :: b_alphaval, b_betaval, b_gammaval
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:,:),allocatable :: b_R_memory_crust_mantle,b_R_memory_inner_core
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:),allocatable :: b_epsilondev_crust_mantle, b_epsilondev_inner_core
  real(kind=CUSTOM_REAL), dimension(:,:,:,:),allocatable :: b_eps_trace_over_3_crust_mantle, b_eps_trace_over_3_inner_core
  real(kind=CUSTOM_REAL), dimension(5) :: b_epsilondev_loc

! for matching with central cube in inner core
  integer, dimension(:), allocatable :: sender_from_slices_to_cube
  integer, dimension(:,:), allocatable :: ibool_central_cube
  double precision, dimension(:,:), allocatable :: buffer_slices
  double precision, dimension(:,:,:), allocatable :: buffer_all_cube_from_slices
  integer nb_msgs_theor_in_cube,non_zero_nb_msgs_theor_in_cube,npoin2D_cube_from_slices,receiver_cube_from_slices

  integer nspec2D_xmin_inner_core,nspec2D_xmax_inner_core,nspec2D_ymin_inner_core,nspec2D_ymax_inner_core,ndim_assemble

! to save movie frames
  integer nmovie_points,ipoin
  real(kind=CUSTOM_REAL), dimension(:), allocatable :: &
      store_val_x,store_val_y,store_val_z, &
      store_val_ux,store_val_uy,store_val_uz
  real(kind=CUSTOM_REAL), dimension(:,:), allocatable :: &
      store_val_x_all,store_val_y_all,store_val_z_all, &
      store_val_ux_all,store_val_uy_all,store_val_uz_all

! use integer array to store values
  integer ibathy_topo(NX_BATHY,NY_BATHY)

! MPI status of messages to be received
  integer msg_status(MPI_STATUS_SIZE)

! for crust/oceans coupling
  integer, dimension(:), allocatable :: ibelm_xmin_crust_mantle,ibelm_xmax_crust_mantle, &
    ibelm_ymin_crust_mantle,ibelm_ymax_crust_mantle,ibelm_bottom_crust_mantle,ibelm_top_crust_mantle
  logical, dimension(NGLOBMAX_CRUST_MANTLE) :: updated_dof_ocean_load
  real(kind=CUSTOM_REAL), dimension(:,:,:), allocatable :: jacobian2D_bottom_crust_mantle,jacobian2D_top_crust_mantle, &
    jacobian2D_xmin_crust_mantle,jacobian2D_xmax_crust_mantle, &
    jacobian2D_ymin_crust_mantle,jacobian2D_ymax_crust_mantle
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: normal_xmin_crust_mantle, &
    normal_xmax_crust_mantle,normal_ymin_crust_mantle,normal_ymax_crust_mantle, &
    normal_bottom_crust_mantle,normal_top_crust_mantle

! Stacey
  real(kind=CUSTOM_REAL) sn,tx,ty,tz
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE) :: rho_vp_crust_mantle,rho_vs_crust_mantle
  integer nspec2D_xmin_crust_mantle,nspec2D_xmax_crust_mantle,nspec2D_ymin_crust_mantle,nspec2D_ymax_crust_mantle
  integer, dimension(:,:), allocatable :: nimin_crust_mantle, &
    nimax_crust_mantle,njmin_crust_mantle,njmax_crust_mantle, &
    nkmin_xi_crust_mantle,nkmin_eta_crust_mantle

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE) :: vp_outer_core
  integer nspec2D_xmin_outer_core,nspec2D_xmax_outer_core,nspec2D_ymin_outer_core,nspec2D_ymax_outer_core
  integer, dimension(:,:), allocatable :: nimin_outer_core, &
    nimax_outer_core,njmin_outer_core,njmax_outer_core, &
    nkmin_xi_outer_core,nkmin_eta_outer_core

! arrays to couple with the fluid regions by pointwise matching
  integer, dimension(:), allocatable :: ibelm_xmin_outer_core, &
    ibelm_xmax_outer_core,ibelm_ymin_outer_core,ibelm_ymax_outer_core, &
    ibelm_bottom_outer_core,ibelm_top_outer_core
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: normal_xmin_outer_core, &
    normal_xmax_outer_core,normal_ymin_outer_core,normal_ymax_outer_core, &
    normal_bottom_outer_core,normal_top_outer_core
  real(kind=CUSTOM_REAL), dimension(:,:,:), allocatable :: jacobian2D_bottom_outer_core,jacobian2D_top_outer_core, &
    jacobian2D_xmin_outer_core,jacobian2D_xmax_outer_core, &
    jacobian2D_ymin_outer_core,jacobian2D_ymax_outer_core

  integer, dimension(:), allocatable :: ibelm_xmin_inner_core, &
    ibelm_xmax_inner_core,ibelm_ymin_inner_core,ibelm_ymax_inner_core, &
    ibelm_bottom_inner_core,ibelm_top_inner_core

! for matching between fluid and solid regions
  integer ispec2D,k_corresp,ispec_selected
  real(kind=CUSTOM_REAL) vx,vy,vz,nx,ny,nz,vn,weight,pressure

! for ellipticity
  integer nspl
  double precision rspl(NR),espl(NR),espl2(NR)
  double precision ell_d80_dble
  real(kind=CUSTOM_REAL) theta,ell_d80
  real(kind=CUSTOM_REAL) p20, cost


! for conversion from x y z to r theta phi
  real(kind=CUSTOM_REAL) rval,thetaval,phival

! ---- arrays to assemble between chunks

! communication pattern for faces between chunks
  integer, dimension(:), allocatable :: iprocfrom_faces,iprocto_faces,imsg_type

! communication pattern for corners between chunks
  integer, dimension(:), allocatable :: iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners

! indirect addressing for each message for faces and corners of the chunks
! a given slice can belong to at most one corner and at most two faces
  integer NPOIN2DMAX_XY
  integer, dimension(:,:), allocatable :: iboolfaces_crust_mantle
  integer, dimension(:,:), allocatable :: iboolfaces_outer_core
  integer, dimension(:,:), allocatable :: iboolfaces_inner_core

! buffers for send and receive between faces of the slices and the chunks
  real(kind=CUSTOM_REAL), dimension(:), allocatable :: buffer_send_faces_scalar,buffer_received_faces_scalar
  real(kind=CUSTOM_REAL), dimension(:,:), allocatable :: buffer_send_faces_vector,buffer_received_faces_vector

! -------- arrays specific to each region here -----------

! ----------------- crust, mantle and oceans ---------------------

! mesh parameters
  integer, dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE) :: ibool_crust_mantle

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE) :: &
        xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle,&
        etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
        gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,jacobian_crust_mantle
  real(kind=CUSTOM_REAL), dimension(NGLOBMAX_CRUST_MANTLE) :: &
        xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle

! arrays for isotropic elements stored only where needed to save space
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_ISO_MANTLE) :: &
        rhostore_crust_mantle, kappavstore_crust_mantle,muvstore_crust_mantle

! arrays for anisotropic elements stored only where needed to save space
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_TISO_MANTLE) :: &
        kappahstore_crust_mantle,muhstore_crust_mantle,eta_anisostore_crust_mantle

! arrays for full anisotropy only when needed
  integer nspec_iso,nspec_tiso,nspec_ani
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE) :: &
        c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle, &
        c14store_crust_mantle,c15store_crust_mantle,c16store_crust_mantle, &
        c22store_crust_mantle,c23store_crust_mantle,c24store_crust_mantle, &
        c25store_crust_mantle,c26store_crust_mantle,c33store_crust_mantle, &
        c34store_crust_mantle,c35store_crust_mantle,c36store_crust_mantle, &
        c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
        c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle

! local to global mapping
  integer, dimension(NSPECMAX_CRUST_MANTLE) :: idoubling_crust_mantle

! mass matrix
  real(kind=CUSTOM_REAL), dimension(NGLOBMAX_CRUST_MANTLE) :: rmass_crust_mantle

! displacement, velocity, acceleration
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLOBMAX_CRUST_MANTLE) :: &
     displ_crust_mantle,veloc_crust_mantle,accel_crust_mantle

! additional mass matrix for ocean load
! ocean load mass matrix is always allocated statically even if no oceans
  real(kind=CUSTOM_REAL), dimension(NGLOBMAX_CRUST_MANTLE) :: rmass_ocean_load
  real(kind=CUSTOM_REAL) additional_term,force_normal_comp

! ----------------- outer core ---------------------

! mesh parameters
  integer, dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE) :: ibool_outer_core

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE) :: &
        xix_outer_core,xiy_outer_core,xiz_outer_core,&
        etax_outer_core,etay_outer_core,etaz_outer_core, &
        gammax_outer_core,gammay_outer_core,gammaz_outer_core,jacobian_outer_core
  real(kind=CUSTOM_REAL), dimension(NGLOBMAX_OUTER_CORE) :: &
        xstore_outer_core,ystore_outer_core,zstore_outer_core

 real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE) :: &
        rhostore_outer_core,kappavstore_outer_core

! local to global mapping
  integer, dimension(NSPECMAX_OUTER_CORE) :: idoubling_outer_core

! mass matrix
  real(kind=CUSTOM_REAL), dimension(NGLOBMAX_OUTER_CORE) :: rmass_outer_core

! velocity potential
  real(kind=CUSTOM_REAL), dimension(NGLOBMAX_OUTER_CORE) :: displ_outer_core, &
    veloc_outer_core,accel_outer_core

! divergence of displ
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable  :: div_displ_outer_core

! ----------------- inner core ---------------------

! mesh parameters
  integer, dimension(NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE) :: ibool_inner_core

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE) :: &
        xix_inner_core,xiy_inner_core,xiz_inner_core,&
        etax_inner_core,etay_inner_core,etaz_inner_core, &
        gammax_inner_core,gammay_inner_core,gammaz_inner_core,jacobian_inner_core, &
        rhostore_inner_core, kappavstore_inner_core,muvstore_inner_core
  real(kind=CUSTOM_REAL), dimension(NGLOB_INNER_CORE) :: &
        xstore_inner_core,ystore_inner_core,zstore_inner_core

! arrays for inner-core anisotropy only when needed
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_IC) :: &
        c11store_inner_core,c33store_inner_core,c12store_inner_core, &
        c13store_inner_core,c44store_inner_core

! local to global mapping
  integer, dimension(NSPEC_INNER_CORE) :: idoubling_inner_core

! mass matrix
  real(kind=CUSTOM_REAL), dimension(NGLOB_INNER_CORE) :: rmass_inner_core

! displacement, velocity, acceleration
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLOB_INNER_CORE) :: &
     displ_inner_core,veloc_inner_core,accel_inner_core

! Newmark time scheme parameters and non-dimensionalization
  real(kind=CUSTOM_REAL) time,deltat,deltatover2,deltatsqover2
  double precision scale_t,scale_displ,scale_veloc

! ADJOINT
  real(kind=CUSTOM_REAL) b_additional_term,b_force_normal_comp
  real(kind=CUSTOM_REAL) b_deltat,b_deltatover2,b_deltatsqover2
  real(kind=CUSTOM_REAL), dimension(:,:),allocatable :: &
    b_displ_crust_mantle,b_veloc_crust_mantle,b_accel_crust_mantle
  real(kind=CUSTOM_REAL), dimension(:),allocatable :: &
    b_displ_outer_core,b_veloc_outer_core,b_accel_outer_core
  real(kind=CUSTOM_REAL), dimension(:,:),allocatable :: &
    b_displ_inner_core,b_veloc_inner_core,b_accel_inner_core

  real(kind=CUSTOM_REAL), dimension(:,:,:,:),allocatable  :: b_div_displ_outer_core

  real(kind=CUSTOM_REAL) :: rho_kl, beta_kl, alpha_kl

  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable:: rho_kl_crust_mantle, &
     beta_kl_crust_mantle, alpha_kl_crust_mantle

  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable:: rho_kl_outer_core, &
     alpha_kl_outer_core

  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable:: rho_kl_inner_core, &
     beta_kl_inner_core, alpha_kl_inner_core

  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: absorb_xmin_crust_mantle, &
     absorb_xmax_crust_mantle, absorb_ymin_crust_mantle, absorb_ymax_crust_mantle

  real(kind=CUSTOM_REAL), dimension(:,:,:), allocatable :: absorb_xmin_outer_core, &
     absorb_xmax_outer_core, absorb_ymin_outer_core, absorb_ymax_outer_core, &
     absorb_zmin_outer_core

  integer reclen_xmin_crust_mantle, reclen_xmax_crust_mantle, reclen_ymin_crust_mantle, &
     reclen_ymax_crust_mantle, reclen_xmin_outer_core, reclen_xmax_outer_core,&
     reclen_ymin_outer_core, reclen_ymax_outer_core, reclen_zmin, reclen1, reclen2

  real(kind=CUSTOM_REAL), dimension(NDIM):: vector_accel_outer_core,b_vector_displ_outer_core

  real(kind=CUSTOM_REAL) xixl,xiyl,xizl,etaxl,etayl,etazl,gammaxl,gammayl,gammazl
  double precision scale_kl
! ADJOINT

  integer npoin2D_faces_crust_mantle(NUMFACES_SHARED)
  integer npoin2D_faces_outer_core(NUMFACES_SHARED)
  integer npoin2D_faces_inner_core(NUMFACES_SHARED)

! parameters for the source
  integer it,isource
  integer, dimension(:), allocatable :: islice_selected_source,ispec_selected_source
  integer yr,jda,ho,mi
  real(kind=CUSTOM_REAL) stf_used
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: sourcearray
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:), allocatable :: sourcearrays
  double precision, dimension(:,:,:) ,allocatable:: nu_source
  double precision sec,stf
  double precision, dimension(:), allocatable :: Mxx,Myy,Mzz,Mxy,Mxz,Myz
  double precision, dimension(:), allocatable :: xi_source,eta_source,gamma_source
  double precision, dimension(:), allocatable :: t_cmt,hdur,hdur_gaussian
  double precision, dimension(:), allocatable :: theta_source,phi_source
  double precision, external :: comp_source_time_function
  double precision t0

! receiver information
  integer nrec,nrec_local,nrec_tot_found
  integer irec_local
  integer, dimension(:), allocatable :: islice_selected_rec,ispec_selected_rec,number_receiver_global
  double precision, dimension(:), allocatable :: xi_receiver,eta_receiver,gamma_receiver
  double precision hlagrange
  character(len=150) STATIONS
  character(len=150) :: rec_filename
  double precision, dimension(:,:,:), allocatable :: nu
  double precision, allocatable, dimension(:) :: stlat,stlon,stele
  character(len=MAX_LENGTH_STATION_NAME), dimension(:), allocatable  :: station_name
  character(len=MAX_LENGTH_NETWORK_NAME), dimension(:), allocatable :: network_name

!ADJOINT
  character(len=150) adj_source_file
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:), allocatable :: adj_sourcearray
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:,:), allocatable :: adj_sourcearrays
  integer nrec_simulation, nadj_rec_local
  logical ibool_read_adj_arrays
  integer NSTEP_SUB_ADJ,it_sub_adj,iadj_block !To read input in chunks
  integer, dimension(:,:), allocatable :: iadjsrc !To read input in chunks
  integer, dimension(:), allocatable :: iadjsrc_len,iadj_vec
!ADJOINT


! seismograms
  integer it_begin,it_end,nit_written
  double precision uxd, uyd, uzd, eps_trace,dxx,dyy,dxy,dxz,dyz,eps_loc(NDIM,NDIM), eps_loc_new(NDIM,NDIM)
  real(kind=CUSTOM_REAL), dimension(:,:,:), allocatable :: seismograms

! non-dimensionalized rotation rate of the Earth times two
  real(kind=CUSTOM_REAL) two_omega_earth

! for the Euler scheme for rotation
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE_ROTATION) :: &
    A_array_rotation,B_array_rotation

  integer i,j,k,l,ispec,irec,iglob,iglob_mantle,iglob_inner_core

! number of faces between chunks
  integer NUM_FACES,NUMMSGS_FACES

! number of corners between chunks
  integer NCORNERSCHUNKS

! number of message types
  integer NUM_MSG_TYPES

! indirect addressing for each corner of the chunks
  integer, dimension(:,:), allocatable :: iboolcorner_crust_mantle,iboolcorner_outer_core,iboolcorner_inner_core

! buffers for send and receive between corners of the chunks
  real(kind=CUSTOM_REAL), dimension(:), allocatable :: buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar
  real(kind=CUSTOM_REAL), dimension(:,:), allocatable :: buffer_send_chunkcorners_vector,buffer_recv_chunkcorners_vector

! Gauss-Lobatto-Legendre points of integration and weights
  double precision, dimension(NGLLX) :: xigll,wxgll
  double precision, dimension(NGLLY) :: yigll,wygll
  double precision, dimension(NGLLZ) :: zigll,wzgll

! product of weights for gravity term
  double precision, dimension(NGLLX,NGLLY,NGLLZ) :: wgll_cube

! array with derivatives of Lagrange polynomials and precalculated products
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLX) :: hprime_xx,hprimewgll_xx
  real(kind=CUSTOM_REAL), dimension(NGLLY,NGLLY) :: hprime_yy,hprimewgll_yy
  real(kind=CUSTOM_REAL), dimension(NGLLZ,NGLLZ) :: hprime_zz,hprimewgll_zz
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY) :: wgllwgll_xy
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLZ) :: wgllwgll_xz
  real(kind=CUSTOM_REAL), dimension(NGLLY,NGLLZ) :: wgllwgll_yz

! Lagrange interpolators at receivers
  double precision, dimension(:), allocatable :: hxir,hetar,hgammar,hpxir,hpetar,hpgammar
  double precision, dimension(:,:), allocatable :: hxir_store,hetar_store,hgammar_store

! 2-D addressing and buffers for summation between slices
  integer, dimension(:), allocatable :: iboolleft_xi_crust_mantle, &
    iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle
  integer, dimension(:), allocatable :: iboolleft_xi_outer_core, &
    iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core
  integer, dimension(:), allocatable :: iboolleft_xi_inner_core, &
    iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core

! for addressing of the slices
  integer, dimension(:,:,:), allocatable :: addressing
  integer, dimension(:), allocatable :: ichunk_slice,iproc_xi_slice,iproc_eta_slice

! proc numbers for MPI
  integer myrank,sizeprocs,ier

! number of spectral elements and total number of global points
  integer nspec_crust_mantle,nglob_crust_mantle
  integer nspec_outer_core,nglob_outer_core

  integer npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle
  integer npoin2D_xi_outer_core,npoin2D_eta_outer_core
  integer npoin2D_xi_inner_core,npoin2D_eta_inner_core

  integer ichunk,iproc_xi,iproc_eta,iproc,iproc_read
  integer NPROC_ONE_DIRECTION

! maximum of the norm of the displacement and of the potential in the fluid
  real(kind=CUSTOM_REAL) Usolidnorm,Usolidnorm_all,Ufluidnorm,Ufluidnorm_all

!ADJOINT
  real(kind=CUSTOM_REAL) b_two_omega_earth
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: b_A_array_rotation,b_B_array_rotation
  real(kind=CUSTOM_REAL) b_Usolidnorm,b_Usolidnorm_all,b_Ufluidnorm,b_Ufluidnorm_all
  real(kind=CUSTOM_REAL) :: tempx1l,tempx2l,tempx3l
!ADJOINT

! timer MPI
  integer ihours,iminutes,iseconds,int_tCPU
  double precision time_start,tCPU

! parameters read from parameter file
  integer MIN_ATTENUATION_PERIOD,MAX_ATTENUATION_PERIOD,NER_CRUST, &
          NER_220_MOHO,NER_400_220,NER_600_400,NER_670_600,NER_771_670, &
          NER_TOPDDOUBLEPRIME_771,NER_CMB_TOPDDOUBLEPRIME,NER_ICB_CMB, &
          NER_TOP_CENTRAL_CUBE_ICB,NEX_XI,NEX_ETA,NER_DOUBLING_OUTER_CORE, &
          NPROC_XI,NPROC_ETA,NTSTEP_BETWEEN_OUTPUT_SEISMOS,&
          NTSTEP_BETWEEN_READ_ADJSRC,NSTEP,NSOURCES,NTSTEP_BETWEEN_FRAMES, &
          NER_ICB_BOTTOMDBL,NER_TOPDBL_CMB,NTSTEP_BETWEEN_OUTPUT_INFO,NUMBER_OF_RUNS, &
          NUMBER_OF_THIS_RUN,NCHUNKS,SIMULATION_TYPE,REFERENCE_1D_MODEL

  double precision DT,RATIO_BOTTOM_DBL_OC,RATIO_TOP_DBL_OC, &
          ANGULAR_WIDTH_XI_IN_DEGREES,ANGULAR_WIDTH_ETA_IN_DEGREES,CENTER_LONGITUDE_IN_DEGREES, &
          CENTER_LATITUDE_IN_DEGREES,GAMMA_ROTATION_AZIMUTH,ROCEAN,RMIDDLE_CRUST, &
          RMOHO,R80,R220,R400,R600,R670,R771,RTOPDDOUBLEPRIME,RCMB,RICB, &
          R_CENTRAL_CUBE,RHO_TOP_OC,RHO_BOTTOM_OC,RHO_OCEANS,HDUR_MOVIE

  logical TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE,ANISOTROPIC_INNER_CORE, &
          CRUSTAL,ELLIPTICITY,GRAVITY,ONE_CRUST,ROTATION,ISOTROPIC_3D_MANTLE, &
          TOPOGRAPHY,OCEANS,MOVIE_SURFACE,MOVIE_VOLUME,ATTENUATION_3D, &
          RECEIVERS_CAN_BE_BURIED,PRINT_SOURCE_TIME_FUNCTION, &
          SAVE_MESH_FILES,ATTENUATION, &
          ABSORBING_CONDITIONS,INCLUDE_CENTRAL_CUBE,INFLATE_CENTRAL_CUBE,SAVE_FORWARD

  character(len=150) OUTPUT_FILES,LOCAL_PATH,MODEL

! parameters deduced from parameters read from file
  integer NPROC,NPROCTOT,NEX_PER_PROC_XI,NEX_PER_PROC_ETA
  integer NER,NER_CMB_670,NER_670_400,NER_CENTRAL_CUBE_CMB

  integer, external :: err_occurred

  logical SAVE_STRAIN

! for SAC headers for seismograms
  integer NSOURCES_SAC,yr_SAC,jda_SAC,ho_SAC,mi_SAC
  real mb_SAC
  double precision t_cmt_SAC,elat_SAC,elon_SAC,depth_SAC,cmt_lat_SAC,cmt_lon_SAC,cmt_depth_SAC,cmt_hdur_SAC,sec_SAC
  character(len=12) ename_SAC

! this for all the regions
  integer, dimension(MAX_NUM_REGIONS) :: NSPEC_AB,NSPEC_AC,NSPEC_BC, &
               NSPEC2D_A_XI,NSPEC2D_B_XI,NSPEC2D_C_XI, &
               NSPEC2D_A_ETA,NSPEC2D_B_ETA,NSPEC2D_C_ETA, &
               NSPEC2DMAX_XMIN_XMAX,NSPEC2DMAX_YMIN_YMAX, &
               NSPEC2D_BOTTOM,NSPEC2D_TOP, &
               NSPEC1D_RADIAL,NPOIN1D_RADIAL, &
               NPOIN2DMAX_XMIN_XMAX,NPOIN2DMAX_YMIN_YMAX, &
               NGLOB_AB,NGLOB_AC,NGLOB_BC

  character(len=150) prname

! lookup table every km for gravity
  integer int_radius,nspl_gravity,idoubling
  real(kind=CUSTOM_REAL) minus_g_cmb,minus_g_icb
  double precision radius,radius_km,g,dg,rho,drhodr,vp,vs,Qkappa,Qmu
  double precision g_cmb_dble,g_icb_dble
  double precision, dimension(NRAD_GRAVITY) :: minus_gravity_table, &
    minus_deriv_gravity_table,density_table,d_ln_density_dr_table,minus_rho_g_over_kappa_fluid
  double precision rspl_gravity(NR),gspl(NR),gspl2(NR)

! flags to read kappa and mu and anisotropy arrays in regions where needed
  logical READ_KAPPA_MU,READ_TISO

! dummy arrays that do not need to be read
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: dummy_rho
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: &
        dummy_vstore, dummy_hstore, dummy_cstore

! names of the data files for all the processors in MPI
  character(len=150) outputname

!! DK DK UGLY if running on MareNostrum in Barcelona
  integer jobid,total_seismos_marenostrum,sender,receiver
  real(kind=CUSTOM_REAL), dimension(:,:), allocatable :: one_seismogram_marenostrum
  character(len=400) system_command

  integer iregion_selected

! ************** PROGRAM STARTS HERE **************

! sizeprocs returns number of processes started (should be equal to NPROCTOT).
! myrank is the rank of each process, between 0 and sizeprocs-1.
! as usual in MPI, process 0 is in charge of coordinating everything
! and also takes care of the main output
  call MPI_COMM_SIZE(MPI_COMM_WORLD,sizeprocs,ier)
  call MPI_COMM_RANK(MPI_COMM_WORLD,myrank,ier)

! read the parameter file
  call read_parameter_file(MIN_ATTENUATION_PERIOD,MAX_ATTENUATION_PERIOD,NER_CRUST, &
          NER_220_MOHO,NER_400_220,NER_600_400,NER_670_600,NER_771_670, &
          NER_TOPDDOUBLEPRIME_771,NER_CMB_TOPDDOUBLEPRIME,NER_ICB_CMB, &
          NER_TOP_CENTRAL_CUBE_ICB,NEX_XI,NEX_ETA,NER_DOUBLING_OUTER_CORE, &
          NPROC_XI,NPROC_ETA,NTSTEP_BETWEEN_OUTPUT_SEISMOS, &
          NTSTEP_BETWEEN_READ_ADJSRC,NSTEP,NTSTEP_BETWEEN_FRAMES, &
          NER_ICB_BOTTOMDBL,NER_TOPDBL_CMB,NTSTEP_BETWEEN_OUTPUT_INFO,NUMBER_OF_RUNS, &
          NUMBER_OF_THIS_RUN,NCHUNKS,DT,RATIO_BOTTOM_DBL_OC,RATIO_TOP_DBL_OC, &
          ANGULAR_WIDTH_XI_IN_DEGREES,ANGULAR_WIDTH_ETA_IN_DEGREES,CENTER_LONGITUDE_IN_DEGREES, &
          CENTER_LATITUDE_IN_DEGREES,GAMMA_ROTATION_AZIMUTH,ROCEAN,RMIDDLE_CRUST, &
          RMOHO,R80,R220,R400,R600,R670,R771,RTOPDDOUBLEPRIME,RCMB,RICB, &
          R_CENTRAL_CUBE,RHO_TOP_OC,RHO_BOTTOM_OC,RHO_OCEANS,HDUR_MOVIE, &
          TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE, &
          ANISOTROPIC_INNER_CORE,CRUSTAL,ELLIPTICITY,GRAVITY,ONE_CRUST, &
          ROTATION,ISOTROPIC_3D_MANTLE,TOPOGRAPHY,OCEANS,MOVIE_SURFACE, &
          MOVIE_VOLUME,ATTENUATION_3D,RECEIVERS_CAN_BE_BURIED, &
          PRINT_SOURCE_TIME_FUNCTION,SAVE_MESH_FILES, &
          ATTENUATION,REFERENCE_1D_MODEL,ABSORBING_CONDITIONS, &
          INCLUDE_CENTRAL_CUBE,INFLATE_CENTRAL_CUBE,LOCAL_PATH,MODEL,SIMULATION_TYPE,SAVE_FORWARD)

  if(err_occurred() /= 0) stop 'an error occurred while reading the parameter file'

! count the total number of sources in the CMTSOLUTION file
  call count_number_of_sources(NSOURCES)
! broadcast the information read on the master to the nodes
  call MPI_BCAST(NSOURCES,1,MPI_INTEGER,0,MPI_COMM_WORLD,ier)

!! DK DK UGLY if running on MareNostrum in Barcelona
  if(RUN_ON_MARENOSTRUM_BARCELONA) then

! use the local scratch disk to save all the files, ignore the path that is given in the Par_file
    LOCAL_PATH = '/scratch/komatits'

! add processor name to local /scratch/komatits path
    write(system_command,"('_proc',i4.4)") myrank
    LOCAL_PATH = trim(LOCAL_PATH) // trim(system_command)

! allocate array to gather the seismograms
    allocate(one_seismogram_marenostrum(NDIM,NSTEP))

  endif

! check simulation pararmeters
  if (SIMULATION_TYPE /= 1 .and.  SIMULATION_TYPE /= 2 .and. SIMULATION_TYPE /= 3) &
          call exit_MPI(myrank, 'SIMULATION_TYPE could be only 1, 2, or 3')
  if (SIMULATION_TYPE /= 1 .and. NSOURCES >= 100000)  &
    call exit_MPI(myrank, 'for adjoint simulations, NSOURCES < 100000')
  if (SIMULATION_TYPE == 3 .and. ATTENUATION) &
    call exit_MPI(myrank, 'attenuation is not implemented for kernel simulations yet')
  if (SIMULATION_TYPE == 3 .and. ANISOTROPIC_3D_MANTLE_VAL .or. ANISOTROPIC_INNER_CORE_VAL) &
     call exit_MPI(myrank, 'anisotropic model is not implemented for kernel simulations yet')
  if (ATTENUATION .or. SIMULATION_TYPE /= 1 .or. SAVE_FORWARD .or. (MOVIE_VOLUME .and. SIMULATION_TYPE /= 3)) then
    SAVE_STRAIN = .true.
  else
    SAVE_STRAIN = .false.
  endif

! compute other parameters based upon values read
  call compute_parameters(NER_CRUST,NER_220_MOHO,NER_400_220, &
      NER_600_400,NER_670_600,NER_771_670,NER_TOPDDOUBLEPRIME_771, &
      NER_CMB_TOPDDOUBLEPRIME,NER_ICB_CMB,NER_TOP_CENTRAL_CUBE_ICB, &
      NER,NER_CMB_670,NER_670_400,NER_CENTRAL_CUBE_CMB, &
      NEX_XI,NEX_ETA,NPROC_XI,NPROC_ETA, &
      NPROC,NPROCTOT,NEX_PER_PROC_XI,NEX_PER_PROC_ETA, &
      NSPEC_AB,NSPEC_AC,NSPEC_BC, &
      NSPEC2D_A_XI,NSPEC2D_B_XI,NSPEC2D_C_XI, &
      NSPEC2D_A_ETA,NSPEC2D_B_ETA,NSPEC2D_C_ETA, &
      NSPEC2DMAX_XMIN_XMAX,NSPEC2DMAX_YMIN_YMAX,NSPEC2D_BOTTOM,NSPEC2D_TOP, &
      NSPEC1D_RADIAL,NPOIN1D_RADIAL, &
      NPOIN2DMAX_XMIN_XMAX,NPOIN2DMAX_YMIN_YMAX, &
      NGLOB_AB,NGLOB_AC,NGLOB_BC,NER_ICB_BOTTOMDBL,NER_TOPDBL_CMB,NCHUNKS,INCLUDE_CENTRAL_CUBE)

! get the base pathname for output files
  call get_value_string(OUTPUT_FILES, 'OUTPUT_FILES', 'OUTPUT_FILES')

! open main output file, only written to by process 0
  if(myrank == 0 .and. IMAIN /= ISTANDARD_OUTPUT) &
    open(unit=IMAIN,file=trim(OUTPUT_FILES)//'/output_solver.txt',status='unknown')

  if(myrank == 0) then

  write(IMAIN,*)
  write(IMAIN,*) '******************************'
  write(IMAIN,*) '**** Specfem3D MPI Solver ****'
  write(IMAIN,*) '******************************'
  write(IMAIN,*)
  write(IMAIN,*)

  if(FIX_UNDERFLOW_PROBLEM) write(IMAIN,*) 'Fixing slow underflow trapping problem using small initial field'

  write(IMAIN,*)
  write(IMAIN,*) 'There are ',sizeprocs,' MPI processes'
  write(IMAIN,*) 'Processes are numbered from 0 to ',sizeprocs-1
  write(IMAIN,*)

  write(IMAIN,*) 'There are ',NEX_XI,' elements along xi in each chunk'
  write(IMAIN,*) 'There are ',NEX_ETA,' elements along eta in each chunk'
  write(IMAIN,*)
  write(IMAIN,*) 'There are ',NPROC_XI,' slices along xi in each chunk'
  write(IMAIN,*) 'There are ',NPROC_ETA,' slices along eta in each chunk'
  write(IMAIN,*) 'There is a total of ',NPROC,' slices in each chunk'
  write(IMAIN,*) 'There are ',NCHUNKS,' chunks'
  write(IMAIN,*) 'There is a total of ',NPROCTOT,' slices in all the chunks'

  write(IMAIN,*)
  write(IMAIN,*) 'NDIM = ',NDIM
  write(IMAIN,*)
  write(IMAIN,*) 'NGLLX = ',NGLLX
  write(IMAIN,*) 'NGLLY = ',NGLLY
  write(IMAIN,*) 'NGLLZ = ',NGLLZ
  write(IMAIN,*)

! write information about precision used for floating-point operations
  if(CUSTOM_REAL == SIZE_REAL) then
    write(IMAIN,*) 'using single precision for the calculations'
  else
    write(IMAIN,*) 'using double precision for the calculations'
  endif
  write(IMAIN,*)
  write(IMAIN,*) 'smallest and largest possible floating-point numbers are: ',tiny(1._CUSTOM_REAL),huge(1._CUSTOM_REAL)
  write(IMAIN,*)

  endif

! check that the code is running with the requested nb of processes
  if(sizeprocs /= NPROCTOT) call exit_MPI(myrank,'wrong number of MPI processes')

! check that the code has been compiled with the right values
  if(NSPEC_AB(IREGION_CRUST_MANTLE) /= NSPEC_CRUST_MANTLE_AB .or. &
     NSPEC_AC(IREGION_CRUST_MANTLE) /= NSPEC_CRUST_MANTLE_AC .or. &
     NSPEC_BC(IREGION_CRUST_MANTLE) /= NSPEC_CRUST_MANTLE_BC .or. &
     NSPEC_AB(IREGION_OUTER_CORE) /= NSPEC_OUTER_CORE_AB .or. &
     NSPEC_AC(IREGION_OUTER_CORE) /= NSPEC_OUTER_CORE_AC .or. &
     NSPEC_BC(IREGION_OUTER_CORE) /= NSPEC_OUTER_CORE_BC .or. &
     NSPEC_AB(IREGION_INNER_CORE) /= NSPEC_INNER_CORE) then
     if (myrank==0) then
       write(IMAIN,*) NSPEC_AB(IREGION_CRUST_MANTLE),NSPEC_CRUST_MANTLE_AB
       write(IMAIN,*) NSPEC_AC(IREGION_CRUST_MANTLE),NSPEC_CRUST_MANTLE_AC
       write(IMAIN,*) NSPEC_BC(IREGION_CRUST_MANTLE),NSPEC_CRUST_MANTLE_BC
       write(IMAIN,*) NSPEC_AB(IREGION_OUTER_CORE), NSPEC_OUTER_CORE_AB
       write(IMAIN,*) NSPEC_AC(IREGION_OUTER_CORE), NSPEC_OUTER_CORE_AC
       write(IMAIN,*) NSPEC_BC(IREGION_OUTER_CORE), NSPEC_OUTER_CORE_BC
       write(IMAIN,*) NSPEC_AB(IREGION_INNER_CORE), NSPEC_INNER_CORE
     endif
       call exit_MPI(myrank,'error in compiled parameters, please recompile solver')
  endif
! dynamic allocation of arrays

! indirect addressing for each corner of the chunks
! maximum size is found in the mantle which has the largest number of points
  allocate(iboolcorner_crust_mantle(NPOIN1D_RADIAL(IREGION_CRUST_MANTLE),NUMCORNERS_SHARED))
  allocate(iboolcorner_outer_core(NPOIN1D_RADIAL(IREGION_OUTER_CORE),NUMCORNERS_SHARED))
  allocate(iboolcorner_inner_core(NPOIN1D_RADIAL(IREGION_INNER_CORE),NUMCORNERS_SHARED))

! buffers for send and receive between corners of the chunks
  allocate(buffer_send_chunkcorners_scalar(NPOIN1D_RADIAL(IREGION_CRUST_MANTLE)))
  allocate(buffer_recv_chunkcorners_scalar(NPOIN1D_RADIAL(IREGION_CRUST_MANTLE)))

  allocate(buffer_send_chunkcorners_vector(NDIM,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE)))
  allocate(buffer_recv_chunkcorners_vector(NDIM,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE)))

! 2-D addressing and buffers for summation between slices, and point codes
! use number of elements found in the mantle since it is the largest region

! crust and mantle
  allocate(iboolleft_xi_crust_mantle(NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(iboolright_xi_crust_mantle(NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(iboolleft_eta_crust_mantle(NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(iboolright_eta_crust_mantle(NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))

! outer core
  allocate(iboolleft_xi_outer_core(NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(iboolright_xi_outer_core(NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(iboolleft_eta_outer_core(NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(iboolright_eta_outer_core(NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))

! inner core
  allocate(iboolleft_xi_inner_core(NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE)))
  allocate(iboolright_xi_inner_core(NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE)))
  allocate(iboolleft_eta_inner_core(NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE)))
  allocate(iboolright_eta_inner_core(NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE)))

! for addressing of the slices
  allocate(addressing(NCHUNKS,0:NPROC_XI-1,0:NPROC_ETA-1))
  allocate(ichunk_slice(0:NPROCTOT-1))
  allocate(iproc_xi_slice(0:NPROCTOT-1))
  allocate(iproc_eta_slice(0:NPROCTOT-1))

! open file with global slice number addressing
  if(myrank == 0) then
    open(unit=IIN,file=trim(OUTPUT_FILES)//'/addressing.txt',status='old',action='read')
    do iproc = 0,NPROCTOT-1
      read(IIN,*) iproc_read,ichunk,iproc_xi,iproc_eta
      if(iproc_read /= iproc) call exit_MPI(myrank,'incorrect slice number read')
      addressing(ichunk,iproc_xi,iproc_eta) = iproc
      ichunk_slice(iproc) = ichunk
      iproc_xi_slice(iproc) = iproc_xi
      iproc_eta_slice(iproc) = iproc_eta
    enddo
    close(IIN)
  endif

! broadcast the information read on the master to the nodes
  call MPI_BCAST(addressing,NCHUNKS*NPROC_XI*NPROC_ETA,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
  call MPI_BCAST(ichunk_slice,NPROCTOT,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
  call MPI_BCAST(iproc_xi_slice,NPROCTOT,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
  call MPI_BCAST(iproc_eta_slice,NPROCTOT,MPI_INTEGER,0,MPI_COMM_WORLD,ier)

! LQY - output a topology map of slices - fix 20x by nproc
  if (myrank == 0 .and. NCHUNKS == 6) then
    write(IMAIN,*) 'Spatial distribution of the slices'
    do iproc_xi = NPROC_XI-1, 0, -1
      write(IMAIN,'(20x)',advance='no')
      do iproc_eta = NPROC_ETA -1, 0, -1
        write(IMAIN,'(i5)',advance='no') addressing(CHUNK_AB,iproc_xi,iproc_eta)
      enddo
      write(IMAIN,'(1x)',advance='yes')
    enddo
    write(IMAIN, *) ' '
    do iproc_xi = NPROC_XI-1, 0, -1
      write(IMAIN,'(1x)',advance='no')
      do iproc_eta = NPROC_ETA -1, 0, -1
        write(IMAIN,'(i5)',advance='no') addressing(CHUNK_BC,iproc_xi,iproc_eta)
      enddo
      write(IMAIN,'(3x)',advance='no')
      do iproc_eta = NPROC_ETA -1, 0, -1
        write(IMAIN,'(i5)',advance='no') addressing(CHUNK_AC,iproc_xi,iproc_eta)
      enddo
      write(IMAIN,'(3x)',advance='no')
      do iproc_eta = NPROC_ETA -1, 0, -1
        write(IMAIN,'(i5)',advance='no') addressing(CHUNK_BC_ANTIPODE,iproc_xi,iproc_eta)
      enddo
      write(IMAIN,'(1x)',advance='yes')
    enddo
    write(IMAIN, *) ' '
    do iproc_xi = NPROC_XI-1, 0, -1
      write(IMAIN,'(20x)',advance='no')
      do iproc_eta = NPROC_ETA -1, 0, -1
        write(IMAIN,'(i5)',advance='no') addressing(CHUNK_AB_ANTIPODE,iproc_xi,iproc_eta)
      enddo
      write(IMAIN,'(1x)',advance='yes')
    enddo
    write(IMAIN, *) ' '
    do iproc_xi = NPROC_XI-1, 0, -1
      write(IMAIN,'(20x)',advance='no')
      do iproc_eta = NPROC_ETA -1, 0, -1
        write(IMAIN,'(i5)',advance='no') addressing(CHUNK_AC_ANTIPODE,iproc_xi,iproc_eta)
      enddo
      write(IMAIN,'(1x)',advance='yes')
    enddo
    write(IMAIN, *) ' '
  endif

! determine chunk number and local slice coordinates using addressing
  ichunk = ichunk_slice(myrank)
  iproc_xi = iproc_xi_slice(myrank)
  iproc_eta = iproc_eta_slice(myrank)

! check chunk number and assign theoretical number of elements
  if(ichunk == CHUNK_AB .or. ichunk == CHUNK_AB_ANTIPODE) then
    nspec_crust_mantle = NSPEC_AB(IREGION_CRUST_MANTLE)
    nglob_crust_mantle = NGLOB_AB(IREGION_CRUST_MANTLE)
    nspec_outer_core = NSPEC_AB(IREGION_OUTER_CORE)
    nglob_outer_core = NGLOB_AB(IREGION_OUTER_CORE)
  else if(ichunk == CHUNK_AC .or. ichunk == CHUNK_AC_ANTIPODE) then
    nspec_crust_mantle = NSPEC_AC(IREGION_CRUST_MANTLE)
    nglob_crust_mantle = NGLOB_AC(IREGION_CRUST_MANTLE)
    nspec_outer_core = NSPEC_AC(IREGION_OUTER_CORE)
    nglob_outer_core = NGLOB_AC(IREGION_OUTER_CORE)
  else if(ichunk == CHUNK_BC .or. ichunk == CHUNK_BC_ANTIPODE) then
    nspec_crust_mantle = NSPEC_BC(IREGION_CRUST_MANTLE)
    nglob_crust_mantle = NGLOB_BC(IREGION_CRUST_MANTLE)
    nspec_outer_core = NSPEC_BC(IREGION_OUTER_CORE)
    nglob_outer_core = NGLOB_BC(IREGION_OUTER_CORE)
  else
    call exit_MPI(myrank,'incorrect chunk number')
  endif

! make ellipticity
  if(ELLIPTICITY) then
    call make_ellipticity(nspl,rspl,espl,espl2,ONE_CRUST)

! compute ellipticity at d80 once and for all for attenuation
    radius = R80/R_EARTH
    call splint(rspl,espl,espl2,nspl,radius,ell_d80_dble)

! distinguish between single and double precision for reals
    if(CUSTOM_REAL == SIZE_REAL) then
      ell_d80 = sngl(ell_d80_dble)
    else
      ell_d80 = ell_d80_dble
    endif

  endif

! define maximum size for message buffers
! use number of elements found in the mantle since it is the largest region
  NPOIN2DMAX_XY = max(NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE))

! allocate arrays for message buffers with maximum size

  allocate(iboolfaces_crust_mantle(NPOIN2DMAX_XY,NUMFACES_SHARED))
  allocate(iboolfaces_outer_core(NPOIN2DMAX_XY,NUMFACES_SHARED))
  allocate(iboolfaces_inner_core(NPOIN2DMAX_XY,NUMFACES_SHARED))

  allocate(buffer_send_faces_scalar(NPOIN2DMAX_XY))
  allocate(buffer_received_faces_scalar(NPOIN2DMAX_XY))

  allocate(buffer_send_faces_vector(NDIM,NPOIN2DMAX_XY))
  allocate(buffer_received_faces_vector(NDIM,NPOIN2DMAX_XY))

! number of corners and faces shared between chunks and number of message types
  if(NCHUNKS == 1 .or. NCHUNKS == 2) then
    NCORNERSCHUNKS = 1
    NUM_FACES = 1
    NUM_MSG_TYPES = 1
  else if(NCHUNKS == 3) then
    NCORNERSCHUNKS = 1
    NUM_FACES = 1
    NUM_MSG_TYPES = 3
  else if(NCHUNKS == 6) then
    NCORNERSCHUNKS = 8
    NUM_FACES = 4
    NUM_MSG_TYPES = 3
  else
    call exit_MPI(myrank,'number of chunks must be either 1, 2, 3 or 6')
  endif

! if more than one chunk then same number of processors in each direction
  NPROC_ONE_DIRECTION = NPROC_XI

! total number of messages corresponding to these common faces
  NUMMSGS_FACES = NPROC_ONE_DIRECTION*NUM_FACES*NUM_MSG_TYPES

! allocate array for messages for faces
  allocate(iprocfrom_faces(NUMMSGS_FACES))
  allocate(iprocto_faces(NUMMSGS_FACES))
  allocate(imsg_type(NUMMSGS_FACES))

! allocate array for messages for corners
  allocate(iproc_master_corners(NCORNERSCHUNKS))
  allocate(iproc_worker1_corners(NCORNERSCHUNKS))
  allocate(iproc_worker2_corners(NCORNERSCHUNKS))

! attenuation
  if(ATTENUATION) then
     if(ATTENUATION_3D) then
        ! for all points in the mesh
        ! Allocate CRUST MANTLE
        i     = NGLLX
        j     = NGLLY
        k     = NGLLZ
        l     = nspec_crust_mantle
        ispec = NSPEC_INNER_CORE
     else
        i     = 1
        j     = 1
        k     = 1
        l     = NRAD_ATTENUATION
        ispec = NRAD_ATTENUATION
     endif
     allocate(      factor_scale_crust_mantle(       i, j, k, l))
     allocate(one_minus_sum_beta_crust_mantle(       i, j, k, l))
     allocate(     factor_common_crust_mantle(N_SLS, i, j, k, l))

     allocate( factor_scale_crust_mantle_dble(       i, j, k, l))
     allocate(         omsb_crust_mantle_dble(       i, j, k, l))
     allocate(factor_common_crust_mantle_dble(N_SLS, i, j, k, l))
     ! Allocate INNER CORE
     allocate(      factor_scale_inner_core(       i, j, k, ispec))
     allocate(one_minus_sum_beta_inner_core(       i, j, k, ispec))
     allocate(     factor_common_inner_core(N_SLS, i, j, k, ispec))

     allocate( factor_scale_inner_core_dble(       i, j, k, ispec))
     allocate(         omsb_inner_core_dble(       i, j, k, ispec))
     allocate(factor_common_inner_core_dble(N_SLS, i, j, k, ispec))
  endif

! start reading the databases

! read arrays created by the mesher

! crust and mantle

  if(ANISOTROPIC_3D_MANTLE) then
    READ_KAPPA_MU = .false.
    READ_TISO = .false.
    nspec_iso = 1
    nspec_tiso = 1
    nspec_ani = nspec_crust_mantle
  else
    nspec_iso = nspec_crust_mantle
    if(TRANSVERSE_ISOTROPY) then
      nspec_tiso = NSPECMAX_TISO_MANTLE
    else
      nspec_tiso = 1
    endif
    nspec_ani = 1
    READ_KAPPA_MU = .true.
    READ_TISO = .true.
  endif
  call read_arrays_solver(IREGION_CRUST_MANTLE,myrank, &
            rho_vp_crust_mantle,rho_vs_crust_mantle, &
            xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
            xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle, &
            etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
            gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,jacobian_crust_mantle, &
            rhostore_crust_mantle,kappavstore_crust_mantle,muvstore_crust_mantle, &
            kappahstore_crust_mantle,muhstore_crust_mantle,eta_anisostore_crust_mantle, &
            nspec_iso,nspec_tiso,nspec_ani, &
            c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle, &
            c14store_crust_mantle,c15store_crust_mantle,c16store_crust_mantle, &
            c22store_crust_mantle,c23store_crust_mantle,c24store_crust_mantle, &
            c25store_crust_mantle,c26store_crust_mantle,c33store_crust_mantle, &
            c34store_crust_mantle,c35store_crust_mantle,c36store_crust_mantle, &
            c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
            c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
            ibool_crust_mantle,idoubling_crust_mantle,rmass_crust_mantle,rmass_ocean_load, &
            nspec_crust_mantle,nglob_crust_mantle, &
            READ_KAPPA_MU,READ_TISO,TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE, &
            ANISOTROPIC_INNER_CORE,OCEANS,LOCAL_PATH,NCHUNKS)

! outer core (no anisotropy nor S velocity)
! rmass_ocean_load is not modified in routine
  READ_KAPPA_MU = .false.
  READ_TISO = .false.
  nspec_iso = nspec_outer_core
  nspec_tiso = 1
  nspec_ani = 1

  allocate(dummy_rho(NGLLX,NGLLY,NGLLZ,nspec_outer_core))
  allocate(dummy_vstore(NGLLX,NGLLY,NGLLZ,nspec_iso))
  allocate(dummy_hstore(NGLLX,NGLLY,NGLLZ,nspec_tiso))
  allocate(dummy_cstore(NGLLX,NGLLY,NGLLZ,nspec_ani))

  call read_arrays_solver(IREGION_OUTER_CORE,myrank, &
            vp_outer_core,dummy_rho, &
            xstore_outer_core,ystore_outer_core,zstore_outer_core, &
            xix_outer_core,xiy_outer_core,xiz_outer_core, &
            etax_outer_core,etay_outer_core,etaz_outer_core, &
            gammax_outer_core,gammay_outer_core,gammaz_outer_core,jacobian_outer_core, &
            rhostore_outer_core,kappavstore_outer_core,dummy_vstore, &
            dummy_hstore,dummy_hstore,dummy_hstore, &
            nspec_iso,nspec_tiso,nspec_ani, &
            dummy_cstore,dummy_cstore,dummy_cstore, &
            dummy_cstore,dummy_cstore,dummy_cstore, &
            dummy_cstore,dummy_cstore,dummy_cstore, &
            dummy_cstore,dummy_cstore,dummy_cstore, &
            dummy_cstore,dummy_cstore,dummy_cstore, &
            dummy_cstore,dummy_cstore,dummy_cstore, &
            dummy_cstore,dummy_cstore,dummy_cstore, &
            ibool_outer_core,idoubling_outer_core,rmass_outer_core,rmass_ocean_load, &
            nspec_outer_core,nglob_outer_core, &
            READ_KAPPA_MU,READ_TISO,TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE, &
            ANISOTROPIC_INNER_CORE,OCEANS,LOCAL_PATH,NCHUNKS)

  deallocate(dummy_rho)
  deallocate(dummy_vstore)
  deallocate(dummy_hstore)
  deallocate(dummy_cstore)

! inner core (no anisotropy)
! rmass_ocean_load is not modified in routine
  READ_KAPPA_MU = .true.
  READ_TISO = .false.
  nspec_iso = NSPEC_INNER_CORE
  nspec_tiso = 1
  if(ANISOTROPIC_INNER_CORE) then
    nspec_ani = NSPEC_INNER_CORE
  else
    nspec_ani = 1
  endif

  allocate(dummy_rho(NGLLX,NGLLY,NGLLZ,nspec_inner_core))
  allocate(dummy_vstore(NGLLX,NGLLY,NGLLZ,nspec_iso))
  allocate(dummy_hstore(NGLLX,NGLLY,NGLLZ,nspec_tiso))
  allocate(dummy_cstore(NGLLX,NGLLY,NGLLZ,nspec_ani))

  call read_arrays_solver(IREGION_INNER_CORE,myrank, &
            dummy_rho,dummy_rho, &
            xstore_inner_core,ystore_inner_core,zstore_inner_core, &
            xix_inner_core,xiy_inner_core,xiz_inner_core, &
            etax_inner_core,etay_inner_core,etaz_inner_core, &
            gammax_inner_core,gammay_inner_core,gammaz_inner_core,jacobian_inner_core, &
            rhostore_inner_core,kappavstore_inner_core,muvstore_inner_core, &
            dummy_hstore,dummy_hstore,dummy_hstore, &
            nspec_iso,nspec_tiso,nspec_ani, &
            c11store_inner_core,c12store_inner_core,c13store_inner_core, &
            dummy_cstore,dummy_cstore,dummy_cstore, &
            dummy_cstore,dummy_cstore,dummy_cstore, &
            dummy_cstore,dummy_cstore,c33store_inner_core, &
            dummy_cstore,dummy_cstore,dummy_cstore, &
            c44store_inner_core,dummy_cstore,dummy_cstore, &
            dummy_cstore,dummy_cstore,dummy_cstore, &
            ibool_inner_core,idoubling_inner_core,rmass_inner_core,rmass_ocean_load, &
            NSPEC_INNER_CORE,NGLOB_INNER_CORE, &
            READ_KAPPA_MU,READ_TISO,TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE, &
            ANISOTROPIC_INNER_CORE,OCEANS,LOCAL_PATH,NCHUNKS)

  deallocate(dummy_rho)
  deallocate(dummy_vstore)
  deallocate(dummy_hstore)
  deallocate(dummy_cstore)

! check that the number of points in this slice is correct

  if(minval(ibool_crust_mantle(:,:,:,1:nspec_crust_mantle)) /= 1 .or. &
    maxval(ibool_crust_mantle(:,:,:,1:nspec_crust_mantle)) /= nglob_crust_mantle) &
      call exit_MPI(myrank,'incorrect global numbering: iboolmax does not equal nglob in crust and mantle')

  if(minval(ibool_outer_core(:,:,:,1:nspec_outer_core)) /= 1 .or. &
     maxval(ibool_outer_core(:,:,:,1:nspec_outer_core)) /= nglob_outer_core) &
    call exit_MPI(myrank,'incorrect global numbering: iboolmax does not equal nglob in outer core')

  if(minval(ibool_inner_core(:,:,:,:)) /= 1 .or. maxval(ibool_inner_core(:,:,:,:)) /= NGLOB_INNER_CORE) &
    call exit_MPI(myrank,'incorrect global numbering: iboolmax does not equal nglob in inner core')

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

! set up GLL points, weights and derivation matrices
  call define_derivation_matrices(xigll,yigll,zigll,wxgll,wygll,wzgll, &
         hprime_xx,hprime_yy,hprime_zz, &
         hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
         wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube)

! read topography and bathymetry file
  if(myrank == 0 .and. (TOPOGRAPHY .or. OCEANS)) call read_topo_bathy_file(ibathy_topo)
! broadcast the information read on the master to the nodes
  call MPI_BCAST(ibathy_topo,NX_BATHY*NY_BATHY,MPI_INTEGER,0,MPI_COMM_WORLD,ier)

! allocate arrays for source
  allocate(islice_selected_source(NSOURCES))
  allocate(ispec_selected_source(NSOURCES))
  allocate(Mxx(NSOURCES))
  allocate(Myy(NSOURCES))
  allocate(Mzz(NSOURCES))
  allocate(Mxy(NSOURCES))
  allocate(Mxz(NSOURCES))
  allocate(Myz(NSOURCES))
  allocate(xi_source(NSOURCES))
  allocate(eta_source(NSOURCES))
  allocate(gamma_source(NSOURCES))
  allocate(t_cmt(NSOURCES))
  allocate(hdur(NSOURCES))
  allocate(hdur_gaussian(NSOURCES))
  allocate(theta_source(NSOURCES))
  allocate(phi_source(NSOURCES))
  allocate(nu_source(NDIM,NDIM,NSOURCES))

! locate sources in the mesh
  call locate_sources(NSOURCES,myrank,nspec_crust_mantle, &
            nglob_crust_mantle,idoubling_crust_mantle,ibool_crust_mantle, &
            xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
            xigll,yigll,zigll,NPROCTOT,ELLIPTICITY,TOPOGRAPHY, &
            sec,t_cmt,yr,jda,ho,mi,theta_source,phi_source, &
            NSTEP,DT,hdur,Mxx,Myy,Mzz,Mxy,Mxz,Myz, &
            islice_selected_source,ispec_selected_source, &
            xi_source,eta_source,gamma_source, nu_source,&
            rspl,espl,espl2,nspl,ibathy_topo,NEX_XI,PRINT_SOURCE_TIME_FUNCTION)

  if(minval(t_cmt) /= 0.) call exit_MPI(myrank,'one t_cmt must be zero, others must be positive')

! filter source time function by Gaussian with hdur = HDUR_MOVIE when outputing movies or shakemaps
  if (MOVIE_SURFACE .or. MOVIE_VOLUME ) then
     hdur = sqrt(hdur**2 + HDUR_MOVIE**2)
     if(myrank == 0) then
        write(IMAIN,*)
        write(IMAIN,*) 'Each source is being convolved with HDUR_MOVIE = ',HDUR_MOVIE
        write(IMAIN,*)
     endif
  endif
! convert the half duration for triangle STF to the one for gaussian STF
  hdur_gaussian = hdur/SOURCE_DECAY_RATE

! define t0 as the earliest start time
  t0 = - 1.5d0*minval(t_cmt-hdur)

! --------- receivers ---------------
  if (SIMULATION_TYPE == 1) then
    rec_filename = 'DATA/STATIONS'
  else
    rec_filename = 'DATA/STATIONS_ADJOINT'
  endif
  call get_value_string(STATIONS, 'solver.STATIONS', rec_filename)

  if(myrank == 0) then
    open(unit=IIN,file=STATIONS,status='old',action='read')
    read(IIN,*) nrec
    close(IIN)
  endif
! broadcast the information read on the master to the nodes
  call MPI_BCAST(nrec,1,MPI_INTEGER,0,MPI_COMM_WORLD,ier)

  if(myrank == 0) then
    write(IMAIN,*)
    if (SIMULATION_TYPE == 1 .or. SIMULATION_TYPE == 3) then
      write(IMAIN,*) 'Total number of receivers = ', nrec
    else
      write(IMAIN,*) 'Total number of adjoint sources = ', nrec
    endif
    write(IMAIN,*)
! write source and receiver VTK files for Paraview
    open(IOVTK,file=trim(OUTPUT_FILES)//'/sr.vtk',status='unknown')
    write(IOVTK,'(a)') '# vtk DataFile Version 2.0'
    write(IOVTK,'(a)') 'Source and Receiver VTK file'
    write(IOVTK,'(a)') 'ASCII'
    write(IOVTK,'(a)') 'DATASET UNSTRUCTURED_GRID'
!  LQY -- won't be able to know NSOURCES+nrec at this point...
    write(IOVTK, '(a,i6,a)') 'POINTS ', 2, ' float'
  endif

  if(nrec < 1) call exit_MPI(myrank,'need at least one receiver')

! allocate memory for receiver arrays
  allocate(islice_selected_rec(nrec))
  allocate(ispec_selected_rec(nrec))
  allocate(xi_receiver(nrec))
  allocate(eta_receiver(nrec))
  allocate(gamma_receiver(nrec))
  allocate(station_name(nrec))
  allocate(network_name(nrec))
  allocate(stlat(nrec))
  allocate(stlon(nrec))
  allocate(stele(nrec))
  allocate(nu(NDIM,NDIM,nrec))

! locate receivers in the crust in the mesh
  call locate_receivers(myrank,DT,NSTEP,nspec_crust_mantle, &
            nglob_crust_mantle,ibool_crust_mantle, &
            xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
            xigll,yigll,zigll,trim(rec_filename), &
            nrec,islice_selected_rec,ispec_selected_rec, &
            xi_receiver,eta_receiver,gamma_receiver,station_name,network_name,stlat,stlon,stele,nu, &
            yr,jda,ho,mi,sec, &
            NPROCTOT,ELLIPTICITY,TOPOGRAPHY, &
            theta_source(1),phi_source(1),rspl,espl,espl2,nspl,ibathy_topo,RECEIVERS_CAN_BE_BURIED,NCHUNKS)

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

! read 2-D addressing for summation between slices with MPI

! mantle and crust
  call read_arrays_buffers_solver(IREGION_CRUST_MANTLE,myrank,iboolleft_xi_crust_mantle, &
     iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
     npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
     iprocfrom_faces,iprocto_faces,imsg_type, &
     iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
     iboolfaces_crust_mantle,npoin2D_faces_crust_mantle, &
     iboolcorner_crust_mantle, &
     NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE), &
     NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_XY,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE), &
     NUMMSGS_FACES,NCORNERSCHUNKS,NPROCTOT,NPROC_XI,NPROC_ETA,LOCAL_PATH,NCHUNKS)

! outer core
  call read_arrays_buffers_solver(IREGION_OUTER_CORE,myrank, &
     iboolleft_xi_outer_core,iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core, &
     npoin2D_xi_outer_core,npoin2D_eta_outer_core, &
     iprocfrom_faces,iprocto_faces,imsg_type, &
     iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
     iboolfaces_outer_core,npoin2D_faces_outer_core, &
     iboolcorner_outer_core, &
     NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE), &
     NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE),NPOIN2DMAX_XY,NPOIN1D_RADIAL(IREGION_OUTER_CORE), &
     NUMMSGS_FACES,NCORNERSCHUNKS,NPROCTOT,NPROC_XI,NPROC_ETA,LOCAL_PATH,NCHUNKS)

! inner core
  call read_arrays_buffers_solver(IREGION_INNER_CORE,myrank, &
     iboolleft_xi_inner_core,iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core, &
     npoin2D_xi_inner_core,npoin2D_eta_inner_core, &
     iprocfrom_faces,iprocto_faces,imsg_type, &
     iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
     iboolfaces_inner_core,npoin2D_faces_inner_core, &
     iboolcorner_inner_core, &
     NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE), &
     NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE),NPOIN2DMAX_XY,NPOIN1D_RADIAL(IREGION_INNER_CORE), &
     NUMMSGS_FACES,NCORNERSCHUNKS,NPROCTOT,NPROC_XI,NPROC_ETA,LOCAL_PATH,NCHUNKS)

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

! allocate 1-D Lagrange interpolators and derivatives
  allocate(hxir(NGLLX))
  allocate(hpxir(NGLLX))
  allocate(hetar(NGLLY))
  allocate(hpetar(NGLLY))
  allocate(hgammar(NGLLZ))
  allocate(hpgammar(NGLLZ))

! to couple mantle with outer core

!
!---- crust and mantle
!

! create name of database
  call create_name_database(prname,myrank,IREGION_CRUST_MANTLE,LOCAL_PATH)

! dynamic allocation of arrays

! boundary parameters locator
  allocate(ibelm_xmin_crust_mantle(NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(ibelm_xmax_crust_mantle(NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(ibelm_ymin_crust_mantle(NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(ibelm_ymax_crust_mantle(NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(ibelm_bottom_crust_mantle(NSPEC2D_BOTTOM(IREGION_CRUST_MANTLE)))
  allocate(ibelm_top_crust_mantle(NSPEC2D_TOP(IREGION_CRUST_MANTLE)))

  allocate(jacobian2D_xmin_crust_mantle(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(jacobian2D_xmax_crust_mantle(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(jacobian2D_ymin_crust_mantle(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(jacobian2D_ymax_crust_mantle(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(jacobian2D_bottom_crust_mantle(NGLLX,NGLLY,NSPEC2D_BOTTOM(IREGION_CRUST_MANTLE)))
  allocate(jacobian2D_top_crust_mantle(NGLLX,NGLLY,NSPEC2D_TOP(IREGION_CRUST_MANTLE)))

! normals
  allocate(normal_xmin_crust_mantle(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(normal_xmax_crust_mantle(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(normal_ymin_crust_mantle(NDIM,NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(normal_ymax_crust_mantle(NDIM,NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(normal_bottom_crust_mantle(NDIM,NGLLX,NGLLY,NSPEC2D_BOTTOM(IREGION_CRUST_MANTLE)))
  allocate(normal_top_crust_mantle(NDIM,NGLLX,NGLLY,NSPEC2D_TOP(IREGION_CRUST_MANTLE)))

! Stacey
  allocate(nimin_crust_mantle(2,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(nimax_crust_mantle(2,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(njmin_crust_mantle(2,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(njmax_crust_mantle(2,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(nkmin_xi_crust_mantle(2,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(nkmin_eta_crust_mantle(2,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))

! boundary parameters
  open(unit=27,file=prname(1:len_trim(prname))//'ibelm.bin',status='old',action='read',form='unformatted')
  read(27) ibelm_xmin_crust_mantle
  read(27) ibelm_xmax_crust_mantle
  read(27) ibelm_ymin_crust_mantle
  read(27) ibelm_ymax_crust_mantle
  read(27) ibelm_bottom_crust_mantle
  read(27) ibelm_top_crust_mantle
  close(27)

  open(unit=27,file=prname(1:len_trim(prname))//'normal.bin',status='old',action='read',form='unformatted')
  read(27) normal_xmin_crust_mantle
  read(27) normal_xmax_crust_mantle
  read(27) normal_ymin_crust_mantle
  read(27) normal_ymax_crust_mantle
  read(27) normal_bottom_crust_mantle
  read(27) normal_top_crust_mantle
  close(27)

  open(unit=27,file=prname(1:len_trim(prname))//'jacobian2D.bin',status='old',action='read',form='unformatted')
  read(27) jacobian2D_xmin_crust_mantle
  read(27) jacobian2D_xmax_crust_mantle
  read(27) jacobian2D_ymin_crust_mantle
  read(27) jacobian2D_ymax_crust_mantle
  read(27) jacobian2D_bottom_crust_mantle
  read(27) jacobian2D_top_crust_mantle
  close(27)

! Stacey put back
  open(unit=27,file=prname(1:len_trim(prname))//'nspec2D.bin',status='unknown',form='unformatted')
  read(27) nspec2D_xmin_crust_mantle
  read(27) nspec2D_xmax_crust_mantle
  read(27) nspec2D_ymin_crust_mantle
  read(27) nspec2D_ymax_crust_mantle
  close(27)

! read arrays for Stacey conditions

  if(ABSORBING_CONDITIONS) then
      open(unit=27,file=prname(1:len_trim(prname))//'nimin.bin',status='unknown',form='unformatted')
      read(27) nimin_crust_mantle
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nimax.bin',status='unknown',form='unformatted')
      read(27) nimax_crust_mantle
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'njmin.bin',status='unknown',form='unformatted')
      read(27) njmin_crust_mantle
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'njmax.bin',status='unknown',form='unformatted')
      read(27) njmax_crust_mantle
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nkmin_xi.bin',status='unknown',form='unformatted')
      read(27) nkmin_xi_crust_mantle
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nkmin_eta.bin',status='unknown',form='unformatted')
      read(27) nkmin_eta_crust_mantle
      close(27)

      if (nspec2D_xmin_crust_mantle > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_xmin_crust_mantle(NDIM,NGLLY,NGLLZ,nspec2D_xmin_crust_mantle))
        reclen_xmin_crust_mantle = CUSTOM_REAL * (NDIM * NGLLY * NGLLZ * nspec2D_xmin_crust_mantle)
        if (SIMULATION_TYPE == 3) then
          open(unit=51,file=trim(prname)//'absorb_xmin.bin',status='old',action='read',form='unformatted',access='direct', &
                recl=reclen_xmin_crust_mantle+2*4)
        else
          open(unit=51,file=trim(prname)//'absorb_xmin.bin',status='unknown',form='unformatted',access='direct',&
                recl=reclen_xmin_crust_mantle+2*4)
        endif
      endif

      if (nspec2D_xmax_crust_mantle > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_xmax_crust_mantle(NDIM,NGLLY,NGLLZ,nspec2D_xmax_crust_mantle))
        reclen_xmax_crust_mantle = CUSTOM_REAL * (NDIM * NGLLY * NGLLZ * nspec2D_xmax_crust_mantle)
        if (SIMULATION_TYPE == 3) then
          open(unit=52,file=trim(prname)//'absorb_xmax.bin',status='old',action='read',form='unformatted',access='direct', &
                recl=reclen_xmax_crust_mantle+2*4)
        else
          open(unit=52,file=trim(prname)//'absorb_xmax.bin',status='unknown',form='unformatted',access='direct', &
                recl=reclen_xmax_crust_mantle+2*4)
        endif
      endif

      if (nspec2D_ymin_crust_mantle > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_ymin_crust_mantle(NDIM,NGLLX,NGLLZ,nspec2D_ymin_crust_mantle))
        reclen_ymin_crust_mantle = CUSTOM_REAL * (NDIM * NGLLX * NGLLZ * nspec2D_ymin_crust_mantle)
        if (SIMULATION_TYPE == 3) then
          open(unit=53,file=trim(prname)//'absorb_ymin.bin',status='old',action='read',form='unformatted',access='direct',&
                recl=reclen_ymin_crust_mantle+2*4)
        else
          open(unit=53,file=trim(prname)//'absorb_ymin.bin',status='unknown',form='unformatted',access='direct',&
                recl=reclen_ymin_crust_mantle+2*4)
        endif
      endif

      if (nspec2D_ymax_crust_mantle > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_ymax_crust_mantle(NDIM,NGLLX,NGLLZ,nspec2D_ymax_crust_mantle))
        reclen_ymax_crust_mantle = CUSTOM_REAL * (NDIM * NGLLX * NGLLZ * nspec2D_ymax_crust_mantle)
        if (SIMULATION_TYPE == 3) then
          open(unit=54,file=trim(prname)//'absorb_ymax.bin',status='old',action='read',form='unformatted',access='direct',&
                recl=reclen_ymax_crust_mantle+2*4)
        else
          open(unit=54,file=trim(prname)//'absorb_ymax.bin',status='unknown',form='unformatted',access='direct',&
                recl=reclen_ymax_crust_mantle+2*4)
        endif
      endif

  endif

! read parameters to couple fluid and solid regions

!
!---- outer core
!

! create name of database
  call create_name_database(prname,myrank,IREGION_OUTER_CORE,LOCAL_PATH)

! dynamic allocation of arrays

! boundary parameters locator
  allocate(ibelm_xmin_outer_core(NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(ibelm_xmax_outer_core(NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(ibelm_ymin_outer_core(NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(ibelm_ymax_outer_core(NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(ibelm_bottom_outer_core(NSPEC2D_BOTTOM(IREGION_OUTER_CORE)))
  allocate(ibelm_top_outer_core(NSPEC2D_TOP(IREGION_OUTER_CORE)))

! normals
  allocate(normal_xmin_outer_core(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(normal_xmax_outer_core(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(normal_ymin_outer_core(NDIM,NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(normal_ymax_outer_core(NDIM,NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(normal_bottom_outer_core(NDIM,NGLLX,NGLLY,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)))
  allocate(normal_top_outer_core(NDIM,NGLLX,NGLLY,NSPEC2D_TOP(IREGION_OUTER_CORE)))

! jacobian on 2D edges
  allocate(jacobian2D_xmin_outer_core(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(jacobian2D_xmax_outer_core(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(jacobian2D_ymin_outer_core(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(jacobian2D_ymax_outer_core(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(jacobian2D_bottom_outer_core(NGLLX,NGLLY,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)))
  allocate(jacobian2D_top_outer_core(NGLLX,NGLLY,NSPEC2D_TOP(IREGION_OUTER_CORE)))

! Stacey
  allocate(nimin_outer_core(2,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(nimax_outer_core(2,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(njmin_outer_core(2,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(njmax_outer_core(2,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(nkmin_xi_outer_core(2,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(nkmin_eta_outer_core(2,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))

! boundary parameters
  open(unit=27,file=prname(1:len_trim(prname))//'ibelm.bin',status='old',action='read',form='unformatted')
  read(27) ibelm_xmin_outer_core
  read(27) ibelm_xmax_outer_core
  read(27) ibelm_ymin_outer_core
  read(27) ibelm_ymax_outer_core
  read(27) ibelm_bottom_outer_core
  read(27) ibelm_top_outer_core
  close(27)

  open(unit=27,file=prname(1:len_trim(prname))//'normal.bin',status='old',action='read',form='unformatted')
  read(27) normal_xmin_outer_core
  read(27) normal_xmax_outer_core
  read(27) normal_ymin_outer_core
  read(27) normal_ymax_outer_core
  read(27) normal_bottom_outer_core
  read(27) normal_top_outer_core
  close(27)

! Stacey put back
  open(unit=27,file=prname(1:len_trim(prname))//'nspec2D.bin',status='unknown',form='unformatted')
  read(27) nspec2D_xmin_outer_core
  read(27) nspec2D_xmax_outer_core
  read(27) nspec2D_ymin_outer_core
  read(27) nspec2D_ymax_outer_core
  close(27)

  open(unit=27,file=prname(1:len_trim(prname))//'jacobian2D.bin',status='old',action='read',form='unformatted')
  read(27) jacobian2D_xmin_outer_core
  read(27) jacobian2D_xmax_outer_core
  read(27) jacobian2D_ymin_outer_core
  read(27) jacobian2D_ymax_outer_core
  read(27) jacobian2D_bottom_outer_core
  read(27) jacobian2D_top_outer_core
  close(27)

! read arrays for Stacey conditions

  if(ABSORBING_CONDITIONS) then
      open(unit=27,file=prname(1:len_trim(prname))//'nimin.bin',status='unknown',form='unformatted')
      read(27) nimin_outer_core
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nimax.bin',status='unknown',form='unformatted')
      read(27) nimax_outer_core
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'njmin.bin',status='unknown',form='unformatted')
      read(27) njmin_outer_core
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'njmax.bin',status='unknown',form='unformatted')
      read(27) njmax_outer_core
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nkmin_xi.bin',status='unknown',form='unformatted')
      read(27) nkmin_xi_outer_core
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nkmin_eta.bin',status='unknown',form='unformatted')
      read(27) nkmin_eta_outer_core
      close(27)

      if (nspec2D_xmin_outer_core > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_xmin_outer_core(NGLLY,NGLLZ,nspec2D_xmin_outer_core))
        reclen_xmin_outer_core = CUSTOM_REAL * (NGLLY * NGLLZ * nspec2D_xmin_outer_core)
        if (SIMULATION_TYPE == 3) then
          open(unit=61,file=trim(prname)//'absorb_xmin.bin',status='old',action='read',form='unformatted',access='direct', &
                recl=reclen_xmin_outer_core+2*4)
        else
          open(unit=61,file=trim(prname)//'absorb_xmin.bin',status='unknown',form='unformatted',access='direct',&
                recl=reclen_xmin_outer_core+2*4)
        endif
      endif

      if (nspec2D_xmax_outer_core > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_xmax_outer_core(NGLLY,NGLLZ,nspec2D_xmax_outer_core))
        reclen_xmax_outer_core = CUSTOM_REAL * (NGLLY * NGLLZ * nspec2D_xmax_outer_core)
        if (SIMULATION_TYPE == 3) then
          open(unit=62,file=trim(prname)//'absorb_xmax.bin',status='old',action='read',form='unformatted',access='direct', &
                recl=reclen_xmax_outer_core+2*4)
        else
          open(unit=62,file=trim(prname)//'absorb_xmax.bin',status='unknown',form='unformatted',access='direct', &
                recl=reclen_xmax_outer_core+2*4)
        endif
      endif

      if (nspec2D_ymin_outer_core > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_ymin_outer_core(NGLLX,NGLLZ,nspec2D_ymin_outer_core))
        reclen_ymin_outer_core = CUSTOM_REAL * (NGLLX * NGLLZ * nspec2D_ymin_outer_core)
        if (SIMULATION_TYPE == 3) then
          open(unit=63,file=trim(prname)//'absorb_ymin.bin',status='old',action='read',form='unformatted',access='direct',&
                recl=reclen_ymin_outer_core+2*4)
        else
          open(unit=63,file=trim(prname)//'absorb_ymin.bin',status='unknown',form='unformatted',access='direct',&
                recl=reclen_ymin_outer_core+2*4)
        endif
      endif

      if (nspec2D_ymax_outer_core > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_ymax_outer_core(NGLLX,NGLLZ,nspec2D_ymax_outer_core))
        reclen_ymax_outer_core = CUSTOM_REAL * (NGLLX * NGLLZ * nspec2D_ymax_outer_core)
        if (SIMULATION_TYPE == 3) then
          open(unit=64,file=trim(prname)//'absorb_ymax.bin',status='old',action='read',form='unformatted',access='direct',&
                recl=reclen_ymax_outer_core+2*4)
        else
          open(unit=64,file=trim(prname)//'absorb_ymax.bin',status='unknown',form='unformatted',access='direct',&
                recl=reclen_ymax_outer_core+2*4)
        endif
      endif

      if (NSPEC2D_BOTTOM(IREGION_OUTER_CORE) > 0 .and. (SIMULATION_TYPE == 3 .or. (SIMULATION_TYPE == 1 .and. SAVE_FORWARD))) then
        allocate(absorb_zmin_outer_core(NGLLX,NGLLY,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)))
        reclen_zmin = CUSTOM_REAL * (NGLLX * NGLLY * NSPEC2D_BOTTOM(IREGION_OUTER_CORE))
         if (SIMULATION_TYPE == 3) then
         open(unit=65,file=trim(prname)//'absorb_zmin.bin',status='old',action='read',form='unformatted',access='direct',&
                recl=reclen_zmin+2*4)
        else
          open(unit=65,file=trim(prname)//'absorb_zmin.bin',status='unknown',form='unformatted',access='direct',&
                recl=reclen_zmin+2*4)
        endif
      endif
  endif

!
!---- inner core
!

! create name of database
  call create_name_database(prname,myrank,IREGION_INNER_CORE,LOCAL_PATH)

! dynamic allocation of arrays

! boundary parameters locator
  allocate(ibelm_xmin_inner_core(NSPEC2DMAX_XMIN_XMAX(IREGION_INNER_CORE)))
  allocate(ibelm_xmax_inner_core(NSPEC2DMAX_XMIN_XMAX(IREGION_INNER_CORE)))
  allocate(ibelm_ymin_inner_core(NSPEC2DMAX_YMIN_YMAX(IREGION_INNER_CORE)))
  allocate(ibelm_ymax_inner_core(NSPEC2DMAX_YMIN_YMAX(IREGION_INNER_CORE)))
  allocate(ibelm_bottom_inner_core(NSPEC2D_BOTTOM(IREGION_INNER_CORE)))
  allocate(ibelm_top_inner_core(NSPEC2D_TOP(IREGION_INNER_CORE)))

! boundary parameters
  open(unit=27,file=prname(1:len_trim(prname))//'ibelm.bin',status='old',action='read',form='unformatted')
  read(27) ibelm_xmin_inner_core
  read(27) ibelm_xmax_inner_core
  read(27) ibelm_ymin_inner_core
  read(27) ibelm_ymax_inner_core
  read(27) ibelm_bottom_inner_core
  read(27) ibelm_top_inner_core
  close(27)

! read info for vertical edges for central cube matching in inner core
  open(unit=27,file=prname(1:len_trim(prname))//'nspec2D.bin',status='old',action='read',form='unformatted')
  read(27) nspec2D_xmin_inner_core
  read(27) nspec2D_xmax_inner_core
  read(27) nspec2D_ymin_inner_core
  read(27) nspec2D_ymax_inner_core
  close(27)


!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
! ---- source array

  if (SIMULATION_TYPE == 1  .or. SIMULATION_TYPE == 3) then

  allocate(sourcearray(NDIM,NGLLX,NGLLY,NGLLZ))
  allocate(sourcearrays(NSOURCES,NDIM,NGLLX,NGLLY,NGLLZ))
  do isource = 1,NSOURCES

!   check that the source slice number is okay
    if(islice_selected_source(isource) < 0 .or. islice_selected_source(isource) > NPROCTOT-1) &
      call exit_MPI(myrank,'something is wrong with the source slice number')

!   compute source arrays in source slice
    if(myrank == islice_selected_source(isource)) then
      call compute_arrays_source(ispec_selected_source(isource), &
             xi_source(isource),eta_source(isource),gamma_source(isource),sourcearray, &
             Mxx(isource),Myy(isource),Mzz(isource),Mxy(isource),Mxz(isource),Myz(isource), &
             xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle, &
             etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
             gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle, &
             xigll,yigll,zigll,nspec_crust_mantle)
      sourcearrays(isource,:,:,:,:) = sourcearray(:,:,:,:)
    endif
  enddo
  endif

  if (SIMULATION_TYPE == 2 .or. SIMULATION_TYPE == 3) then
    nadj_rec_local = 0
    do irec = 1,nrec
      if(myrank == islice_selected_rec(irec))then
        if(islice_selected_rec(irec) < 0 .or. islice_selected_rec(irec) > NPROCTOT-1) &
          call exit_MPI(myrank,'something is wrong with the source slice number in adjoint simulation')
        nadj_rec_local = nadj_rec_local + 1
      endif
    enddo

    NSTEP_SUB_ADJ = ceiling( dble(NSTEP)/dble(NTSTEP_BETWEEN_READ_ADJSRC) )
    allocate(iadj_vec(NSTEP))
    iadj_block = 1  !counts blocks
    do it=1,NSTEP
       iadj_vec(it) = NSTEP-it+1  ! default is for reversing entire record
    enddo

    if(nadj_rec_local > 0) then
     ! allocate adjoint source arrays
     allocate(adj_sourcearray(NTSTEP_BETWEEN_READ_ADJSRC,NDIM,NGLLX,NGLLY,NGLLZ))
     allocate(adj_sourcearrays(nadj_rec_local,NTSTEP_BETWEEN_READ_ADJSRC,NDIM,NGLLX,NGLLY,NGLLZ))

     ! allocate and initialize indexing arrays
     allocate(iadjsrc(NSTEP_SUB_ADJ,2))
     allocate(iadjsrc_len(NSTEP_SUB_ADJ))
     iadjsrc(:,:) = 0
     iadjsrc_len(:) = 0

     do it=1,NSTEP

       it_sub_adj = ceiling( dble(it)/dble(NTSTEP_BETWEEN_READ_ADJSRC) ) !block number

       if(mod(it-1,NTSTEP_BETWEEN_READ_ADJSRC) == 0) then !we are at the edge of a block
         iadjsrc(iadj_block,1) = NSTEP-it_sub_adj*NTSTEP_BETWEEN_READ_ADJSRC+1
         iadjsrc(iadj_block,2) = NSTEP-(it_sub_adj-1)*NTSTEP_BETWEEN_READ_ADJSRC
         if(iadjsrc(iadj_block,1) < 0) iadjsrc(iadj_block,1) = 1         ! final adj src array
         iadjsrc_len(iadj_block) = iadjsrc(iadj_block,2)-iadjsrc(iadj_block,1)+1
         iadj_block = iadj_block+1
       endif

       iadj_vec(it) = iadjsrc_len(it_sub_adj) - mod(it-1,NTSTEP_BETWEEN_READ_ADJSRC)
     enddo

    endif



  endif

!--- select local receivers

! count number of receivers located in this slice
  nrec_local = 0
  if (SIMULATION_TYPE == 1 .or. SIMULATION_TYPE == 3) then
    nrec_simulation = nrec
    do irec = 1,nrec
      if(myrank == islice_selected_rec(irec)) nrec_local = nrec_local + 1
    enddo
  else
    nrec_simulation = NSOURCES
    do isource = 1, NSOURCES
      if(myrank == islice_selected_source(isource)) nrec_local = nrec_local + 1
    enddo
  endif

  if (nrec_local > 0) then

! allocate Lagrange interpolators for receivers
  allocate(hxir_store(nrec_local,NGLLX))
  allocate(hetar_store(nrec_local,NGLLY))
  allocate(hgammar_store(nrec_local,NGLLZ))

! define local to global receiver numbering mapping
  allocate(number_receiver_global(nrec_local))
  irec_local = 0
  if (SIMULATION_TYPE == 1 .or. SIMULATION_TYPE == 3) then
    do irec = 1,nrec
      if(myrank == islice_selected_rec(irec)) then
        irec_local = irec_local + 1
        number_receiver_global(irec_local) = irec
      endif
    enddo
  else
    do isource = 1,NSOURCES
      if(myrank == islice_selected_source(isource)) then
        irec_local = irec_local + 1
        number_receiver_global(irec_local) = isource
      endif
    enddo
  endif

! define and store Lagrange interpolators at all the receivers
  if (SIMULATION_TYPE == 1 .or. SIMULATION_TYPE == 3) then
  do irec_local = 1,nrec_local
    irec = number_receiver_global(irec_local)
    call lagrange_any(xi_receiver(irec),NGLLX,xigll,hxir,hpxir)
    call lagrange_any(eta_receiver(irec),NGLLY,yigll,hetar,hpetar)
    call lagrange_any(gamma_receiver(irec),NGLLZ,zigll,hgammar,hpgammar)
    hxir_store(irec_local,:) = hxir(:)
    hetar_store(irec_local,:) = hetar(:)
    hgammar_store(irec_local,:) = hgammar(:)
  enddo
  else
  do irec_local = 1,nrec_local
    irec = number_receiver_global(irec_local)
    call lagrange_any(xi_source(irec),NGLLX,xigll,hxir,hpxir)
    call lagrange_any(eta_source(irec),NGLLY,yigll,hetar,hpetar)
    call lagrange_any(gamma_source(irec),NGLLZ,zigll,hgammar,hpgammar)
    hxir_store(irec_local,:) = hxir(:)
    hetar_store(irec_local,:) = hetar(:)
    hgammar_store(irec_local,:) = hgammar(:)
  enddo
  endif
  endif ! nrec_local

! check that the sum of the number of receivers in each slice is nrec
  call MPI_REDUCE(nrec_local,nrec_tot_found,1,MPI_INTEGER,MPI_SUM,0, &
                          MPI_COMM_WORLD,ier)
  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'found a total of ',nrec_tot_found,' receivers in all the slices'
    if(nrec_tot_found /= nrec_simulation) then
      call exit_MPI(myrank,'problem when dispatching the receivers')
    else
      write(IMAIN,*) 'this total is okay'
    endif
  endif

  if(myrank == 0) then

  close(IOVTK)

  write(IMAIN,*)
  write(IMAIN,*) 'Total number of samples for seismograms = ',NSTEP
  write(IMAIN,*)

  write(IMAIN,*)
  write(IMAIN,*) 'Reference radius of the Earth used is ',R_EARTH_KM,' km'
  write(IMAIN,*)

  if(NSOURCES > 1) write(IMAIN,*) 'Using ',NSOURCES,' point sources'

  write(IMAIN,*)
  if(ELLIPTICITY) then
    write(IMAIN,*) 'incorporating ellipticity'
  else
    write(IMAIN,*) 'no ellipticity'
  endif

  write(IMAIN,*)
  if(TOPOGRAPHY) then
    write(IMAIN,*) 'incorporating surface topography'
  else
    write(IMAIN,*) 'no surface topography'
  endif

  write(IMAIN,*)
  if(ISOTROPIC_3D_MANTLE) then
    write(IMAIN,*) 'incorporating 3-D lateral variations'
  else
    write(IMAIN,*) 'no 3-D lateral variations'
  endif

  write(IMAIN,*)
  if(CRUSTAL) then
    write(IMAIN,*) 'incorporating crustal variations'
  else
    write(IMAIN,*) 'no crustal variations'
  endif

  write(IMAIN,*)
  if(ONE_CRUST) then
    write(IMAIN,*) 'using one layer only in PREM crust'
  else
    write(IMAIN,*) 'using real PREM crust with two layers'
  endif

  write(IMAIN,*)
  if(GRAVITY) then
    write(IMAIN,*) 'incorporating self-gravitation (Cowling approximation)'
  else
    write(IMAIN,*) 'no self-gravitation'
  endif

  write(IMAIN,*)
  if(ROTATION) then
    write(IMAIN,*) 'incorporating rotation'
  else
    write(IMAIN,*) 'no rotation'
  endif

  write(IMAIN,*)
  if(TRANSVERSE_ISOTROPY) then
    write(IMAIN,*) 'incorporating transverse isotropy'
  else
    write(IMAIN,*) 'no transverse isotropy'
  endif

  write(IMAIN,*)
  if(ATTENUATION) then
    write(IMAIN,*) 'incorporating attenuation using ',N_SLS,' standard linear solids'
    if(ATTENUATION_3D) write(IMAIN,*) 'using 3D attenuation'
  else
    write(IMAIN,*) 'no attenuation'
  endif

  write(IMAIN,*)
  if(OCEANS) then
    write(IMAIN,*) 'incorporating the oceans using equivalent load'
  else
    write(IMAIN,*) 'no oceans'
  endif

  write(IMAIN,*)
  if(ANISOTROPIC_INNER_CORE) then
    write(IMAIN,*) 'incorporating anisotropic inner core'
  else
    write(IMAIN,*) 'no inner-core anisotropy'
  endif

  write(IMAIN,*)
  if(ANISOTROPIC_3D_MANTLE) then
    write(IMAIN,*) 'incorporating anisotropic mantle'
  else
    write(IMAIN,*) 'no general mantle anisotropy'
  endif
  write(IMAIN,*)
  write(IMAIN,*)

  endif

! synchronize all the processes before assembling the mass matrix
! to make sure all the nodes have finished to read their databases
  call MPI_BARRIER(MPI_COMM_WORLD,ier)

! the mass matrix needs to be assembled with MPI here once and for all

! ocean load
  if (OCEANS) then
  call assemble_MPI_scalar(myrank,rmass_ocean_load,nglob_crust_mantle, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_crust_mantle,iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
            npoin2D_faces_crust_mantle,npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
            iboolfaces_crust_mantle,iboolcorner_crust_mantle, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_XY,NCHUNKS)
  endif

! crust and mantle
  call assemble_MPI_scalar(myrank,rmass_crust_mantle,nglob_crust_mantle, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_crust_mantle,iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
            npoin2D_faces_crust_mantle,npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
            iboolfaces_crust_mantle,iboolcorner_crust_mantle, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_XY,NCHUNKS)

! outer core
  call assemble_MPI_scalar(myrank,rmass_outer_core,nglob_outer_core, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_outer_core,iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core, &
            npoin2D_faces_outer_core,npoin2D_xi_outer_core,npoin2D_eta_outer_core, &
            iboolfaces_outer_core,iboolcorner_outer_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_OUTER_CORE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE),NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE),NPOIN2DMAX_XY,NCHUNKS)

! inner core
  call assemble_MPI_scalar(myrank,rmass_inner_core,NGLOB_INNER_CORE, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_inner_core,iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core, &
            npoin2D_faces_inner_core,npoin2D_xi_inner_core,npoin2D_eta_inner_core, &
            iboolfaces_inner_core,iboolcorner_inner_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_INNER_CORE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE),NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE),NPOIN2DMAX_XY,NCHUNKS)

  if(myrank == 0) write(IMAIN,*) 'end assembling MPI mass matrix'

!
!--- handle the communications with the central cube if it was included in the mesh
!
  if(INCLUDE_CENTRAL_CUBE) then

    if(myrank == 0) write(IMAIN,*) 'including central cube'

! compute number of messages to expect in cube as well as their size
    call comp_central_cube_buffer_size(iproc_xi,iproc_eta,ichunk,NPROC_XI,NPROC_ETA,NSPEC2D_BOTTOM(IREGION_INNER_CORE), &
                nb_msgs_theor_in_cube,npoin2D_cube_from_slices)

! this value is used for dynamic memory allocation, therefore make sure it is never zero
    if(nb_msgs_theor_in_cube > 0) then
      non_zero_nb_msgs_theor_in_cube = nb_msgs_theor_in_cube
    else
      non_zero_nb_msgs_theor_in_cube = 1
    endif

! allocate buffers for cube and slices
    allocate(sender_from_slices_to_cube(non_zero_nb_msgs_theor_in_cube))
    allocate(buffer_all_cube_from_slices(non_zero_nb_msgs_theor_in_cube,npoin2D_cube_from_slices,NDIM))
    allocate(buffer_slices(npoin2D_cube_from_slices,NDIM))
    allocate(ibool_central_cube(non_zero_nb_msgs_theor_in_cube,npoin2D_cube_from_slices))

! create buffers to assemble with the central cube
    call create_central_cube_buffers(myrank,iproc_xi,iproc_eta,ichunk, &
       NPROC_XI,NPROC_ETA,NCHUNKS,NSPEC_INNER_CORE,NGLOB_INNER_CORE, &
       NSPEC2DMAX_XMIN_XMAX(IREGION_INNER_CORE),NSPEC2DMAX_YMIN_YMAX(IREGION_INNER_CORE), &
       NSPEC2D_BOTTOM(IREGION_INNER_CORE), &
       addressing,ibool_inner_core,idoubling_inner_core, &
       xstore_inner_core,ystore_inner_core,zstore_inner_core, &
       nspec2D_xmin_inner_core,nspec2D_xmax_inner_core,nspec2D_ymin_inner_core,nspec2D_ymax_inner_core, &
       ibelm_xmin_inner_core,ibelm_xmax_inner_core,ibelm_ymin_inner_core,ibelm_ymax_inner_core,ibelm_bottom_inner_core, &
       nb_msgs_theor_in_cube,non_zero_nb_msgs_theor_in_cube,npoin2D_cube_from_slices, &
       receiver_cube_from_slices,sender_from_slices_to_cube,ibool_central_cube,buffer_slices,buffer_all_cube_from_slices)

    if(myrank == 0) write(IMAIN,*) 'done including central cube'

! the mass matrix to assemble is a scalar, not a vector
    ndim_assemble = 1

! use these buffers to assemble the inner core mass matrix with the central cube
    call assemble_MPI_central_cube(ichunk,nb_msgs_theor_in_cube, sender_from_slices_to_cube, &
     npoin2D_cube_from_slices, buffer_all_cube_from_slices, buffer_slices, ibool_central_cube, &
     receiver_cube_from_slices, ibool_inner_core, idoubling_inner_core, NSPEC_INNER_CORE, &
     ibelm_bottom_inner_core, NSPEC2D_BOTTOM(IREGION_INNER_CORE),NGLOB_INNER_CORE,rmass_inner_core,ndim_assemble)

! suppress fictitious mass matrix elements in central cube
! because the slices do not compute all their spectral elements in the cube
    where(rmass_inner_core(:) <= 0.) rmass_inner_core = 1.

  endif   ! end of handling the communications with the central cube


! check that all the mass matrices are positive
  if((OCEANS .and. minval(rmass_ocean_load(1:nglob_crust_mantle)) <= 0.) .or. &
     minval(rmass_crust_mantle(1:nglob_crust_mantle)) <= 0. .or. &
     (minval(rmass_inner_core) <= 0. .or. &
     minval(rmass_outer_core(1:nglob_outer_core)) <= 0.)) &
       call exit_MPI(myrank,'negative mass matrix term')

! for efficiency, invert final mass matrix once and for all on each slice
  if(OCEANS) rmass_ocean_load(1:nglob_crust_mantle) = 1. / rmass_ocean_load(1:nglob_crust_mantle)
  rmass_crust_mantle(1:nglob_crust_mantle) = 1. / rmass_crust_mantle(1:nglob_crust_mantle)
  rmass_outer_core(1:nglob_outer_core) = 1. / rmass_outer_core(1:nglob_outer_core)
  rmass_inner_core(:) = 1. / rmass_inner_core(:)

! change x, y, z to r, theta and phi once and for all
! IMPROVE dangerous: old name kept (xstore ystore zstore) for new values

! convert in the crust and mantle
    do iglob = 1,nglob_crust_mantle
      call xyz_2_rthetaphi(xstore_crust_mantle(iglob), &
    ystore_crust_mantle(iglob),zstore_crust_mantle(iglob),rval,thetaval,phival)
      xstore_crust_mantle(iglob) = rval
      ystore_crust_mantle(iglob) = thetaval
      zstore_crust_mantle(iglob) = phival
    enddo

! convert in the outer core
    do iglob = 1,nglob_outer_core
      call xyz_2_rthetaphi(xstore_outer_core(iglob), &
    ystore_outer_core(iglob),zstore_outer_core(iglob),rval,thetaval,phival)
      xstore_outer_core(iglob) = rval
      ystore_outer_core(iglob) = thetaval
      zstore_outer_core(iglob) = phival
    enddo

! convert in the inner core
    do iglob = 1,NGLOB_INNER_CORE
      call xyz_2_rthetaphi(xstore_inner_core(iglob), &
    ystore_inner_core(iglob),zstore_inner_core(iglob),rval,thetaval,phival)
      xstore_inner_core(iglob) = rval
      ystore_inner_core(iglob) = thetaval
      zstore_inner_core(iglob) = phival
    enddo

! if attenuation is on, shift PREM to right frequency
! rescale mu in PREM to average frequency for attenuation

  if(ATTENUATION) then

! get and store PREM attenuation model

! ATTENUATION_3D get values from mesher
     if(ATTENUATION_3D) then
        ! CRUST_MANTLE ATTENUATION
        call create_name_database(prname, myrank, IREGION_CRUST_MANTLE, LOCAL_PATH)
        call get_attenuation_model_3D(myrank, prname, omsb_crust_mantle_dble, &
             factor_common_crust_mantle_dble, factor_scale_crust_mantle_dble, tau_sigma_dble, nspec_crust_mantle)
        ! INNER_CORE ATTENUATION
        call create_name_database(prname, myrank, IREGION_INNER_CORE, LOCAL_PATH)
        call get_attenuation_model_3D(myrank, prname, omsb_inner_core_dble, &
             factor_common_inner_core_dble, factor_scale_inner_core_dble, tau_sigma_dble, NSPEC_INNER_CORE)
     else ! ATTENUATION = .true. .AND. ATTENUATION_3D = .false.
        call create_name_database(prname, myrank, IREGION_CRUST_MANTLE, LOCAL_PATH)
        call get_attenuation_model_1D(myrank, prname, IREGION_CRUST_MANTLE, tau_sigma_dble, &
             omsb_crust_mantle_dble, factor_common_crust_mantle_dble,  &
             factor_scale_crust_mantle_dble, NRAD_ATTENUATION,1,1,1, AM_V)
        omsb_inner_core_dble(:,:,:,:)            = omsb_crust_mantle_dble(:,:,:,:)
        factor_scale_inner_core_dble(:,:,:,:)    = factor_scale_crust_mantle_dble(:,:,:,:)
        factor_common_inner_core_dble(:,:,:,:,:) = factor_common_crust_mantle_dble(:,:,:,:,:)
        ! Tell the Attenuation Code about the IDOUBLING regions within the Mesh
        call set_attenuation_regions_1D(RICB, RCMB, R670, R220, R80, AM_V)
     endif ! ATTENUATION_3D

   if(CUSTOM_REAL == SIZE_REAL) then
      factor_scale_crust_mantle       = sngl(factor_scale_crust_mantle_dble)
      one_minus_sum_beta_crust_mantle = sngl(omsb_crust_mantle_dble)
      factor_common_crust_mantle      = sngl(factor_common_crust_mantle_dble)

      factor_scale_inner_core         = sngl(factor_scale_inner_core_dble)
      one_minus_sum_beta_inner_core   = sngl(omsb_inner_core_dble)
      factor_common_inner_core        = sngl(factor_common_inner_core_dble)
   else
      factor_scale_crust_mantle       = factor_scale_crust_mantle_dble
      one_minus_sum_beta_crust_mantle = omsb_crust_mantle_dble
      factor_common_crust_mantle      = factor_common_crust_mantle_dble

      factor_scale_inner_core         = factor_scale_inner_core_dble
      one_minus_sum_beta_inner_core   = omsb_inner_core_dble
      factor_common_inner_core        = factor_common_inner_core_dble
   endif

   deallocate(factor_scale_crust_mantle_dble)
   deallocate(omsb_crust_mantle_dble)
   deallocate(factor_common_crust_mantle_dble)

   deallocate(factor_scale_inner_core_dble)
   deallocate(omsb_inner_core_dble)
   deallocate(factor_common_inner_core_dble)

! rescale in crust and mantle

    do ispec = 1,nspec_crust_mantle
      do k=1,NGLLZ
        do j=1,NGLLY
          do i=1,NGLLX

! ATTENUATION_3D get scale_factor
             if(ATTENUATION_3D) then
                ! tau_mu and tau_sigma need to reference a point in the mesh
                scale_factor = factor_scale_crust_mantle(i,j,k,ispec)
             else
                iglob   = ibool_crust_mantle(i,j,k,ispec)
                dist_cr = xstore_crust_mantle(iglob)
                theta   = ystore_crust_mantle(iglob)
                if(ELLIPTICITY_VAL .AND. idoubling_crust_mantle(ispec) .LE. IFLAG_220_MOHO) then
                   cost    = cos(theta)
                   p20     = 0.5 * (3.0 * cost * cost - 1.0)
                   dist_cr = dist_cr * (1.0 + (2.0/3.0) * ell_d80 * p20)
                endif
                call get_attenuation_index(idoubling_crust_mantle(ispec), dble(dist_cr), iregion_selected, .FALSE., AM_V)
                scale_factor = factor_scale_crust_mantle(1,1,1,iregion_selected)
             endif ! ATTENUATION_3D

    if(ANISOTROPIC_3D_MANTLE) then
      scale_factor_minus_one = scale_factor - 1.
      mul = c44store_crust_mantle(i,j,k,ispec)
      c11store_crust_mantle(i,j,k,ispec) = c11store_crust_mantle(i,j,k,ispec) &
              + FOUR_THIRDS * scale_factor_minus_one * mul
      c12store_crust_mantle(i,j,k,ispec) = c12store_crust_mantle(i,j,k,ispec) &
              - TWO_THIRDS * scale_factor_minus_one * mul
      c13store_crust_mantle(i,j,k,ispec) = c13store_crust_mantle(i,j,k,ispec) &
              - TWO_THIRDS * scale_factor_minus_one * mul
      c22store_crust_mantle(i,j,k,ispec) = c22store_crust_mantle(i,j,k,ispec) &
              + FOUR_THIRDS * scale_factor_minus_one * mul
      c23store_crust_mantle(i,j,k,ispec) = c23store_crust_mantle(i,j,k,ispec) &
              - TWO_THIRDS * scale_factor_minus_one * mul
      c33store_crust_mantle(i,j,k,ispec) = c33store_crust_mantle(i,j,k,ispec) &
              + FOUR_THIRDS * scale_factor_minus_one * mul
      c44store_crust_mantle(i,j,k,ispec) = c44store_crust_mantle(i,j,k,ispec) &
              + scale_factor_minus_one * mul
      c55store_crust_mantle(i,j,k,ispec) = c55store_crust_mantle(i,j,k,ispec) &
              + scale_factor_minus_one * mul
      c66store_crust_mantle(i,j,k,ispec) = c66store_crust_mantle(i,j,k,ispec) &
              + scale_factor_minus_one * mul
    else
      muvstore_crust_mantle(i,j,k,ispec) = muvstore_crust_mantle(i,j,k,ispec) * scale_factor
      if(TRANSVERSE_ISOTROPY .and. idoubling_crust_mantle(ispec) == IFLAG_220_MOHO) &
        muhstore_crust_mantle(i,j,k,ispec) = muhstore_crust_mantle(i,j,k,ispec) * scale_factor
    endif

          enddo
        enddo
      enddo
    enddo ! END DO CRUST MANTLE

! rescale in inner core

    do ispec = 1,NSPEC_INNER_CORE
      do k=1,NGLLZ
        do j=1,NGLLY
          do i=1,NGLLX

            if(ATTENUATION_3D) then
               scale_factor_minus_one = factor_scale_inner_core(i,j,k,ispec) - 1.0
            else
               iglob   = ibool_inner_core(i,j,k,ispec)
               dist_cr = xstore_inner_core(iglob)
               call get_attenuation_index(idoubling_inner_core(ispec), dble(dist_cr), iregion_selected, .TRUE., AM_V)
               scale_factor_minus_one = factor_scale_inner_core(1,1,1,iregion_selected) - 1.
            endif

        if(ANISOTROPIC_INNER_CORE) then
          mul = muvstore_inner_core(i,j,k,ispec)
          c11store_inner_core(i,j,k,ispec) = c11store_inner_core(i,j,k,ispec) &
                  + FOUR_THIRDS * scale_factor_minus_one * mul
          c12store_inner_core(i,j,k,ispec) = c12store_inner_core(i,j,k,ispec) &
                  - TWO_THIRDS * scale_factor_minus_one * mul
          c13store_inner_core(i,j,k,ispec) = c13store_inner_core(i,j,k,ispec) &
                  - TWO_THIRDS * scale_factor_minus_one * mul
          c33store_inner_core(i,j,k,ispec) = c33store_inner_core(i,j,k,ispec) &
                  + FOUR_THIRDS * scale_factor_minus_one * mul
          c44store_inner_core(i,j,k,ispec) = c44store_inner_core(i,j,k,ispec) &
                  + scale_factor_minus_one * mul
        endif

            if(ATTENUATION_3D) then
               muvstore_inner_core(i,j,k,ispec) = muvstore_inner_core(i,j,k,ispec) * factor_scale_inner_core(i,j,k,ispec)
            else
               muvstore_inner_core(i,j,k,ispec) = muvstore_inner_core(i,j,k,ispec) * factor_scale_inner_core(1,1,1,iregion_selected)
            endif

          enddo
        enddo
      enddo
    enddo ! END DO INNER CORE

! deallocate arrays
    deallocate(factor_scale_crust_mantle)
    deallocate(factor_scale_inner_core)

  endif ! END IF(ATTENUATION)

! allocate seismogram array
  if (nrec_local > 0) then
    if (SIMULATION_TYPE == 1 .or. SIMULATION_TYPE == 3) then
      allocate(seismograms(NDIM,nrec_local,NSTEP))
    else
      allocate(seismograms(9,nrec_local,NTSTEP_BETWEEN_OUTPUT_SEISMOS))
    endif
! initialize seismograms
    seismograms(:,:,:) = 0._CUSTOM_REAL
    nit_written = 0
  endif

! initialize arrays to zero

  displ_crust_mantle(:,:) = 0._CUSTOM_REAL
  veloc_crust_mantle(:,:) = 0._CUSTOM_REAL
  accel_crust_mantle(:,:) = 0._CUSTOM_REAL

  displ_outer_core(:) = 0._CUSTOM_REAL
  veloc_outer_core(:) = 0._CUSTOM_REAL
  accel_outer_core(:) = 0._CUSTOM_REAL

  displ_inner_core(:,:) = 0._CUSTOM_REAL
  veloc_inner_core(:,:) = 0._CUSTOM_REAL
  accel_inner_core(:,:) = 0._CUSTOM_REAL

! put negligible initial value to avoid very slow underflow trapping
  if(FIX_UNDERFLOW_PROBLEM) then
    displ_crust_mantle(:,:) = VERYSMALLVAL
    displ_outer_core(:) = VERYSMALLVAL
    displ_inner_core(:,:) = VERYSMALLVAL
  endif

  if (SIMULATION_TYPE == 3) then
    allocate(b_displ_crust_mantle(NDIM,NGLOBMAX_CRUST_MANTLE))
    allocate(b_veloc_crust_mantle(NDIM,NGLOBMAX_CRUST_MANTLE))
    allocate(b_accel_crust_mantle(NDIM,NGLOBMAX_CRUST_MANTLE))

    allocate(b_displ_outer_core(NGLOBMAX_OUTER_CORE))
    allocate(b_veloc_outer_core(NGLOBMAX_OUTER_CORE))
    allocate(b_accel_outer_core(NGLOBMAX_OUTER_CORE))

    allocate(b_displ_inner_core(NDIM,NGLOB_INNER_CORE))
    allocate(b_veloc_inner_core(NDIM,NGLOB_INNER_CORE))
    allocate(b_accel_inner_core(NDIM,NGLOB_INNER_CORE))

    allocate(div_displ_outer_core(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE))
    allocate(b_div_displ_outer_core(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE))

    allocate(rho_kl_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE))
    allocate(beta_kl_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE))
    allocate(alpha_kl_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE))

    allocate(rho_kl_outer_core(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE))
    allocate(alpha_kl_outer_core(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE))

    allocate(rho_kl_inner_core(NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE))
    allocate(beta_kl_inner_core(NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE))
    allocate(alpha_kl_inner_core(NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE))

    rho_kl_crust_mantle(:,:,:,:) = 0._CUSTOM_REAL
    beta_kl_crust_mantle(:,:,:,:) = 0._CUSTOM_REAL
    alpha_kl_crust_mantle(:,:,:,:) = 0._CUSTOM_REAL

    rho_kl_outer_core(:,:,:,:) = 0._CUSTOM_REAL
    alpha_kl_outer_core(:,:,:,:) = 0._CUSTOM_REAL

    rho_kl_inner_core(:,:,:,:) = 0._CUSTOM_REAL
    beta_kl_inner_core(:,:,:,:) = 0._CUSTOM_REAL
    alpha_kl_inner_core(:,:,:,:) = 0._CUSTOM_REAL

    div_displ_outer_core(:,:,:,:) = 0._CUSTOM_REAL
    b_div_displ_outer_core(:,:,:,:) = 0._CUSTOM_REAL

  endif

! store g, rho and dg/dr=dg using normalized radius in lookup table every 100 m
! get density and velocity from PREM model using dummy doubling flag
! this assumes that the gravity perturbations are small and smooth
! and that we can neglect the 3D model and use PREM every 100 m in all cases
! this is probably a rather reasonable assumption
  if(GRAVITY) then
    call make_gravity(nspl_gravity,rspl_gravity,gspl,gspl2,ONE_CRUST)
    do int_radius = 1,NRAD_GRAVITY
      radius = dble(int_radius) / (R_EARTH_KM * 10.d0)
      call splint(rspl_gravity,gspl,gspl2,nspl_gravity,radius,g)
      idoubling = 0

! use PREM density profile to calculate gravity (fine for other 1D models)
      call prem_iso(myrank,radius,rho,drhodr,vp,vs,Qkappa,Qmu,idoubling,.false., &
          ONE_CRUST,.false.,RICB,RCMB,RTOPDDOUBLEPRIME, &
          R600,R670,R220,R771,R400,R80,RMOHO,RMIDDLE_CRUST,ROCEAN)

      dg = 4.0d0*rho - 2.0d0*g/radius
      minus_gravity_table(int_radius) = - g
      minus_deriv_gravity_table(int_radius) = - dg
      density_table(int_radius) = rho
      minus_rho_g_over_kappa_fluid(int_radius) = - g / vp**2
    enddo

! make sure fluid array is only assigned in outer core between 1222 and 3478 km
! lookup table is defined every 100 m
    do int_radius = 1,NRAD_GRAVITY
      radius_km = dble(int_radius) / 10.d0
      if(radius_km > RCMB/1000.d0 - 3.d0) &
        minus_rho_g_over_kappa_fluid(int_radius) = minus_rho_g_over_kappa_fluid(nint((RCMB/1000.d0 - 3.d0)*10.d0))
      if(radius_km < RICB/1000.d0 + 3.d0) &
        minus_rho_g_over_kappa_fluid(int_radius) = minus_rho_g_over_kappa_fluid(nint((RICB/1000.d0 + 3.d0)*10.d0))
    enddo

! compute gravity value at CMB and ICB once and for all
    radius = RCMB / R_EARTH
    call splint(rspl_gravity,gspl,gspl2,nspl_gravity,radius,g_cmb_dble)

    radius = RICB / R_EARTH
    call splint(rspl_gravity,gspl,gspl2,nspl_gravity,radius,g_icb_dble)

! distinguish between single and double precision for reals
    if(CUSTOM_REAL == SIZE_REAL) then
      minus_g_cmb = sngl(- g_cmb_dble)
      minus_g_icb = sngl(- g_icb_dble)
    else
      minus_g_cmb = - g_cmb_dble
      minus_g_icb = - g_icb_dble
    endif

  else

! tabulate d ln(rho)/dr needed for the no gravity fluid potential
    do int_radius = 1,NRAD_GRAVITY
      radius = dble(int_radius) / (R_EARTH_KM * 10.d0)
      idoubling = 0
      call prem_iso(myrank,radius,rho,drhodr,vp,vs,Qkappa,Qmu,idoubling,.false., &
          ONE_CRUST,.false.,RICB,RCMB,RTOPDDOUBLEPRIME, &
          R600,R670,R220,R771,R400,R80,RMOHO,RMIDDLE_CRUST,ROCEAN)
      d_ln_density_dr_table(int_radius) = drhodr/rho
    enddo

  endif

! allocate files to save movies
  if(MOVIE_SURFACE) then
    nmovie_points = NGLLX * NGLLY * NSPEC2D_TOP(IREGION_CRUST_MANTLE)
    allocate(store_val_x(nmovie_points))
    allocate(store_val_y(nmovie_points))
    allocate(store_val_z(nmovie_points))
    allocate(store_val_ux(nmovie_points))
    allocate(store_val_uy(nmovie_points))
    allocate(store_val_uz(nmovie_points))

    allocate(store_val_x_all(nmovie_points,0:NPROCTOT-1))
    allocate(store_val_y_all(nmovie_points,0:NPROCTOT-1))
    allocate(store_val_z_all(nmovie_points,0:NPROCTOT-1))
    allocate(store_val_ux_all(nmovie_points,0:NPROCTOT-1))
    allocate(store_val_uy_all(nmovie_points,0:NPROCTOT-1))
    allocate(store_val_uz_all(nmovie_points,0:NPROCTOT-1))
  endif

  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) '           time step: ',sngl(DT),' s'
    write(IMAIN,*) 'number of time steps: ',NSTEP
    write(IMAIN,*) 'total simulated time: ',sngl(((NSTEP-1)*DT-t0)/60.d0),' minutes'
    write(IMAIN,*) 'start time:',sngl(-t0),' seconds'
    write(IMAIN,*)
  endif

! define constants for the time integration
! scaling to make displacement in meters and velocity in meters per second
  scale_t = ONE/dsqrt(PI*GRAV*RHOAV)
  scale_displ = R_EARTH
  scale_veloc = scale_displ / scale_t

! distinguish between single and double precision for reals
  if(CUSTOM_REAL == SIZE_REAL) then
    deltat = sngl(DT/scale_t)
  else
    deltat = DT/scale_t
  endif
  deltatover2 = 0.5d0*deltat
  deltatsqover2 = 0.5d0*deltat*deltat

  if (SIMULATION_TYPE == 3) then
    if(CUSTOM_REAL == SIZE_REAL) then
      b_deltat = - sngl(DT/scale_t)
    else
      b_deltat = - DT/scale_t
    endif
    b_deltatover2 = 0.5d0*b_deltat
    b_deltatsqover2 = 0.5d0*b_deltat*b_deltat
  endif

! non-dimensionalized rotation rate of the Earth times two
  if(ROTATION) then
! distinguish between single and double precision for reals
    if (SIMULATION_TYPE == 1) then
    if(CUSTOM_REAL == SIZE_REAL) then
      two_omega_earth = sngl(2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t))
    else
      two_omega_earth = 2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t)
    endif
    else
    if(CUSTOM_REAL == SIZE_REAL) then
      two_omega_earth = - sngl(2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t))
    else
      two_omega_earth = - 2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t)
    endif
    endif
    A_array_rotation = 0.
    B_array_rotation = 0.
    if (SIMULATION_TYPE == 3) then
    if(CUSTOM_REAL == SIZE_REAL) then
      b_two_omega_earth = sngl(2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t))
    else
      b_two_omega_earth = 2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t)
    endif
    allocate(b_A_array_rotation(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE_ROTATION))
    allocate(b_B_array_rotation(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE_ROTATION))
    endif
  else
    two_omega_earth = 0._CUSTOM_REAL
    if (SIMULATION_TYPE == 3) b_two_omega_earth = 0._CUSTOM_REAL
  endif

! precompute Runge-Kutta coefficients if attenuation
  if(ATTENUATION) then
     call attenuation_memory_values(tau_sigma_dble, deltat, alphaval_dble, betaval_dble, gammaval_dble)
     if(CUSTOM_REAL == SIZE_REAL) then
        alphaval = sngl(alphaval_dble)
        betaval  = sngl(betaval_dble)
        gammaval = sngl(gammaval_dble)
     else
        alphaval = alphaval_dble
        betaval  = betaval_dble
        gammaval = gammaval_dble
     endif
     if (SIMULATION_TYPE == 3) then
       call attenuation_memory_values(tau_sigma_dble, b_deltat, alphaval_dble, betaval_dble, gammaval_dble)
       if(CUSTOM_REAL == SIZE_REAL) then
         b_alphaval = sngl(alphaval_dble)
         b_betaval  = sngl(betaval_dble)
         b_gammaval = sngl(gammaval_dble)
       else
         b_alphaval = alphaval_dble
         b_betaval  = betaval_dble
         b_gammaval = gammaval_dble
       endif
     endif
  endif

  if (SAVE_STRAIN) then
    allocate(epsilondev_crust_mantle(5,NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE))
    allocate(epsilondev_inner_core(5,NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE))
    allocate(eps_trace_over_3_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE))
    allocate(eps_trace_over_3_inner_core(NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE))

    if (SIMULATION_TYPE == 3) then
      allocate(b_epsilondev_crust_mantle(5,NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE))
      allocate(b_epsilondev_inner_core(5,NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE))
      allocate(b_eps_trace_over_3_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE))
      allocate(b_eps_trace_over_3_inner_core(NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE))
    endif
  else
    allocate(epsilondev_crust_mantle(5,NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE_ATTENUAT))
    allocate(epsilondev_inner_core(5,NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE_ATTENUATION))
  endif

! clear memory variables if attenuation
  if(ATTENUATION) then
    if (NSPECMAX_CRUST_MANTLE_ATTENUAT /= NSPECMAX_CRUST_MANTLE) &
       call exit_MPI(myrank, 'NSPECMAX_CRUST_MANTLE_ATTENUAT /= NSPECMAX_CRUST_MANTLE, exit')
    if (NSPEC_INNER_CORE_ATTENUATION /= NSPEC_INNER_CORE) &
       call exit_MPI(myrank, 'NSPEC_INNER_CORE_ATTENUATION /= NSPEC_INNER_CORE, exit')
    R_memory_crust_mantle(:,:,:,:,:,:) = 0._CUSTOM_REAL
    R_memory_inner_core(:,:,:,:,:,:) = 0._CUSTOM_REAL

    epsilondev_crust_mantle(:,:,:,:,:) = 0._CUSTOM_REAL
    epsilondev_inner_core(:,:,:,:,:) = 0._CUSTOM_REAL

    if(FIX_UNDERFLOW_PROBLEM) then
      R_memory_crust_mantle(:,:,:,:,:,:) = VERYSMALLVAL
      R_memory_inner_core(:,:,:,:,:,:) = VERYSMALLVAL

      epsilondev_crust_mantle(:,:,:,:,:) = VERYSMALLVAL
      epsilondev_inner_core(:,:,:,:,:) = VERYSMALLVAL
    endif

    if (SIMULATION_TYPE == 3) then
      allocate(b_R_memory_crust_mantle(5,N_SLS,NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE_ATTENUAT))
      allocate(b_R_memory_inner_core(5,N_SLS,NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE_ATTENUATION))
    endif

  endif

! get information about event name and location for SAC seismograms
  call get_event_info_parallel(myrank,yr_SAC,jda_SAC,ho_SAC,mi_SAC,sec_SAC,t_cmt_SAC, &
                 elat_SAC,elon_SAC,depth_SAC,mb_SAC,ename_SAC,cmt_lat_SAC,cmt_lon_SAC,cmt_depth_SAC,cmt_hdur_SAC,NSOURCES_SAC)

! define correct time steps if restart files
  if(NUMBER_OF_RUNS < 1 .or. NUMBER_OF_RUNS > 3) stop 'number of restart runs can be 1, 2 or 3'
  if(NUMBER_OF_THIS_RUN < 1 .or. NUMBER_OF_THIS_RUN > NUMBER_OF_RUNS) stop 'incorrect run number'
  if (SIMULATION_TYPE /= 1 .and. NUMBER_OF_RUNS /= 1) stop 'Only 1 run for SIMULATION_TYPE = 2/3'

  if(NUMBER_OF_RUNS == 3) then
    if(NUMBER_OF_THIS_RUN == 1) then
      it_begin = 1
      it_end = NSTEP/3
    else if(NUMBER_OF_THIS_RUN == 2) then
      it_begin = NSTEP/3 + 1
      it_end = 2*(NSTEP/3)
    else
      it_begin = 2*(NSTEP/3) + 1
      it_end = NSTEP
    endif

  else if(NUMBER_OF_RUNS == 2) then
    if(NUMBER_OF_THIS_RUN == 1) then
      it_begin = 1
      it_end = NSTEP/2
    else
      it_begin = NSTEP/2 + 1
      it_end = NSTEP
    endif

  else
    it_begin = 1
    it_end = NSTEP
  endif

! read files back from local disk or MT tape system if restart file
  if(NUMBER_OF_THIS_RUN > 1) then
    write(outputname,"('dump_all_arrays',i6.6)") myrank
    open(unit=55,file=trim(LOCAL_PATH)//'/'//outputname,status='old',action='read',form='unformatted')
    read(55) displ_crust_mantle
    read(55) veloc_crust_mantle
    read(55) accel_crust_mantle
    read(55) displ_inner_core
    read(55) veloc_inner_core
    read(55) accel_inner_core
    read(55) displ_outer_core
    read(55) veloc_outer_core
    read(55) accel_outer_core
    read(55) R_memory_crust_mantle
    read(55) R_memory_inner_core
    read(55) epsilondev_crust_mantle
    read(55) epsilondev_inner_core
    read(55) A_array_rotation
    read(55) B_array_rotation
    close(55)
  endif

  if (SIMULATION_TYPE == 3) then
    write(outputname,'(a,i6.6,a)') 'proc',myrank,'_save_forward_arrays.bin'
    open(unit=55,file=trim(LOCAL_PATH)//'/'//outputname,status='old',action='read',form='unformatted')
    read(55) b_displ_crust_mantle
    read(55) b_veloc_crust_mantle
    read(55) b_accel_crust_mantle
    read(55) b_displ_inner_core
    read(55) b_veloc_inner_core
    read(55) b_accel_inner_core
    read(55) b_displ_outer_core
    read(55) b_veloc_outer_core
    read(55) b_accel_outer_core
    if (ATTENUATION_VAL) then
      read(55) b_R_memory_crust_mantle
      read(55) b_R_memory_inner_core
    endif
    read(55) b_epsilondev_crust_mantle
    read(55) b_epsilondev_inner_core
    if (ROTATION) then
      read(55) b_A_array_rotation
      read(55) b_B_array_rotation
    endif
    close(55)

  endif

!
!   s t a r t   t i m e   i t e r a t i o n s
!

! synchronize all processes to make sure everybody is ready to start time loop
  call MPI_BARRIER(MPI_COMM_WORLD,ier)
  if(myrank == 0) write(IMAIN,*) 'All processes are synchronized before time loop'

  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'Starting time iteration loop...'
    write(IMAIN,*)
  endif

! create an empty file to monitor the start of the simulation
  if(myrank == 0) then
    open(unit=IOUT,file=trim(OUTPUT_FILES)//'/starttimeloop.txt',status='unknown')
    write(IOUT,*) 'hello, starting time loop'
    close(IOUT)
  endif

! get MPI starting time
  time_start = MPI_WTIME()

! *********************************************************
! ************* MAIN LOOP OVER THE TIME STEPS *************
! *********************************************************

  do it=it_begin,it_end

! mantle
  do i=1,nglob_crust_mantle
    displ_crust_mantle(:,i) = displ_crust_mantle(:,i) + deltat*veloc_crust_mantle(:,i) + deltatsqover2*accel_crust_mantle(:,i)
    veloc_crust_mantle(:,i) = veloc_crust_mantle(:,i) + deltatover2*accel_crust_mantle(:,i)
  enddo

! outer core
  do i=1,nglob_outer_core
    displ_outer_core(i) = displ_outer_core(i) + deltat*veloc_outer_core(i) + deltatsqover2*accel_outer_core(i)
    veloc_outer_core(i) = veloc_outer_core(i) + deltatover2*accel_outer_core(i)
  enddo

! inner core
  do i=1,NGLOB_INNER_CORE
    displ_inner_core(:,i) = displ_inner_core(:,i) + deltat*veloc_inner_core(:,i) + deltatsqover2*accel_inner_core(:,i)
    veloc_inner_core(:,i) = veloc_inner_core(:,i) + deltatover2*accel_inner_core(:,i)
  enddo

! backward field
  if (SIMULATION_TYPE == 3) then
  do i=1,nglob_crust_mantle
    b_displ_crust_mantle(:,i) = b_displ_crust_mantle(:,i) + b_deltat*b_veloc_crust_mantle(:,i) + &
         b_deltatsqover2*b_accel_crust_mantle(:,i)
    b_veloc_crust_mantle(:,i) = b_veloc_crust_mantle(:,i) + b_deltatover2*b_accel_crust_mantle(:,i)
  enddo
  do i=1,nglob_outer_core
    b_displ_outer_core(i) = b_displ_outer_core(i) + b_deltat*b_veloc_outer_core(i) + b_deltatsqover2*b_accel_outer_core(i)
    b_veloc_outer_core(i) = b_veloc_outer_core(i) + b_deltatover2*b_accel_outer_core(i)
  enddo
  do i=1,NGLOB_INNER_CORE
    b_displ_inner_core(:,i) = b_displ_inner_core(:,i) + b_deltat*b_veloc_inner_core(:,i) + b_deltatsqover2*b_accel_inner_core(:,i)
    b_veloc_inner_core(:,i) = b_veloc_inner_core(:,i) + b_deltatover2*b_accel_inner_core(:,i)
  enddo
  endif

! compute the maximum of the norm of the displacement
! in all the slices using an MPI reduction
! and output timestamp file to check that simulation is running fine
  if(mod(it,NTSTEP_BETWEEN_OUTPUT_INFO) == 0 .or. it == 5) then

! compute maximum of norm of displacement in each slice
    Usolidnorm = max( &
        maxval(sqrt(displ_crust_mantle(1,1:nglob_crust_mantle)**2 + &
          displ_crust_mantle(2,1:nglob_crust_mantle)**2 + displ_crust_mantle(3,1:nglob_crust_mantle)**2)), &
        maxval(sqrt(displ_inner_core(1,:)**2 + displ_inner_core(2,:)**2 + displ_inner_core(3,:)**2)))

    Ufluidnorm = maxval(abs(displ_outer_core(1:nglob_outer_core)))

! compute the maximum of the maxima for all the slices using an MPI reduction
    call MPI_REDUCE(Usolidnorm,Usolidnorm_all,1,CUSTOM_MPI_TYPE,MPI_MAX,0, &
                          MPI_COMM_WORLD,ier)
    call MPI_REDUCE(Ufluidnorm,Ufluidnorm_all,1,CUSTOM_MPI_TYPE,MPI_MAX,0, &
                          MPI_COMM_WORLD,ier)
    if (SIMULATION_TYPE == 3) then
      b_Usolidnorm = max( &
                 maxval(sqrt(b_displ_crust_mantle(1,1:nglob_crust_mantle)**2 + &
                 b_displ_crust_mantle(2,1:nglob_crust_mantle)**2 + b_displ_crust_mantle(3,1:nglob_crust_mantle)**2)), &
                 maxval(sqrt(b_displ_inner_core(1,:)**2 + b_displ_inner_core(2,:)**2 + b_displ_inner_core(3,:)**2)))

      b_Ufluidnorm = maxval(abs(b_displ_outer_core(1:nglob_outer_core)))

! compute the maximum of the maxima for all the slices using an MPI reduction
      call MPI_REDUCE(b_Usolidnorm,b_Usolidnorm_all,1,CUSTOM_MPI_TYPE,MPI_MAX,0, &
                 MPI_COMM_WORLD,ier)
      call MPI_REDUCE(b_Ufluidnorm,b_Ufluidnorm_all,1,CUSTOM_MPI_TYPE,MPI_MAX,0, &
                 MPI_COMM_WORLD,ier)

    endif

    if(myrank == 0) then

      write(IMAIN,*) 'Time step # ',it
      write(IMAIN,*) 'Time: ',sngl(((it-1)*DT-t0)/60.d0),' minutes'

! elapsed time since beginning of the simulation
      tCPU = MPI_WTIME() - time_start
      int_tCPU = int(tCPU)
      ihours = int_tCPU / 3600
      iminutes = (int_tCPU - 3600*ihours) / 60
      iseconds = int_tCPU - 3600*ihours - 60*iminutes
      write(IMAIN,*) 'Elapsed time in seconds = ',tCPU
      write(IMAIN,"(' Elapsed time in hh:mm:ss = ',i4,' h ',i2.2,' m ',i2.2,' s')") ihours,iminutes,iseconds
      write(IMAIN,*) 'Mean elapsed time per time step in seconds = ',tCPU/dble(it)

! rescale maximum displacement to correct dimensions
      Usolidnorm_all = Usolidnorm_all * sngl(scale_displ)
      write(IMAIN,*) 'Max norm displacement vector U in solid in all slices (m) = ',Usolidnorm_all
      write(IMAIN,*) 'Max non-dimensional potential Ufluid in fluid in all slices = ',Ufluidnorm_all
      write(IMAIN,*)
      if (SIMULATION_TYPE == 3) then
      b_Usolidnorm_all = b_Usolidnorm_all * sngl(scale_displ)
      write(IMAIN,*) 'Max norm displacement vector U in solid in all slices for back prop.(m) = ',b_Usolidnorm_all
      write(IMAIN,*) 'Max non-dimensional potential Ufluid in fluid in all slices for back prop.= ',b_Ufluidnorm_all
      write(IMAIN,*)
      endif

! write time stamp file to give information about progression of simulation
      write(outputname,"('/timestamp',i6.6)") it
      open(unit=IOUT,file=trim(OUTPUT_FILES)//outputname,status='unknown')
      write(IOUT,*) 'Time step # ',it
      write(IOUT,*) 'Time: ',sngl(((it-1)*DT-t0)/60.d0),' minutes'
      write(IOUT,*) 'Elapsed time in seconds = ',tCPU
      write(IOUT,"(' Elapsed time in hh:mm:ss = ',i4,' h ',i2.2,' m ',i2.2,' s')") ihours,iminutes,iseconds
      write(IOUT,*) 'Mean elapsed time per time step in seconds = ',tCPU/dble(it)
      write(IOUT,*) 'Max norm displacement vector U in solid in all slices (m) = ',Usolidnorm_all
      write(IOUT,*) 'Max non-dimensional potential Ufluid in fluid in all slices = ',Ufluidnorm_all
      if (SIMULATION_TYPE == 3) then
      write(IOUT,*) 'Max norm displacement vector U in solid in all slices for back prop.(m) = ',b_Usolidnorm_all
      write(IOUT,*) 'Max non-dimensional potential Ufluid in fluid in all slices for back prop.= ',b_Ufluidnorm_all
      endif
      close(IOUT)
! check stability of the code, exit if unstable
      if(Usolidnorm_all > STABILITY_THRESHOLD) call exit_MPI(myrank,'code became unstable and blew up in solid')
      if(Ufluidnorm_all > STABILITY_THRESHOLD) call exit_MPI(myrank,'code became unstable and blew up in fluid')
      if (SIMULATION_TYPE == 3) then
        if(b_Usolidnorm_all > STABILITY_THRESHOLD) call exit_MPI(myrank,'code became unstable and blew up in solid for back prop.')
        if(b_Ufluidnorm_all > STABILITY_THRESHOLD) call exit_MPI(myrank,'code became unstable and blew up in fluid for back prop.')
      endif
    endif
  endif

! ****************************************************
!   big loop over all spectral elements in the fluid
! ****************************************************

! compute internal forces in the fluid region
  if(CUSTOM_REAL == SIZE_REAL) then
    time = sngl((dble(it-1)*DT-t0)/scale_t)
  else
    time = (dble(it-1)*DT-t0)/scale_t
  endif

! accel_outer_core, div_displ_outer_core are initialized to zero in the following subroutine.
  call compute_forces_outer_core(time,deltat,two_omega_earth, &
         A_array_rotation,B_array_rotation,d_ln_density_dr_table, &
         minus_rho_g_over_kappa_fluid,displ_outer_core,accel_outer_core,div_displ_outer_core, &
         xstore_outer_core,ystore_outer_core,zstore_outer_core, &
         xix_outer_core,xiy_outer_core,xiz_outer_core, &
         etax_outer_core,etay_outer_core,etaz_outer_core, &
         gammax_outer_core,gammay_outer_core,gammaz_outer_core, &
         jacobian_outer_core,hprime_xx,hprime_yy,hprime_zz, &
         hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
         wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube, &
         ibool_outer_core,nspec_outer_core,nglob_outer_core,SIMULATION_TYPE)

  if (SIMULATION_TYPE == 3) then
    call compute_forces_outer_core(time,b_deltat,b_two_omega_earth, &
         b_A_array_rotation,b_B_array_rotation,d_ln_density_dr_table, &
         minus_rho_g_over_kappa_fluid,b_displ_outer_core,b_accel_outer_core,b_div_displ_outer_core, &
         xstore_outer_core,ystore_outer_core,zstore_outer_core, &
         xix_outer_core,xiy_outer_core,xiz_outer_core, &
         etax_outer_core,etay_outer_core,etaz_outer_core, &
         gammax_outer_core,gammay_outer_core,gammaz_outer_core, &
         jacobian_outer_core,hprime_xx,hprime_yy,hprime_zz, &
         hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
         wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube, &
         ibool_outer_core,nspec_outer_core,nglob_outer_core,SIMULATION_TYPE)
  endif

! Stacey
  if(NCHUNKS /= 6 .and. ABSORBING_CONDITIONS) then

!   xmin
! if two chunks exclude this face for one of them
  if(NCHUNKS == 1 .or. ichunk == CHUNK_AC) then

    if (SIMULATION_TYPE == 3 .and. nspec2D_xmin_outer_core > 0)  then
      read(61,rec=NSTEP-it+1) reclen1,absorb_xmin_outer_core,reclen2
      if (reclen1 /= reclen_xmin_outer_core .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_xmin_outer_core')
    endif

    do ispec2D=1,nspec2D_xmin_outer_core

      ispec=ibelm_xmin_outer_core(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_xi_outer_core(1,ispec2D) == 0 .or. njmin_outer_core(1,ispec2D) == 0) cycle

      i=1
      do k=nkmin_xi_outer_core(1,ispec2D),NGLLZ
        do j=njmin_outer_core(1,ispec2D),njmax_outer_core(1,ispec2D)
          iglob=ibool_outer_core(i,j,k,ispec)

          sn = veloc_outer_core(iglob)/vp_outer_core(i,j,k,ispec)

          weight = jacobian2D_xmin_outer_core(j,k,ispec2D)*wgllwgll_yz(j,k)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn

          if (SIMULATION_TYPE == 3) then
            b_accel_outer_core(iglob) = b_accel_outer_core(iglob) - absorb_xmin_outer_core(j,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_xmin_outer_core(j,k,ispec2D) = weight*sn
          endif
        enddo
      enddo
    enddo
  endif

  if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_xmin_outer_core > 0 ) &
     write(61,rec=it) reclen_xmin_outer_core,absorb_xmin_outer_core,reclen_xmin_outer_core

!   xmax
! if two chunks exclude this face for one of them
  if(NCHUNKS == 1 .or. ichunk == CHUNK_AB) then

    if (SIMULATION_TYPE == 3 .and. nspec2D_xmax_outer_core > 0)  then
      read(62,rec=NSTEP-it+1) reclen1,absorb_xmax_outer_core,reclen2
      if (reclen1 /= reclen_xmax_outer_core .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_xmax_outer_core')
    endif

    do ispec2D=1,nspec2D_xmax_outer_core

      ispec=ibelm_xmax_outer_core(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_xi_outer_core(2,ispec2D) == 0 .or. njmin_outer_core(2,ispec2D) == 0) cycle

      i=NGLLX
      do k=nkmin_xi_outer_core(2,ispec2D),NGLLZ
        do j=njmin_outer_core(2,ispec2D),njmax_outer_core(2,ispec2D)
          iglob=ibool_outer_core(i,j,k,ispec)

          sn = veloc_outer_core(iglob)/vp_outer_core(i,j,k,ispec)

          weight = jacobian2D_xmax_outer_core(j,k,ispec2D)*wgllwgll_yz(j,k)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn

          if (SIMULATION_TYPE == 3) then
            b_accel_outer_core(iglob) = b_accel_outer_core(iglob) - absorb_xmax_outer_core(j,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_xmax_outer_core(j,k,ispec2D) = weight*sn
          endif

        enddo
      enddo
    enddo

  if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_xmax_outer_core > 0 ) &
     write(62,rec=it) reclen_xmax_outer_core,absorb_xmax_outer_core,reclen_xmax_outer_core

  endif

!   ymin
    if (SIMULATION_TYPE == 3 .and. nspec2D_ymin_outer_core > 0)  then
      read(63,rec=NSTEP-it+1) reclen1,absorb_ymin_outer_core,reclen2
      if (reclen1 /= reclen_ymin_outer_core .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_ymin_outer_core')
    endif

    do ispec2D=1,nspec2D_ymin_outer_core

      ispec=ibelm_ymin_outer_core(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_eta_outer_core(1,ispec2D) == 0 .or. nimin_outer_core(1,ispec2D) == 0) cycle

      j=1
      do k=nkmin_eta_outer_core(1,ispec2D),NGLLZ
        do i=nimin_outer_core(1,ispec2D),nimax_outer_core(1,ispec2D)
          iglob=ibool_outer_core(i,j,k,ispec)

          sn = veloc_outer_core(iglob)/vp_outer_core(i,j,k,ispec)

          weight=jacobian2D_ymin_outer_core(i,k,ispec2D)*wgllwgll_xz(i,k)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn

          if (SIMULATION_TYPE == 3) then
            b_accel_outer_core(iglob) = b_accel_outer_core(iglob) - absorb_ymin_outer_core(i,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_ymin_outer_core(i,k,ispec2D) = weight*sn
          endif

        enddo
      enddo
    enddo

    if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_ymin_outer_core > 0 ) &
       write(63,rec=it) reclen_ymin_outer_core,absorb_ymin_outer_core,reclen_ymin_outer_core


!   ymax
    if (SIMULATION_TYPE == 3 .and. nspec2D_ymax_outer_core > 0)  then
      read(64,rec=NSTEP-it+1) reclen1,absorb_ymax_outer_core,reclen2
      if (reclen1 /= reclen_ymax_outer_core .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_ymax_outer_core')
    endif
    do ispec2D=1,nspec2D_ymax_outer_core

      ispec=ibelm_ymax_outer_core(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_eta_outer_core(2,ispec2D) == 0 .or. nimin_outer_core(2,ispec2D) == 0) cycle

      j=NGLLY
      do k=nkmin_eta_outer_core(2,ispec2D),NGLLZ
        do i=nimin_outer_core(2,ispec2D),nimax_outer_core(2,ispec2D)
          iglob=ibool_outer_core(i,j,k,ispec)

          sn = veloc_outer_core(iglob)/vp_outer_core(i,j,k,ispec)

          weight=jacobian2D_ymax_outer_core(i,k,ispec2D)*wgllwgll_xz(i,k)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn

          if (SIMULATION_TYPE == 3) then
            b_accel_outer_core(iglob) = b_accel_outer_core(iglob) - absorb_ymax_outer_core(i,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_ymax_outer_core(i,k,ispec2D) = weight*sn
          endif

        enddo
      enddo
    enddo

    if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_ymax_outer_core > 0 ) &
       write(64,rec=it) reclen_ymax_outer_core,absorb_ymax_outer_core,reclen_ymax_outer_core


! for surface elements exactly on the ICB
   if (SIMULATION_TYPE == 3 .and. NSPEC2D_BOTTOM(IREGION_OUTER_CORE)> 0)  then
      read(65,rec=NSTEP-it+1) reclen1,absorb_zmin_outer_core,reclen2
      if (reclen1 /= reclen_zmin .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_zmin_outer_core')
    endif
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)

      ispec = ibelm_bottom_outer_core(ispec2D)

      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX
          iglob = ibool_outer_core(i,j,k,ispec)

          sn = veloc_outer_core(iglob)/vp_outer_core(i,j,k,ispec)

          weight = jacobian2D_bottom_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn

          if (SIMULATION_TYPE == 3) then
            b_accel_outer_core(iglob) = b_accel_outer_core(iglob) - absorb_zmin_outer_core(i,j,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_zmin_outer_core(i,j,ispec2D) = weight*sn
          endif

        enddo
      enddo
    enddo

    if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. NSPEC2D_BOTTOM(IREGION_OUTER_CORE) > 0 ) &
       write(65,rec=it) reclen_zmin,absorb_zmin_outer_core,reclen_zmin

  endif ! Stacey conditions


! ****************************************************
! **********  add matching with solid part  **********
! ****************************************************

! only for elements in first matching layer in the fluid

!---
!--- couple with mantle at the top of the outer core
!---

  if(ACTUALLY_COUPLE_FLUID_CMB) then

! for surface elements exactly on the CMB
    do ispec2D = 1,NSPEC2D_TOP(IREGION_OUTER_CORE)
      ispec = ibelm_top_outer_core(ispec2D)

! only for DOFs exactly on the CMB (top of these elements)
      k = NGLLZ
      do j = 1,NGLLY
        do i = 1,NGLLX

! get velocity on the solid side using pointwise matching
          ispec_selected = ibelm_bottom_crust_mantle(ispec2D)

! corresponding points are located at the bottom of the mantle
          k_corresp = 1
          iglob = ibool_crust_mantle(i,j,k_corresp,ispec_selected)

          vx = displ_crust_mantle(1,iglob)
          vy = displ_crust_mantle(2,iglob)
          vz = displ_crust_mantle(3,iglob)

! get global point number
          iglob = ibool_outer_core(i,j,k,ispec)

! get normal on the CMB
          nx = normal_top_outer_core(1,i,j,ispec2D)
          ny = normal_top_outer_core(2,i,j,ispec2D)
          nz = normal_top_outer_core(3,i,j,ispec2D)

! compute dot product
          vn = vx*nx+vy*ny+vz*nz

! formulation with generalized potential
          weight = jacobian2D_top_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel_outer_core(iglob) = accel_outer_core(iglob) + weight*vn

          if (SIMULATION_TYPE == 3) then
            iglob = ibool_crust_mantle(i,j,k_corresp,ispec_selected)
            vx = b_displ_crust_mantle(1,iglob)
            vy = b_displ_crust_mantle(2,iglob)
            vz = b_displ_crust_mantle(3,iglob)
            vn = vx*nx+vy*ny+vz*nz
            iglob = ibool_outer_core(i,j,k,ispec)
            b_accel_outer_core(iglob) = b_accel_outer_core(iglob) + weight*vn
          endif

        enddo
      enddo
    enddo

    endif

!---
!--- couple with inner core at the bottom of the outer core
!---

  if(ACTUALLY_COUPLE_FLUID_ICB .and. NCHUNKS == 6) then

! for surface elements exactly on the ICB
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)
      ispec = ibelm_bottom_outer_core(ispec2D)

! only for DOFs exactly on the ICB (bottom of these elements)
      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX

! get velocity on the solid side using pointwise matching
          ispec_selected = ibelm_top_inner_core(ispec2D)

! corresponding points are located at the bottom of the mantle
          k_corresp = NGLLZ
          iglob = ibool_inner_core(i,j,k_corresp,ispec_selected)

          vx = displ_inner_core(1,iglob)
          vy = displ_inner_core(2,iglob)
          vz = displ_inner_core(3,iglob)

! get global point number
          iglob = ibool_outer_core(i,j,k,ispec)

! get normal on the ICB
          nx = normal_bottom_outer_core(1,i,j,ispec2D)
          ny = normal_bottom_outer_core(2,i,j,ispec2D)
          nz = normal_bottom_outer_core(3,i,j,ispec2D)

! compute dot product
          vn = vx*nx+vy*ny+vz*nz

! formulation with generalized potential
          weight = jacobian2D_bottom_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*vn

          if (SIMULATION_TYPE == 3) then
            iglob = ibool_inner_core(i,j,k_corresp,ispec_selected)
            vx = b_displ_inner_core(1,iglob)
            vy = b_displ_inner_core(2,iglob)
            vz = b_displ_inner_core(3,iglob)
            vn = vx*nx+vy*ny+vz*nz
            iglob = ibool_outer_core(i,j,k,ispec)
            b_accel_outer_core(iglob) = b_accel_outer_core(iglob) - weight*vn
          endif

        enddo
      enddo
    enddo

  endif

! assemble all the contributions between slices using MPI

! outer core
  call assemble_MPI_scalar(myrank,accel_outer_core,nglob_outer_core, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_outer_core,iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core, &
            npoin2D_faces_outer_core,npoin2D_xi_outer_core,npoin2D_eta_outer_core, &
            iboolfaces_outer_core,iboolcorner_outer_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_OUTER_CORE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE),NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE),NPOIN2DMAX_XY,NCHUNKS)

! multiply by the inverse of the mass matrix and update velocity
  do i=1,nglob_outer_core
    accel_outer_core(i) = accel_outer_core(i)*rmass_outer_core(i)
    veloc_outer_core(i) = veloc_outer_core(i) + deltatover2*accel_outer_core(i)
  enddo

  if (SIMULATION_TYPE == 3) then
  call assemble_MPI_scalar(myrank,b_accel_outer_core,nglob_outer_core, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_outer_core,iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core, &
            npoin2D_faces_outer_core,npoin2D_xi_outer_core,npoin2D_eta_outer_core, &
            iboolfaces_outer_core,iboolcorner_outer_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_OUTER_CORE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE),NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE),NPOIN2DMAX_XY,NCHUNKS)

  do i=1,nglob_outer_core
    b_accel_outer_core(i) = b_accel_outer_core(i)*rmass_outer_core(i)
    b_veloc_outer_core(i) = b_veloc_outer_core(i) + b_deltatover2*b_accel_outer_core(i)
  enddo
  endif

! ****************************************************
!   big loop over all spectral elements in the solid
! ****************************************************

! compute internal forces in the solid regions

! for anisotropy and gravity, x y and z contain r theta and phi

  call compute_forces_crust_mantle(ell_d80,minus_gravity_table,density_table,minus_deriv_gravity_table, &
          nspec_crust_mantle,displ_crust_mantle,accel_crust_mantle, &
          xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
          xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle, &
          etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
          gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,jacobian_crust_mantle, &
          hprime_xx,hprime_yy,hprime_zz, &
          hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
          wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube, &
          kappavstore_crust_mantle,kappahstore_crust_mantle,muvstore_crust_mantle, &
          muhstore_crust_mantle,eta_anisostore_crust_mantle, &
          c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle, &
          c14store_crust_mantle,c15store_crust_mantle,c16store_crust_mantle, &
          c22store_crust_mantle,c23store_crust_mantle,c24store_crust_mantle, &
          c25store_crust_mantle,c26store_crust_mantle,c33store_crust_mantle, &
          c34store_crust_mantle,c35store_crust_mantle,c36store_crust_mantle, &
          c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
          c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
          ibool_crust_mantle,idoubling_crust_mantle, &
          R_memory_crust_mantle,epsilondev_crust_mantle,eps_trace_over_3_crust_mantle,one_minus_sum_beta_crust_mantle, &
          alphaval,betaval,gammaval,factor_common_crust_mantle, &
          size(factor_common_crust_mantle,2), size(factor_common_crust_mantle,3), &
          size(factor_common_crust_mantle,4), size(factor_common_crust_mantle,5),SAVE_STRAIN,AM_V)

  if (SIMULATION_TYPE == 3) then
! for anisotropy and gravity, x y and z contain r theta and phi
  call compute_forces_crust_mantle(ell_d80,minus_gravity_table,density_table,minus_deriv_gravity_table, &
          nspec_crust_mantle,b_displ_crust_mantle,b_accel_crust_mantle, &
          xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
          xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle, &
          etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
          gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,jacobian_crust_mantle, &
          hprime_xx,hprime_yy,hprime_zz, &
          hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
          wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube, &
          kappavstore_crust_mantle,kappahstore_crust_mantle,muvstore_crust_mantle, &
          muhstore_crust_mantle,eta_anisostore_crust_mantle, &
          c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle, &
          c14store_crust_mantle,c15store_crust_mantle,c16store_crust_mantle, &
          c22store_crust_mantle,c23store_crust_mantle,c24store_crust_mantle, &
          c25store_crust_mantle,c26store_crust_mantle,c33store_crust_mantle, &
          c34store_crust_mantle,c35store_crust_mantle,c36store_crust_mantle, &
          c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
          c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
          ibool_crust_mantle,idoubling_crust_mantle, &
          b_R_memory_crust_mantle,b_epsilondev_crust_mantle,b_eps_trace_over_3_crust_mantle,one_minus_sum_beta_crust_mantle, &
          b_alphaval,b_betaval,b_gammaval,factor_common_crust_mantle, &
          size(factor_common_crust_mantle,2), size(factor_common_crust_mantle,3), &
          size(factor_common_crust_mantle,4), size(factor_common_crust_mantle,5),SAVE_STRAIN,AM_V)
  endif


! Stacey
  if(NCHUNKS /= 6 .and. ABSORBING_CONDITIONS) then

! crust & mantle

!   xmin
! if two chunks exclude this face for one of them
  if(NCHUNKS == 1 .or. ichunk == CHUNK_AC) then

    if (SIMULATION_TYPE == 3 .and. nspec2D_xmin_crust_mantle > 0)  then
      read(51,rec=NSTEP-it+1) reclen1,absorb_xmin_crust_mantle,reclen2
      if (reclen1 /= reclen_xmin_crust_mantle .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_xmin')
    endif

    do ispec2D=1,nspec2D_xmin_crust_mantle

      ispec=ibelm_xmin_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_xi_crust_mantle(1,ispec2D) == 0 .or. njmin_crust_mantle(1,ispec2D) == 0) cycle

      i=1
      do k=nkmin_xi_crust_mantle(1,ispec2D),NGLLZ
        do j=njmin_crust_mantle(1,ispec2D),njmax_crust_mantle(1,ispec2D)
          iglob=ibool_crust_mantle(i,j,k,ispec)

          vx=veloc_crust_mantle(1,iglob)
          vy=veloc_crust_mantle(2,iglob)
          vz=veloc_crust_mantle(3,iglob)

          nx=normal_xmin_crust_mantle(1,j,k,ispec2D)
          ny=normal_xmin_crust_mantle(2,j,k,ispec2D)
          nz=normal_xmin_crust_mantle(3,j,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp_crust_mantle(i,j,k,ispec)*vn*nx+rho_vs_crust_mantle(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp_crust_mantle(i,j,k,ispec)*vn*ny+rho_vs_crust_mantle(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp_crust_mantle(i,j,k,ispec)*vn*nz+rho_vs_crust_mantle(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_xmin_crust_mantle(j,k,ispec2D)*wgllwgll_yz(j,k)

          accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
          accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
          accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

          if (SIMULATION_TYPE == 3) then
            b_accel_crust_mantle(:,iglob)=b_accel_crust_mantle(:,iglob) - absorb_xmin_crust_mantle(:,j,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_xmin_crust_mantle(1,j,k,ispec2D) = tx*weight
            absorb_xmin_crust_mantle(2,j,k,ispec2D) = ty*weight
            absorb_xmin_crust_mantle(3,j,k,ispec2D) = tz*weight
          endif

        enddo
      enddo
    enddo
  endif

  if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_xmin_crust_mantle > 0 ) &
     write(51,rec=it) reclen_xmin_crust_mantle,absorb_xmin_crust_mantle,reclen_xmin_crust_mantle

!   xmax
! if two chunks exclude this face for one of them
  if(NCHUNKS == 1 .or. ichunk == CHUNK_AB) then

    if (SIMULATION_TYPE == 3 .and. nspec2D_xmax_crust_mantle > 0)  then
      read(52,rec=NSTEP-it+1) reclen1,absorb_xmax_crust_mantle,reclen2
      if (reclen1 /= reclen_xmax_crust_mantle .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_xmax')
    endif

    do ispec2D=1,nspec2D_xmax_crust_mantle

      ispec=ibelm_xmax_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_xi_crust_mantle(2,ispec2D) == 0 .or. njmin_crust_mantle(2,ispec2D) == 0) cycle

      i=NGLLX
      do k=nkmin_xi_crust_mantle(2,ispec2D),NGLLZ
        do j=njmin_crust_mantle(2,ispec2D),njmax_crust_mantle(2,ispec2D)
          iglob=ibool_crust_mantle(i,j,k,ispec)

          vx=veloc_crust_mantle(1,iglob)
          vy=veloc_crust_mantle(2,iglob)
          vz=veloc_crust_mantle(3,iglob)

          nx=normal_xmax_crust_mantle(1,j,k,ispec2D)
          ny=normal_xmax_crust_mantle(2,j,k,ispec2D)
          nz=normal_xmax_crust_mantle(3,j,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp_crust_mantle(i,j,k,ispec)*vn*nx+rho_vs_crust_mantle(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp_crust_mantle(i,j,k,ispec)*vn*ny+rho_vs_crust_mantle(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp_crust_mantle(i,j,k,ispec)*vn*nz+rho_vs_crust_mantle(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_xmax_crust_mantle(j,k,ispec2D)*wgllwgll_yz(j,k)

          accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
          accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
          accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

          if (SIMULATION_TYPE == 3) then
            b_accel_crust_mantle(:,iglob)=b_accel_crust_mantle(:,iglob) - absorb_xmax_crust_mantle(:,j,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_xmax_crust_mantle(1,j,k,ispec2D) = tx*weight
            absorb_xmax_crust_mantle(2,j,k,ispec2D) = ty*weight
            absorb_xmax_crust_mantle(3,j,k,ispec2D) = tz*weight
          endif

        enddo
      enddo
    enddo
  endif

  if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_xmax_crust_mantle > 0 ) &
     write(52,rec=it) reclen_xmax_crust_mantle,absorb_xmax_crust_mantle,reclen_xmax_crust_mantle

!   ymin

    if (SIMULATION_TYPE == 3 .and. nspec2D_ymin_crust_mantle > 0)  then
      read(53,rec=NSTEP-it+1) reclen1,absorb_ymin_crust_mantle,reclen2
      if (reclen1 /= reclen_ymin_crust_mantle .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_ymin')
    endif
    do ispec2D=1,nspec2D_ymin_crust_mantle

      ispec=ibelm_ymin_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_eta_crust_mantle(1,ispec2D) == 0 .or. nimin_crust_mantle(1,ispec2D) == 0) cycle

      j=1
      do k=nkmin_eta_crust_mantle(1,ispec2D),NGLLZ
        do i=nimin_crust_mantle(1,ispec2D),nimax_crust_mantle(1,ispec2D)
          iglob=ibool_crust_mantle(i,j,k,ispec)

          vx=veloc_crust_mantle(1,iglob)
          vy=veloc_crust_mantle(2,iglob)
          vz=veloc_crust_mantle(3,iglob)

          nx=normal_ymin_crust_mantle(1,i,k,ispec2D)
          ny=normal_ymin_crust_mantle(2,i,k,ispec2D)
          nz=normal_ymin_crust_mantle(3,i,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp_crust_mantle(i,j,k,ispec)*vn*nx+rho_vs_crust_mantle(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp_crust_mantle(i,j,k,ispec)*vn*ny+rho_vs_crust_mantle(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp_crust_mantle(i,j,k,ispec)*vn*nz+rho_vs_crust_mantle(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_ymin_crust_mantle(i,k,ispec2D)*wgllwgll_xz(i,k)

          accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
          accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
          accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

          if (SIMULATION_TYPE == 3) then
            b_accel_crust_mantle(:,iglob)=b_accel_crust_mantle(:,iglob) - absorb_ymin_crust_mantle(:,i,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_ymin_crust_mantle(1,i,k,ispec2D) = tx*weight
            absorb_ymin_crust_mantle(2,i,k,ispec2D) = ty*weight
            absorb_ymin_crust_mantle(3,i,k,ispec2D) = tz*weight
          endif

        enddo
      enddo
    enddo

    if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_ymin_crust_mantle > 0 ) &
       write(53,rec=it) reclen_ymin_crust_mantle,absorb_ymin_crust_mantle,reclen_ymin_crust_mantle

!   ymax

    if (SIMULATION_TYPE == 3 .and. nspec2D_ymax_crust_mantle > 0)  then
      read(54,rec=NSTEP-it+1) reclen1,absorb_ymax_crust_mantle,reclen2
      if (reclen1 /= reclen_ymax_crust_mantle .or. reclen1 /= reclen2)  &
         call exit_MPI(myrank,'Error reading absorbing contribution absorb_ymax')
    endif
    do ispec2D=1,nspec2D_ymax_crust_mantle

      ispec=ibelm_ymax_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_eta_crust_mantle(2,ispec2D) == 0 .or. nimin_crust_mantle(2,ispec2D) == 0) cycle

      j=NGLLY
      do k=nkmin_eta_crust_mantle(2,ispec2D),NGLLZ
        do i=nimin_crust_mantle(2,ispec2D),nimax_crust_mantle(2,ispec2D)
          iglob=ibool_crust_mantle(i,j,k,ispec)

          vx=veloc_crust_mantle(1,iglob)
          vy=veloc_crust_mantle(2,iglob)
          vz=veloc_crust_mantle(3,iglob)

          nx=normal_ymax_crust_mantle(1,i,k,ispec2D)
          ny=normal_ymax_crust_mantle(2,i,k,ispec2D)
          nz=normal_ymax_crust_mantle(3,i,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp_crust_mantle(i,j,k,ispec)*vn*nx+rho_vs_crust_mantle(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp_crust_mantle(i,j,k,ispec)*vn*ny+rho_vs_crust_mantle(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp_crust_mantle(i,j,k,ispec)*vn*nz+rho_vs_crust_mantle(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_ymax_crust_mantle(i,k,ispec2D)*wgllwgll_xz(i,k)

          accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
          accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
          accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

          if (SIMULATION_TYPE == 3) then
            b_accel_crust_mantle(:,iglob)=b_accel_crust_mantle(:,iglob) - absorb_ymax_crust_mantle(:,i,k,ispec2D)
          else if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
            absorb_ymax_crust_mantle(1,i,k,ispec2D) = tx*weight
            absorb_ymax_crust_mantle(2,i,k,ispec2D) = ty*weight
            absorb_ymax_crust_mantle(3,i,k,ispec2D) = tz*weight
          endif

        enddo
      enddo
    enddo
    if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD .and. nspec2D_ymax_crust_mantle > 0 ) &
       write(54,rec=it) reclen_ymax_crust_mantle,absorb_ymax_crust_mantle,reclen_ymax_crust_mantle

  endif ! Stacey conditions

  call compute_forces_inner_core(minus_gravity_table,density_table,minus_deriv_gravity_table, &
          displ_inner_core,accel_inner_core, &
          xstore_inner_core,ystore_inner_core,zstore_inner_core, &
          xix_inner_core,xiy_inner_core,xiz_inner_core, &
          etax_inner_core,etay_inner_core,etaz_inner_core, &
          gammax_inner_core,gammay_inner_core,gammaz_inner_core,jacobian_inner_core, &
          hprime_xx,hprime_yy,hprime_zz, &
          hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
          wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube, &
          kappavstore_inner_core,muvstore_inner_core,ibool_inner_core,idoubling_inner_core, &
          c11store_inner_core,c33store_inner_core,c12store_inner_core,c13store_inner_core,c44store_inner_core, &
          R_memory_inner_core,epsilondev_inner_core, eps_trace_over_3_inner_core,&
          one_minus_sum_beta_inner_core, &
          alphaval,betaval,gammaval, &
          factor_common_inner_core, &
          size(factor_common_inner_core,2), size(factor_common_inner_core,3), &
          size(factor_common_inner_core,4), size(factor_common_inner_core,5),SAVE_STRAIN,AM_V)

  if (SIMULATION_TYPE == 3) then
  call compute_forces_inner_core(minus_gravity_table,density_table,minus_deriv_gravity_table, &
          b_displ_inner_core,b_accel_inner_core, &
          xstore_inner_core,ystore_inner_core,zstore_inner_core, &
          xix_inner_core,xiy_inner_core,xiz_inner_core, &
          etax_inner_core,etay_inner_core,etaz_inner_core, &
          gammax_inner_core,gammay_inner_core,gammaz_inner_core,jacobian_inner_core, &
          hprime_xx,hprime_yy,hprime_zz, &
          hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
          wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube, &
          kappavstore_inner_core,muvstore_inner_core,ibool_inner_core,idoubling_inner_core, &
          c11store_inner_core,c33store_inner_core,c12store_inner_core,c13store_inner_core,c44store_inner_core, &
          b_R_memory_inner_core,b_epsilondev_inner_core, b_eps_trace_over_3_inner_core,&
          one_minus_sum_beta_inner_core, &
          b_alphaval,b_betaval,b_gammaval, &
          factor_common_inner_core, &
          size(factor_common_inner_core,2), size(factor_common_inner_core,3), &
          size(factor_common_inner_core,4), size(factor_common_inner_core,5),SAVE_STRAIN,AM_V)
  endif

! add the sources
  if (SIMULATION_TYPE == 1) then
  do isource = 1,NSOURCES

! add only if this proc carries the source
    if(myrank == islice_selected_source(isource)) then

      stf = comp_source_time_function(dble(it-1)*DT-t0-t_cmt(isource),hdur_gaussian(isource))

!     distinguish between single and double precision for reals
      if(CUSTOM_REAL == SIZE_REAL) then
        stf_used = sngl(stf)
      else
        stf_used = stf
      endif

!     add source array
      do k=1,NGLLZ
        do j=1,NGLLY
          do i=1,NGLLX
            iglob = ibool_crust_mantle(i,j,k,ispec_selected_source(isource))
            accel_crust_mantle(:,iglob) = accel_crust_mantle(:,iglob) + sourcearrays(isource,:,i,j,k)*stf_used
          enddo
        enddo
      enddo

    endif

  enddo
  endif

  if (SIMULATION_TYPE == 2 .or. SIMULATION_TYPE == 3) then
! figure out if we need to read in a chunk of the adjoint source at this timestep
        it_sub_adj = ceiling( dble(it)/dble(NTSTEP_BETWEEN_READ_ADJSRC) )   !chunk_number
        ibool_read_adj_arrays = (((it == it_begin) .or. (mod(it-1,NTSTEP_BETWEEN_READ_ADJSRC) == 0)) .and. (nadj_rec_local > 0))

        if(ibool_read_adj_arrays) then
           irec_local = 0
           do irec = 1, nrec
! check that the source slice number is okay
              if(islice_selected_rec(irec) < 0 .or. islice_selected_rec(irec) > NPROCTOT-1) then
                 if(islice_selected_rec(irec) < 0) call exit_MPI(myrank,'islice < 0')
                 if(islice_selected_rec(irec) > NPROCTOT-1) call exit_MPI(myrank,'islice > NPROCTOT-1')
                 call exit_MPI(myrank,'now: something is wrong with the source slice number in adjoint simulation')
              endif
! compute source arrays
              if(myrank == islice_selected_rec(irec)) then
                 irec_local = irec_local + 1
                 adj_source_file = trim(station_name(irec))//'.'//trim(network_name(irec))
                 call comp_subarrays_adjoint_src(myrank,adj_source_file, &
                      xi_receiver(irec),eta_receiver(irec),gamma_receiver(irec), &
                      nu(:,:,irec),adj_sourcearray, xigll,yigll,zigll,iadjsrc_len(it_sub_adj), &
                      iadjsrc,it_sub_adj,NSTEP_SUB_ADJ)
                 adj_sourcearrays(irec_local,:,:,:,:,:) = adj_sourcearray(:,:,:,:,:)
              endif
           enddo
           if(irec_local /= nadj_rec_local) &
                call exit_MPI(myrank,'irec_local /= nadj_rec_local in adjoint simulation')
        endif

    irec_local = 0
    do irec = 1,nrec
!

!   add the source (only if this proc carries the source)
      if(myrank == islice_selected_rec(irec)) then
        irec_local = irec_local + 1

!     add source array
        do k=1,NGLLZ
          do j=1,NGLLY
            do i=1,NGLLX
              iglob = ibool_crust_mantle(i,j,k,ispec_selected_rec(irec))
              accel_crust_mantle(:,iglob) = accel_crust_mantle(:,iglob) + adj_sourcearrays(irec_local,iadj_vec(it),:,i,j,k)
            enddo
          enddo
        enddo
      endif

    enddo

  endif

  if (SIMULATION_TYPE == 3) then
  do isource = 1,NSOURCES

!   add the source (only if this proc carries the source)
    if(myrank == islice_selected_source(isource)) then

      stf = comp_source_time_function(dble(NSTEP-it+1)*DT-t0-t_cmt(isource),hdur_gaussian(isource))

!     distinguish between single and double precision for reals
      if(CUSTOM_REAL == SIZE_REAL) then
        stf_used = sngl(stf)
      else
        stf_used = stf
      endif

!     add source array
      do k=1,NGLLZ
        do j=1,NGLLY
          do i=1,NGLLX
            iglob = ibool_crust_mantle(i,j,k,ispec_selected_source(isource))
            b_accel_crust_mantle(:,iglob) = b_accel_crust_mantle(:,iglob) + sourcearrays(isource,:,i,j,k)*stf_used
          enddo
        enddo
      enddo

    endif

  enddo
  endif



! ****************************************************
! **********  add matching with fluid part  **********
! ****************************************************

! only for elements in first matching layer in the solid

!---
!--- couple with outer core at the bottom of the mantle
!---

  if(ACTUALLY_COUPLE_FLUID_CMB) then

! for surface elements exactly on the CMB
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_CRUST_MANTLE)

      ispec = ibelm_bottom_crust_mantle(ispec2D)

! only for DOFs exactly on the CMB (bottom of these elements)
      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX

! get velocity potential on the fluid side using pointwise matching
          ispec_selected = ibelm_top_outer_core(ispec2D)
          k_corresp = NGLLZ

! get normal at the CMB
          nx = normal_top_outer_core(1,i,j,ispec2D)
          ny = normal_top_outer_core(2,i,j,ispec2D)
          nz = normal_top_outer_core(3,i,j,ispec2D)

! get global point number
! corresponding points are located at the top of the outer core
          iglob = ibool_outer_core(i,j,NGLLZ,ispec_selected)
          iglob_mantle = ibool_crust_mantle(i,j,k,ispec)

! compute pressure, taking gravity into account
          if(GRAVITY_VAL) then
            pressure = RHO_TOP_OC * (- accel_outer_core(iglob) &
               + minus_g_cmb *(displ_crust_mantle(1,iglob_mantle)*nx &
               + displ_crust_mantle(2,iglob_mantle)*ny + displ_crust_mantle(3,iglob_mantle)*nz))
          else
            pressure = - RHO_TOP_OC * accel_outer_core(iglob)
          endif

! formulation with generalized potential
          weight = jacobian2D_top_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel_crust_mantle(1,iglob_mantle) = accel_crust_mantle(1,iglob_mantle) + weight*nx*pressure
          accel_crust_mantle(2,iglob_mantle) = accel_crust_mantle(2,iglob_mantle) + weight*ny*pressure
          accel_crust_mantle(3,iglob_mantle) = accel_crust_mantle(3,iglob_mantle) + weight*nz*pressure

          if (SIMULATION_TYPE == 3) then
          if(GRAVITY_VAL) then
            pressure = RHO_TOP_OC * (- b_accel_outer_core(iglob) &
               + minus_g_cmb *(b_displ_crust_mantle(1,iglob_mantle)*nx &
               + b_displ_crust_mantle(2,iglob_mantle)*ny + b_displ_crust_mantle(3,iglob_mantle)*nz))
          else
            pressure = - RHO_TOP_OC * b_accel_outer_core(iglob)
          endif
          b_accel_crust_mantle(1,iglob_mantle) = b_accel_crust_mantle(1,iglob_mantle) + weight*nx*pressure
          b_accel_crust_mantle(2,iglob_mantle) = b_accel_crust_mantle(2,iglob_mantle) + weight*ny*pressure
          b_accel_crust_mantle(3,iglob_mantle) = b_accel_crust_mantle(3,iglob_mantle) + weight*nz*pressure
          endif

        enddo
      enddo
    enddo

  endif

!---
!--- couple with outer core at the top of the inner core
!---

  if(ACTUALLY_COUPLE_FLUID_ICB .and. NCHUNKS == 6) then

! for surface elements exactly on the ICB
    do ispec2D = 1,NSPEC2D_TOP(IREGION_INNER_CORE)

      ispec = ibelm_top_inner_core(ispec2D)

! only for DOFs exactly on the ICB (top of these elements)
      k = NGLLZ
      do j = 1,NGLLY
        do i = 1,NGLLX

! get velocity potential on the fluid side using pointwise matching
          ispec_selected = ibelm_bottom_outer_core(ispec2D)
          k_corresp = 1

! get normal at the ICB
          nx = normal_bottom_outer_core(1,i,j,ispec2D)
          ny = normal_bottom_outer_core(2,i,j,ispec2D)
          nz = normal_bottom_outer_core(3,i,j,ispec2D)

! get global point number
! corresponding points are located at the bottom of the outer core
          iglob = ibool_outer_core(i,j,k_corresp,ispec_selected)
          iglob_inner_core = ibool_inner_core(i,j,k,ispec)

! compute pressure, taking gravity into account
          if(GRAVITY_VAL) then
            pressure = RHO_BOTTOM_OC * (- accel_outer_core(iglob) &
               + minus_g_icb *(displ_inner_core(1,iglob_inner_core)*nx &
               + displ_inner_core(2,iglob_inner_core)*ny + displ_inner_core(3,iglob_inner_core)*nz))
          else
            pressure = - RHO_BOTTOM_OC * accel_outer_core(iglob)
          endif

! formulation with generalized potential
          weight = jacobian2D_bottom_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel_inner_core(1,iglob_inner_core) = accel_inner_core(1,iglob_inner_core) - weight*nx*pressure
          accel_inner_core(2,iglob_inner_core) = accel_inner_core(2,iglob_inner_core) - weight*ny*pressure
          accel_inner_core(3,iglob_inner_core) = accel_inner_core(3,iglob_inner_core) - weight*nz*pressure

          if (SIMULATION_TYPE == 3) then
          if(GRAVITY_VAL) then
            pressure = RHO_BOTTOM_OC * (- b_accel_outer_core(iglob) &
               + minus_g_cmb *(b_displ_inner_core(1,iglob_inner_core)*nx &
               + b_displ_inner_core(2,iglob_inner_core)*ny + b_displ_inner_core(3,iglob_inner_core)*nz))
          else
            pressure = - RHO_BOTTOM_OC * b_accel_outer_core(iglob)
          endif
          b_accel_inner_core(1,iglob_inner_core) = b_accel_inner_core(1,iglob_inner_core) - weight*nx*pressure
          b_accel_inner_core(2,iglob_inner_core) = b_accel_inner_core(2,iglob_inner_core) - weight*ny*pressure
          b_accel_inner_core(3,iglob_inner_core) = b_accel_inner_core(3,iglob_inner_core) - weight*nz*pressure
          endif

        enddo
      enddo
    enddo

    endif

! assemble all the contributions between slices using MPI

! crust and mantle
  call assemble_MPI_vector(myrank,accel_crust_mantle,nglob_crust_mantle, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_crust_mantle,iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
            npoin2D_faces_crust_mantle,npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
            iboolfaces_crust_mantle,iboolcorner_crust_mantle, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_vector,buffer_received_faces_vector, &
            buffer_send_chunkcorners_vector,buffer_recv_chunkcorners_vector, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_XY,NCHUNKS)

! inner core
  call assemble_MPI_vector(myrank,accel_inner_core,NGLOB_INNER_CORE, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_inner_core,iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core, &
            npoin2D_faces_inner_core,npoin2D_xi_inner_core,npoin2D_eta_inner_core, &
            iboolfaces_inner_core,iboolcorner_inner_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_vector,buffer_received_faces_vector, &
            buffer_send_chunkcorners_vector,buffer_recv_chunkcorners_vector, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_INNER_CORE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE),NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE),NPOIN2DMAX_XY,NCHUNKS)

!---
!---  use buffers to assemble forces with the central cube
!---

  if(INCLUDE_CENTRAL_CUBE) then

   call assemble_MPI_central_cube(ichunk,nb_msgs_theor_in_cube, sender_from_slices_to_cube, &
     npoin2D_cube_from_slices, buffer_all_cube_from_slices, buffer_slices, ibool_central_cube, &
     receiver_cube_from_slices, ibool_inner_core, idoubling_inner_core, NSPEC_INNER_CORE, &
     ibelm_bottom_inner_core, NSPEC2D_BOTTOM(IREGION_INNER_CORE),NGLOB_INNER_CORE,accel_inner_core,NDIM)

  endif   ! end of assembling forces with the central cube

  do i=1,nglob_crust_mantle
    accel_crust_mantle(1,i) = accel_crust_mantle(1,i)*rmass_crust_mantle(i) &
               + two_omega_earth*veloc_crust_mantle(2,i)
    accel_crust_mantle(2,i) = accel_crust_mantle(2,i)*rmass_crust_mantle(i) &
               - two_omega_earth*veloc_crust_mantle(1,i)
    accel_crust_mantle(3,i) = accel_crust_mantle(3,i)*rmass_crust_mantle(i)
  enddo

  if (SIMULATION_TYPE == 3) then
!  call MPI_BARRIER(MPI_COMM_WORLD,ier)

! assemble all the contributions between slices using MPI

! crust and mantle
  call assemble_MPI_vector(myrank,b_accel_crust_mantle,nglob_crust_mantle, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_crust_mantle,iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
            npoin2D_faces_crust_mantle,npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
            iboolfaces_crust_mantle,iboolcorner_crust_mantle, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_vector,buffer_received_faces_vector, &
            buffer_send_chunkcorners_vector,buffer_recv_chunkcorners_vector, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_XY,NCHUNKS)

! inner core
  call assemble_MPI_vector(myrank,b_accel_inner_core,NGLOB_INNER_CORE, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_inner_core,iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core, &
            npoin2D_faces_inner_core,npoin2D_xi_inner_core,npoin2D_eta_inner_core, &
            iboolfaces_inner_core,iboolcorner_inner_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_worker1_corners,iproc_worker2_corners, &
            buffer_send_faces_vector,buffer_received_faces_vector, &
            buffer_send_chunkcorners_vector,buffer_recv_chunkcorners_vector, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_INNER_CORE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE),NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE),NPOIN2DMAX_XY,NCHUNKS)

!---
!---  use buffers to assemble forces with the central cube
!---

  if(INCLUDE_CENTRAL_CUBE) then

   call assemble_MPI_central_cube(ichunk,nb_msgs_theor_in_cube, sender_from_slices_to_cube, &
     npoin2D_cube_from_slices, buffer_all_cube_from_slices, buffer_slices, ibool_central_cube, &
     receiver_cube_from_slices, ibool_inner_core, idoubling_inner_core, NSPEC_INNER_CORE, &
     ibelm_bottom_inner_core, NSPEC2D_BOTTOM(IREGION_INNER_CORE),NGLOB_INNER_CORE,b_accel_inner_core,NDIM)

  endif   ! end of assembling forces with the central cube

  do i=1,nglob_crust_mantle
    b_accel_crust_mantle(1,i) = b_accel_crust_mantle(1,i)*rmass_crust_mantle(i) &
               + b_two_omega_earth*b_veloc_crust_mantle(2,i)
    b_accel_crust_mantle(2,i) = b_accel_crust_mantle(2,i)*rmass_crust_mantle(i) &
               - b_two_omega_earth*b_veloc_crust_mantle(1,i)
    b_accel_crust_mantle(3,i) = b_accel_crust_mantle(3,i)*rmass_crust_mantle(i)
  enddo

  endif

  if(OCEANS) then

!   initialize the updates
    updated_dof_ocean_load(:) = .false.

! for surface elements exactly at the top of the crust (ocean bottom)
    do ispec2D = 1,NSPEC2D_TOP(IREGION_CRUST_MANTLE)

      ispec = ibelm_top_crust_mantle(ispec2D)

! only for DOFs exactly at the top of the crust (ocean bottom)
      k = NGLLZ

      do j = 1,NGLLY
        do i = 1,NGLLX

! get global point number
          iglob = ibool_crust_mantle(i,j,k,ispec)

! only update once
          if(.not. updated_dof_ocean_load(iglob)) then

! get normal
            nx = normal_top_crust_mantle(1,i,j,ispec2D)
            ny = normal_top_crust_mantle(2,i,j,ispec2D)
            nz = normal_top_crust_mantle(3,i,j,ispec2D)

! make updated component of right-hand side
! we divide by rmass_crust_mantle() which is 1 / M
! we use the total force which includes the Coriolis term above
            force_normal_comp = (accel_crust_mantle(1,iglob)*nx + &
                 accel_crust_mantle(2,iglob)*ny + &
                 accel_crust_mantle(3,iglob)*nz) / rmass_crust_mantle(iglob)

            additional_term = (rmass_ocean_load(iglob) - rmass_crust_mantle(iglob)) * force_normal_comp

            accel_crust_mantle(1,iglob) = accel_crust_mantle(1,iglob) + additional_term * nx
            accel_crust_mantle(2,iglob) = accel_crust_mantle(2,iglob) + additional_term * ny
            accel_crust_mantle(3,iglob) = accel_crust_mantle(3,iglob) + additional_term * nz

            if (SIMULATION_TYPE == 3) then
              b_force_normal_comp = (b_accel_crust_mantle(1,iglob)*nx + &
                 b_accel_crust_mantle(2,iglob)*ny + &
                 b_accel_crust_mantle(3,iglob)*nz) / rmass_crust_mantle(iglob)

              b_additional_term = (rmass_ocean_load(iglob) - rmass_crust_mantle(iglob)) * b_force_normal_comp

              b_accel_crust_mantle(1,iglob) = b_accel_crust_mantle(1,iglob) + b_additional_term * nx
              b_accel_crust_mantle(2,iglob) = b_accel_crust_mantle(2,iglob) + b_additional_term * ny
              b_accel_crust_mantle(3,iglob) = b_accel_crust_mantle(3,iglob) + b_additional_term * nz
            endif

!           done with this point
            updated_dof_ocean_load(iglob) = .true.

          endif

        enddo
      enddo
    enddo
  endif

  do i=1,nglob_crust_mantle
    veloc_crust_mantle(:,i) = veloc_crust_mantle(:,i) + deltatover2*accel_crust_mantle(:,i)
  enddo

  do i=1,NGLOB_INNER_CORE
    accel_inner_core(1,i) = accel_inner_core(1,i)*rmass_inner_core(i) &
             + two_omega_earth*veloc_inner_core(2,i)
    accel_inner_core(2,i) = accel_inner_core(2,i)*rmass_inner_core(i) &
             - two_omega_earth*veloc_inner_core(1,i)
    accel_inner_core(3,i) = accel_inner_core(3,i)*rmass_inner_core(i)

    veloc_inner_core(:,i) = veloc_inner_core(:,i) + deltatover2*accel_inner_core(:,i)
  enddo

  if (SIMULATION_TYPE == 3) then
    do i=1,nglob_crust_mantle
      b_veloc_crust_mantle(:,i) = b_veloc_crust_mantle(:,i) + b_deltatover2*b_accel_crust_mantle(:,i)
    enddo
    do i=1,NGLOB_INNER_CORE
      b_accel_inner_core(1,i) = b_accel_inner_core(1,i)*rmass_inner_core(i) &
         + b_two_omega_earth*b_veloc_inner_core(2,i)
      b_accel_inner_core(2,i) = b_accel_inner_core(2,i)*rmass_inner_core(i) &
         - b_two_omega_earth*b_veloc_inner_core(1,i)
      b_accel_inner_core(3,i) = b_accel_inner_core(3,i)*rmass_inner_core(i)

      b_veloc_inner_core(:,i) = b_veloc_inner_core(:,i) + b_deltatover2*b_accel_inner_core(:,i)
    enddo
  endif

! write the seismograms with time shift

! write the seismograms only if there is at least one receiver located in this slice
  if (nrec_local > 0) then

  do irec_local = 1,nrec_local

! get global number of that receiver
    irec = number_receiver_global(irec_local)

! perform the general interpolation using Lagrange polynomials
    uxd = ZERO
    uyd = ZERO
    uzd = ZERO

    if (SIMULATION_TYPE == 1) then
      do k = 1,NGLLZ
        do j = 1,NGLLY
          do i = 1,NGLLX

            iglob = ibool_crust_mantle(i,j,k,ispec_selected_rec(irec))

            hlagrange = hxir_store(irec_local,i)*hetar_store(irec_local,j)*hgammar_store(irec_local,k)

            uxd = uxd + dble(displ_crust_mantle(1,iglob))*hlagrange
            uyd = uyd + dble(displ_crust_mantle(2,iglob))*hlagrange
            uzd = uzd + dble(displ_crust_mantle(3,iglob))*hlagrange

          enddo
        enddo
      enddo
! store North, East and Vertical components

! distinguish between single and double precision for reals
      if(CUSTOM_REAL == SIZE_REAL) then
        seismograms(:,irec_local,it) = sngl(scale_displ*(nu(:,1,irec)*uxd + &
                   nu(:,2,irec)*uyd + nu(:,3,irec)*uzd))
      else
        seismograms(:,irec_local,it) = scale_displ*(nu(:,1,irec)*uxd + &
                   nu(:,2,irec)*uyd + nu(:,3,irec)*uzd)
      endif

    else if (SIMULATION_TYPE == 2) then

      eps_trace = ZERO
      dxx = ZERO
      dyy = ZERO
      dxy = ZERO
      dxz = ZERO
      dyz = ZERO

      do k = 1,NGLLZ
        do j = 1,NGLLY
          do i = 1,NGLLX

            iglob = ibool_crust_mantle(i,j,k,ispec_selected_source(irec))

            hlagrange = hxir_store(irec_local,i)*hetar_store(irec_local,j)*hgammar_store(irec_local,k)

            uxd = uxd + dble(displ_crust_mantle(1,iglob))*hlagrange
            uyd = uyd + dble(displ_crust_mantle(2,iglob))*hlagrange
            uzd = uzd + dble(displ_crust_mantle(3,iglob))*hlagrange

            eps_trace = eps_trace + dble(eps_trace_over_3_crust_mantle(i,j,k,ispec_selected_source(irec)))*hlagrange
            dxx = dxx + dble(epsilondev_crust_mantle(1,i,j,k,ispec_selected_source(irec)))*hlagrange
            dyy = dyy + dble(epsilondev_crust_mantle(2,i,j,k,ispec_selected_source(irec)))*hlagrange
            dxy = dxy + dble(epsilondev_crust_mantle(3,i,j,k,ispec_selected_source(irec)))*hlagrange
            dxz = dxz + dble(epsilondev_crust_mantle(4,i,j,k,ispec_selected_source(irec)))*hlagrange
            dyz = dyz + dble(epsilondev_crust_mantle(5,i,j,k,ispec_selected_source(irec)))*hlagrange

          enddo
        enddo
      enddo

      eps_loc(1,1) = eps_trace + dxx
      eps_loc(2,2) = eps_trace + dyy
      eps_loc(3,3) = eps_trace - dxx - dyy
      eps_loc(1,2) = dxy
      eps_loc(1,3) = dxz
      eps_loc(2,3) = dyz
      eps_loc(2,1) = dxy
      eps_loc(3,1) = dxz
      eps_loc(3,2) = dyz

      eps_loc_new(:,:) = eps_loc(:,:)
! LQY -- does not rotate eps_loc first.
!      eps_loc_new(:,:) = matmul(matmul(nu_source(:,:,irec),eps_loc(:,:)), transpose(nu_source(:,:,irec)))

! distinguish between single and double precision for reals
      if (CUSTOM_REAL == SIZE_REAL) then
        seismograms(1,irec_local,it-nit_written) = sngl(eps_loc_new(1,1))
        seismograms(2,irec_local,it-nit_written) = sngl(eps_loc_new(2,2))
        seismograms(3,irec_local,it-nit_written) = sngl(eps_loc_new(3,3))
        seismograms(4,irec_local,it-nit_written) = sngl(eps_loc_new(1,2))
        seismograms(5,irec_local,it-nit_written) = sngl(eps_loc_new(1,3))
        seismograms(6,irec_local,it-nit_written) = sngl(eps_loc_new(2,3))
        seismograms(7:9,irec_local,it-nit_written) = sngl(scale_displ*(nu_source(:,1,irec)*uxd + &
                    nu_source(:,2,irec)*uyd + nu_source(:,3,irec)*uzd))
     else
        seismograms(1,irec_local,it-nit_written) = eps_loc_new(1,1)
        seismograms(2,irec_local,it-nit_written) = eps_loc_new(2,2)
        seismograms(3,irec_local,it-nit_written) = eps_loc_new(3,3)
        seismograms(4,irec_local,it-nit_written) = eps_loc_new(1,2)
        seismograms(5,irec_local,it-nit_written) = eps_loc_new(1,3)
        seismograms(6,irec_local,it-nit_written) = eps_loc_new(2,3)
        seismograms(7:9,irec_local,it-nit_written) = scale_displ*(nu_source(:,1,irec)*uxd + &
                    nu_source(:,2,irec)*uyd + nu_source(:,3,irec)*uzd)
      endif

    else  if (SIMULATION_TYPE == 3) then

      do k = 1,NGLLZ
        do j = 1,NGLLY
          do i = 1,NGLLX

            iglob = ibool_crust_mantle(i,j,k,ispec_selected_rec(irec))

            hlagrange = hxir_store(irec_local,i)*hetar_store(irec_local,j)*hgammar_store(irec_local,k)

            uxd = uxd + dble(b_displ_crust_mantle(1,iglob))*hlagrange
            uyd = uyd + dble(b_displ_crust_mantle(2,iglob))*hlagrange
            uzd = uzd + dble(b_displ_crust_mantle(3,iglob))*hlagrange

          enddo
        enddo
        enddo
! store North, East and Vertical components

! distinguish between single and double precision for reals
        if(CUSTOM_REAL == SIZE_REAL) then
          seismograms(:,irec_local,it) = sngl(scale_displ*(nu(:,1,irec)*uxd + &
             nu(:,2,irec)*uyd + nu(:,3,irec)*uzd))
        else
          seismograms(:,irec_local,it) = scale_displ*(nu(:,1,irec)*uxd + &
             nu(:,2,irec)*uyd + nu(:,3,irec)*uzd)
        endif

      endif

    enddo

! write the current seismograms
  if(mod(it,NTSTEP_BETWEEN_OUTPUT_SEISMOS) == 0) then
    if (SIMULATION_TYPE == 1 .or. SIMULATION_TYPE == 3) then
      if(.not. RUN_ON_MARENOSTRUM_BARCELONA) &
        call write_seismograms(myrank,seismograms,number_receiver_global,station_name, &
          network_name,stlat,stlon,stele,nrec,nrec_local,DT,NSTEP,t0,LOCAL_PATH,it_begin,it_end, &
      yr_SAC,jda_SAC,ho_SAC,mi_SAC,sec_SAC,t_cmt_SAC, &
                 elat_SAC,elon_SAC,depth_SAC,mb_SAC,ename_SAC,cmt_lat_SAC,cmt_lon_SAC,cmt_depth_SAC,cmt_hdur_SAC,NSOURCES_SAC)
    else
      call write_adj_seismograms(seismograms,number_receiver_global, &
        nrec_local,it,nit_written,DT,NSTEP,NTSTEP_BETWEEN_OUTPUT_SEISMOS,t0,LOCAL_PATH)
        nit_written = it
    endif
  endif
  endif ! nrec_local


! kernel calculations
  if (SIMULATION_TYPE == 3) then

! crust_mantle
    do ispec = 1, nspec_crust_mantle
      do k = 1, NGLLZ
        do j = 1, NGLLY
          do i = 1, NGLLX
            iglob = ibool_crust_mantle(i,j,k,ispec)

            rho_kl_crust_mantle(i,j,k,ispec) =  rho_kl_crust_mantle(i,j,k,ispec) &
               + deltat * (accel_crust_mantle(1,iglob) * b_displ_crust_mantle(1,iglob) &
               + accel_crust_mantle(2,iglob) * b_displ_crust_mantle(2,iglob) &
               + accel_crust_mantle(3,iglob) * b_displ_crust_mantle(3,iglob) )

            epsilondev_loc(:) = epsilondev_crust_mantle(:,i,j,k,ispec)
            b_epsilondev_loc(:) = b_epsilondev_crust_mantle(:,i,j,k,ispec)
            beta_kl_crust_mantle(i,j,k,ispec) =  beta_kl_crust_mantle(i,j,k,ispec) &
               + deltat * (epsilondev_loc(1)*b_epsilondev_loc(1) + epsilondev_loc(2)*b_epsilondev_loc(2) &
               + (epsilondev_loc(1)+epsilondev_loc(2)) * (b_epsilondev_loc(1)+b_epsilondev_loc(2)) &
                + 2 * (epsilondev_loc(3)*b_epsilondev_loc(3) + epsilondev_loc(4)*b_epsilondev_loc(4) + &
                epsilondev_loc(5)*b_epsilondev_loc(5)) )

            alpha_kl_crust_mantle(i,j,k,ispec) = alpha_kl_crust_mantle(i,j,k,ispec) &
               + deltat * (9 * eps_trace_over_3_crust_mantle(i,j,k,ispec) * b_eps_trace_over_3_crust_mantle(i,j,k,ispec))
          enddo
        enddo
      enddo
    enddo

! outer_core
    do ispec = 1, nspec_outer_core
      do k = 1, NGLLZ
        do j = 1, NGLLY
          do i = 1, NGLLX
            iglob = ibool_outer_core(i,j,k,ispec)

            xixl = xix_outer_core(i,j,k,ispec)
            xiyl = xiy_outer_core(i,j,k,ispec)
            xizl = xiz_outer_core(i,j,k,ispec)
            etaxl = etax_outer_core(i,j,k,ispec)
            etayl = etay_outer_core(i,j,k,ispec)
            etazl = etaz_outer_core(i,j,k,ispec)
            gammaxl = gammax_outer_core(i,j,k,ispec)
            gammayl = gammay_outer_core(i,j,k,ispec)
            gammazl = gammaz_outer_core(i,j,k,ispec)

            tempx1l = 0._CUSTOM_REAL
            tempx2l = 0._CUSTOM_REAL
            tempx3l = 0._CUSTOM_REAL

            do l=1,NGLLX
              tempx1l = tempx1l + b_displ_outer_core(ibool_outer_core(l,j,k,ispec)) * hprime_xx(l,i)
            enddo

            do l=1,NGLLY
              tempx2l = tempx2l + b_displ_outer_core(ibool_outer_core(i,l,k,ispec)) * hprime_yy(l,j)
            enddo

            do l=1,NGLLZ
              tempx3l = tempx3l +  b_displ_outer_core(ibool_outer_core(i,j,l,ispec)) * hprime_zz(l,k)
            enddo

            b_vector_displ_outer_core(1) = xixl*tempx1l + etaxl*tempx2l + gammaxl*tempx3l
            b_vector_displ_outer_core(2) = xiyl*tempx1l + etayl*tempx2l + gammayl*tempx3l
            b_vector_displ_outer_core(3) = xizl*tempx1l + etazl*tempx2l + gammazl*tempx3l

            tempx1l = 0._CUSTOM_REAL
            tempx2l = 0._CUSTOM_REAL
            tempx3l = 0._CUSTOM_REAL

            do l=1,NGLLX
              tempx1l = tempx1l + accel_outer_core(ibool_outer_core(l,j,k,ispec)) * hprime_xx(l,i)
            enddo

            do l=1,NGLLY
              tempx2l = tempx2l + accel_outer_core(ibool_outer_core(i,l,k,ispec)) * hprime_yy(l,j)
            enddo

            do l=1,NGLLZ
              tempx3l = tempx3l + accel_outer_core(ibool_outer_core(i,j,l,ispec)) * hprime_zz(l,k)
            enddo

            vector_accel_outer_core(1) = xixl*tempx1l + etaxl*tempx2l + gammaxl*tempx3l
            vector_accel_outer_core(2) = xiyl*tempx1l + etayl*tempx2l + gammayl*tempx3l
            vector_accel_outer_core(3) = xizl*tempx1l + etazl*tempx2l + gammazl*tempx3l

            rho_kl_outer_core(i,j,k,ispec) = rho_kl_outer_core(i,j,k,ispec) &
               + deltat * (vector_accel_outer_core(1) * b_vector_displ_outer_core(1) &
               + vector_accel_outer_core(2) * b_vector_displ_outer_core(2) &
               + vector_accel_outer_core(3) * b_vector_displ_outer_core(3) )

            kappal = rhostore_outer_core(i,j,k,ispec)/kappavstore_outer_core(i,j,k,ispec)
            div_displ_outer_core(i,j,k,ispec) = div_displ_outer_core(i,j,k,ispec) + kappal * accel_outer_core(iglob)
            b_div_displ_outer_core(i,j,k,ispec) = b_div_displ_outer_core(i,j,k,ispec) + kappal * b_accel_outer_core(iglob)

            alpha_kl_outer_core(i,j,k,ispec) = alpha_kl_outer_core(i,j,k,ispec) &
               + deltat * div_displ_outer_core(i,j,k,ispec) * b_div_displ_outer_core(i,j,k,ispec)

          enddo
        enddo
      enddo
    enddo

! inner_core
    do ispec = 1, nspec_inner_core
      do k = 1, NGLLZ
        do j = 1, NGLLY
          do i = 1, NGLLX
            iglob = ibool_inner_core(i,j,k,ispec)

            rho_kl_inner_core(i,j,k,ispec) =  rho_kl_inner_core(i,j,k,ispec) &
               + deltat * (accel_inner_core(1,iglob) * b_displ_inner_core(1,iglob) &
               + accel_inner_core(2,iglob) * b_displ_inner_core(2,iglob) &
               + accel_inner_core(3,iglob) * b_displ_inner_core(3,iglob) )

            epsilondev_loc(:) = epsilondev_inner_core(:,i,j,k,ispec)
            b_epsilondev_loc(:) = b_epsilondev_inner_core(:,i,j,k,ispec)
            beta_kl_inner_core(i,j,k,ispec) =  beta_kl_inner_core(i,j,k,ispec) &
               + deltat * (epsilondev_loc(1)*b_epsilondev_loc(1) + epsilondev_loc(2)*b_epsilondev_loc(2) &
                  + (epsilondev_loc(1)+epsilondev_loc(2)) * (b_epsilondev_loc(1)+b_epsilondev_loc(2)) &
                  + 2 * (epsilondev_loc(3)*b_epsilondev_loc(3) + epsilondev_loc(4)*b_epsilondev_loc(4) &
                  + epsilondev_loc(5)*b_epsilondev_loc(5)) )

            alpha_kl_inner_core(i,j,k,ispec) = alpha_kl_inner_core(i,j,k,ispec) &
               + deltat * (9 * eps_trace_over_3_inner_core(i,j,k,ispec) * b_eps_trace_over_3_inner_core(i,j,k,ispec))
          enddo
        enddo
      enddo
    enddo

  endif


! save movie on surface
  if(MOVIE_SURFACE .and. mod(it,NTSTEP_BETWEEN_FRAMES) == 0) then

! save velocity here to avoid static offset on displacement for movies

! get coordinates of surface mesh and surface displacement
    ipoin = 0
    do ispec2D = 1,NSPEC2D_TOP(IREGION_CRUST_MANTLE)
      ispec = ibelm_top_crust_mantle(ispec2D)
      k = NGLLZ

! loop on all the points inside the element
      do j = 1,NGLLY
        do i = 1,NGLLX
          ipoin = ipoin + 1
          iglob = ibool_crust_mantle(i,j,k,ispec)
          store_val_x(ipoin) = xstore_crust_mantle(iglob)
          store_val_y(ipoin) = ystore_crust_mantle(iglob)
          store_val_z(ipoin) = zstore_crust_mantle(iglob)
          store_val_ux(ipoin) = veloc_crust_mantle(1,iglob)*scale_veloc
          store_val_uy(ipoin) = veloc_crust_mantle(2,iglob)*scale_veloc
          store_val_uz(ipoin) = veloc_crust_mantle(3,iglob)*scale_veloc
        enddo
      enddo

    enddo

! gather info on master proc
    ispec = nmovie_points
    call MPI_GATHER(store_val_x,ispec,CUSTOM_MPI_TYPE,store_val_x_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_y,ispec,CUSTOM_MPI_TYPE,store_val_y_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_z,ispec,CUSTOM_MPI_TYPE,store_val_z_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_ux,ispec,CUSTOM_MPI_TYPE,store_val_ux_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_uy,ispec,CUSTOM_MPI_TYPE,store_val_uy_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_uz,ispec,CUSTOM_MPI_TYPE,store_val_uz_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)

! save movie data to disk in home directory
    if(myrank == 0) then
      write(outputname,"('/moviedata',i6.6)") it
      open(unit=IOUT,file=trim(OUTPUT_FILES)//outputname,status='unknown',form='unformatted')
      write(IOUT) store_val_x_all
      write(IOUT) store_val_y_all
      write(IOUT) store_val_z_all
      write(IOUT) store_val_ux_all
      write(IOUT) store_val_uy_all
      write(IOUT) store_val_uz_all
      close(IOUT)
    endif

  endif

! save movie in full 3D mesh
  if(MOVIE_VOLUME .and. mod(it,NTSTEP_BETWEEN_FRAMES) == 0) then

! div
    write(outputname,"('proc',i6.6,'_crust_mantle_div_displ_it',i6.6,'.bin')") myrank,it
    open(unit=27,file=trim(LOCAL_PATH)//trim(outputname),status='unknown',form='unformatted')
    write(27) eps_trace_over_3_crust_mantle
    close(27)

    write(outputname,"('proc',i6.6,'_outer_core_div_displ_it',i6.6,'.bin')") myrank,it
    open(unit=27,file=trim(LOCAL_PATH)//trim(outputname),status='unknown',form='unformatted')
    write(27)  ONE_THIRD * div_displ_outer_core
    close(27)

    write(outputname,"('proc',i6.6,'_inner_core_div_displ_proc_it',i6.6,'.bin')") myrank,it
    open(unit=27,file=trim(LOCAL_PATH)//trim(outputname),status='unknown',form='unformatted')
    write(27) eps_trace_over_3_inner_core
    close(27)

! epsilondev

    write(outputname,"('proc',i6.6,'_crust_mantle_epsdev_displ_it',i6.6,'.bin')") myrank,it
    open(unit=27,file=trim(LOCAL_PATH)//trim(outputname),status='unknown',form='unformatted')
    write(27) epsilondev_crust_mantle
    close(27)

    write(outputname,"('proc',i6.6,'inner_core_epsdev_displ_it',i6.6,'.bin')") myrank,it
    open(unit=27,file=trim(LOCAL_PATH)//trim(outputname),status='unknown',form='unformatted')
    write(27) epsilondev_inner_core
    close(27)

  endif

!---- end of time iteration loop
!
  enddo   ! end of main time loop

! write the final seismograms

  if (nrec_local > 0) then
    if (SIMULATION_TYPE == 1 .or. SIMULATION_TYPE == 3) then
      if(.not. RUN_ON_MARENOSTRUM_BARCELONA) &
        call write_seismograms(myrank,seismograms,number_receiver_global,station_name, &
        network_name,stlat,stlon,stele,nrec,nrec_local,DT,NSTEP,t0,LOCAL_PATH,it_begin,it_end, &
      yr_SAC,jda_SAC,ho_SAC,mi_SAC,sec_SAC,t_cmt_SAC, &
                 elat_SAC,elon_SAC,depth_SAC,mb_SAC,ename_SAC,cmt_lat_SAC,cmt_lon_SAC,cmt_depth_SAC,cmt_hdur_SAC,NSOURCES_SAC)
    else
      call write_adj_seismograms(seismograms,number_receiver_global, &
        nrec_local,it,nit_written,DT,NSTEP,NTSTEP_BETWEEN_OUTPUT_SEISMOS,t0,LOCAL_PATH)
    endif
  endif

! save files to local disk or MT tape system if restart file
  if(NUMBER_OF_RUNS > 1 .and. NUMBER_OF_THIS_RUN < NUMBER_OF_RUNS) then
    write(outputname,"('dump_all_arrays',i6.6)") myrank
    open(unit=55,file=trim(LOCAL_PATH)//'/'//outputname,status='unknown',form='unformatted')
    write(55) displ_crust_mantle
    write(55) veloc_crust_mantle
    write(55) accel_crust_mantle
    write(55) displ_inner_core
    write(55) veloc_inner_core
    write(55) accel_inner_core
    write(55) displ_outer_core
    write(55) veloc_outer_core
    write(55) accel_outer_core
    write(55) R_memory_crust_mantle
    write(55) R_memory_inner_core
    write(55) epsilondev_crust_mantle
    write(55) epsilondev_inner_core
    write(55) A_array_rotation
    write(55) B_array_rotation
    close(55)
  endif

! save last frame of the forward simulation
  if (SIMULATION_TYPE == 1 .and. SAVE_FORWARD) then
    write(outputname,'(a,i6.6,a)') 'proc',myrank,'_save_forward_arrays.bin'
    open(unit=55,file=trim(LOCAL_PATH)//'/'//outputname,status='unknown',form='unformatted')
    write(55) displ_crust_mantle
    write(55) veloc_crust_mantle
    write(55) accel_crust_mantle
    write(55) displ_inner_core
    write(55) veloc_inner_core
    write(55) accel_inner_core
    write(55) displ_outer_core
    write(55) veloc_outer_core
    write(55) accel_outer_core
    if (ATTENUATION_VAL) then
      write(55) R_memory_crust_mantle
      write(55) R_memory_inner_core
    endif
    write(55) epsilondev_crust_mantle
    write(55) epsilondev_inner_core
    if (ROTATION) then
      write(55) A_array_rotation
      write(55) B_array_rotation
    endif
    close(55)
  endif

! dump kernel arrays
  if (SIMULATION_TYPE == 3) then
    scale_kl = scale_t/scale_displ * 1.d9
! crust_mantle
    do ispec = 1, nspec_crust_mantle
      do k = 1, NGLLZ
        do j = 1, NGLLY
          do i = 1, NGLLX
            rhol = rhostore_crust_mantle(i,j,k,ispec)
            mul = muvstore_crust_mantle(i,j,k,ispec)
            kappal = kappavstore_crust_mantle(i,j,k,ispec)
            rho_kl = - rhol * rho_kl_crust_mantle(i,j,k,ispec)
            alpha_kl = - kappal * alpha_kl_crust_mantle(i,j,k,ispec)
            beta_kl =  - 2 * mul * beta_kl_crust_mantle(i,j,k,ispec)
            rho_kl_crust_mantle(i,j,k,ispec) = (rho_kl + alpha_kl + beta_kl) * scale_kl
            beta_kl_crust_mantle(i,j,k,ispec) = 2 * (beta_kl - FOUR_THIRDS * mul * alpha_kl / kappal) * scale_kl
            alpha_kl_crust_mantle(i,j,k,ispec) = 2 * (1 +  FOUR_THIRDS * mul / kappal) * alpha_kl * scale_kl
          enddo
        enddo
      enddo
    enddo

    call create_name_database(prname,myrank,IREGION_CRUST_MANTLE,LOCAL_PATH)
    open(unit=27,file=trim(prname)//'rho_kernel.bin',status='unknown',form='unformatted')
    write(27) rho_kl_crust_mantle
    close(27)
    open(unit=27,file=trim(prname)//'alpha_kernel.bin',status='unknown',form='unformatted')
    write(27) alpha_kl_crust_mantle
    close(27)
    open(unit=27,file=trim(prname)//'beta_kernel.bin',status='unknown',form='unformatted')
    write(27) beta_kl_crust_mantle
    close(27)

! outer_core
    do ispec = 1, nspec_outer_core
      do k = 1, NGLLZ
        do j = 1, NGLLY
          do i = 1, NGLLX
            rhol = rhostore_outer_core(i,j,k,ispec)
            kappal = kappavstore_outer_core(i,j,k,ispec)
            rho_kl = - rhol * rho_kl_outer_core(i,j,k,ispec)
            alpha_kl = - kappal * alpha_kl_outer_core(i,j,k,ispec)
            rho_kl_outer_core(i,j,k,ispec) = (rho_kl + alpha_kl) * scale_kl
            alpha_kl_outer_core(i,j,k,ispec) = 2 * alpha_kl * scale_kl
          enddo
        enddo
      enddo
    enddo

    call create_name_database(prname,myrank,IREGION_OUTER_CORE,LOCAL_PATH)
    open(unit=27,file=trim(prname)//'rho_kernel.bin',status='unknown',form='unformatted')
    write(27) rho_kl_outer_core
    close(27)
    open(unit=27,file=trim(prname)//'alpha_kernel.bin',status='unknown',form='unformatted')
    write(27) alpha_kl_outer_core
    close(27)

! inner_core
   do ispec = 1, nspec_inner_core
      do k = 1, NGLLZ
        do j = 1, NGLLY
          do i = 1, NGLLX
            rhol = rhostore_inner_core(i,j,k,ispec)
            mul = muvstore_inner_core(i,j,k,ispec)
            kappal = kappavstore_inner_core(i,j,k,ispec)
            rho_kl = -rhol * rho_kl_inner_core(i,j,k,ispec)
            alpha_kl = -kappal * alpha_kl_inner_core(i,j,k,ispec)
            beta_kl =  - 2 * mul * beta_kl_inner_core(i,j,k,ispec)
            rho_kl_inner_core(i,j,k,ispec) = (rho_kl + alpha_kl + beta_kl) * scale_kl
            beta_kl_inner_core(i,j,k,ispec) = 2 * (beta_kl - FOUR_THIRDS * mul * alpha_kl / kappal) * scale_kl
            alpha_kl_inner_core(i,j,k,ispec) = 2 * (1 +  FOUR_THIRDS * mul / kappal) * alpha_kl * scale_kl
          enddo
        enddo
      enddo
    enddo

    call create_name_database(prname,myrank,IREGION_INNER_CORE,LOCAL_PATH)
    open(unit=27,file=trim(prname)//'rho_kernel.bin',status='unknown',form='unformatted')
    write(27) rho_kl_inner_core
    close(27)
    open(unit=27,file=trim(prname)//'alpha_kernel.bin',status='unknown',form='unformatted')
    write(27) alpha_kl_inner_core
    close(27)
    open(unit=27,file=trim(prname)//'beta_kernel.bin',status='unknown',form='unformatted')
    write(27) beta_kl_inner_core
    close(27)

  endif

!! DK DK UGLY if running on MareNostrum in Barcelona, gather all
!! DK DK UGLY the seismograms on the master to write them to GPFS
  if(RUN_ON_MARENOSTRUM_BARCELONA) then

    if(myrank == 0) then ! on the master, gather all the seismograms

! get the job ID from file output by LoadLeveler script
      open(unit=27,file=trim(OUTPUT_FILES)//'/jobid',status='old',action='read')
      read(27,*) jobid
      close(27)

! open a file on the GPFS file system
    write(system_command,"('/gpfs/scratch/hpce07/hpce07084/seismograms_BSC/all_seismos_jobid_',i7.7,'.bin')") jobid
    open(unit=133,file=system_command,status='replace',action='write',form='unformatted')

    total_seismos_marenostrum = 0

! receive information from all the slices
    do iproc = 0,NPROCTOT-1

! receive except from proc 0, which is me and therefore I already have this value
      sender = iproc
      if(iproc /= 0) call MPI_RECV(nrec_local,1,MPI_INTEGER,sender,itag,MPI_COMM_WORLD,msg_status,ier)

      if (nrec_local > 0) then

        do irec_local = 1,nrec_local

! receive except from proc 0, which is myself and therefore I already have these values
          if(iproc == 0) then
! get global number of that receiver
            irec = number_receiver_global(irec_local)
            one_seismogram_marenostrum(:,:) = seismograms(:,irec_local,:)
          else
            call MPI_RECV(irec,1,MPI_INTEGER,sender,itag,MPI_COMM_WORLD,msg_status,ier)
            call MPI_RECV(one_seismogram_marenostrum,NDIM*NSTEP,CUSTOM_MPI_TYPE,sender,itag,MPI_COMM_WORLD,msg_status,ier)
          endif

          total_seismos_marenostrum = total_seismos_marenostrum + 1
          write(133) irec
          write(133) one_seismogram_marenostrum

        enddo

      endif

    enddo

    close(133)

    write(IMAIN,*)
    write(IMAIN,*) 'Total number of receivers saved to GPFS is ',total_seismos_marenostrum,' out of ',nrec
    write(IMAIN,*)
    if(total_seismos_marenostrum /= nrec) call exit_MPI(myrank, 'incorrect total number of receivers saved to GPFS')

  else  ! on the nodes, send the seismograms to the master

    receiver = 0

    call MPI_SEND(nrec_local,1,MPI_INTEGER,receiver,itag,MPI_COMM_WORLD,ier)

    if (nrec_local > 0) then

      do irec_local = 1,nrec_local

! get global number of that receiver
        irec = number_receiver_global(irec_local)
        call MPI_SEND(irec,1,MPI_INTEGER,receiver,itag,MPI_COMM_WORLD,ier)

        one_seismogram_marenostrum(:,:) = seismograms(:,irec_local,:)
        call MPI_SEND(one_seismogram_marenostrum,NDIM*NSTEP,CUSTOM_MPI_TYPE,receiver,itag,MPI_COMM_WORLD,ier)

      enddo
    endif

  endif

! remove all the files stored on the local disk
    write(system_command,"('rm -r -f /scratch/komatits_proc',i4.4)") myrank
    call system(system_command)

  endif ! of RUN_ON_MARENOSTRUM_BARCELONA

! close the main output file
  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'End of the simulation'
    write(IMAIN,*)
    close(IMAIN)
  endif

! synchronize all the processes to make sure everybody has finished
  call MPI_BARRIER(MPI_COMM_WORLD,ier)

  end subroutine specfem3D

