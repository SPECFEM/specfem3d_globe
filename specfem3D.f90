!=====================================================================
!
!          S p e c f e m 3 D  G l o b e  V e r s i o n  3 . 5
!          --------------------------------------------------
!
!                 Dimitri Komatitsch and Jeroen Tromp
!    Seismological Laboratory - California Institute of Technology
!        (c) California Institute of Technology July 2004
!
!    A signed non-commercial agreement is required to use this program.
!   Please check http://www.gps.caltech.edu/research/jtromp for details.
!           Free for non-commercial academic research ONLY.
!      This program is distributed WITHOUT ANY WARRANTY whatsoever.
!      Do not redistribute this program without written permission.
!
!=====================================================================
!
! Copyright July 2004, by the California Institute of Technology.
! ALL RIGHTS RESERVED. United States Government Sponsorship Acknowledged.
!
! Any commercial use must be negotiated with the Office of Technology
! Transfer at the California Institute of Technology. This software may be
! subject to U.S. export control laws and regulations. By accepting
! this software, the user agrees to comply with all applicable U.S. export laws
! and regulations, including the International Traffic and Arms Regulations,
! 22 C.F.R. 120-130 and the Export Administration Regulations,
! 15 C.F.R. 730-744. User has the responsibility to obtain export licenses,
! or other export authority as may be required before exporting such
! information to foreign countries or providing access to foreign nationals.
! In no event shall the California Institute of Technology be liable to any
! party for direct, indirect, special, incidental or consequential damages,
! including lost profits, arising out of the use of this software and its
! documentation, even if the California Institute of Technology has been
! advised of the possibility of such damage.
!
! The California Institute of Technology specifically disclaims any
! warranties, including the implied warranties or merchantability and fitness
! for a particular purpose. The software and documentation provided hereunder
! is on an "as is" basis, and the California Institute of Technology has no
! obligations to provide maintenance, support, updates, enhancements or
! modifications.
!

  program specfem3D

  implicit none

! standard include of the MPI library
  include 'mpif.h'

  include "constants.h"
  include "precision.h"

!=======================================================================!
!                                                                       !
!   specfem3D is a 3-D spectral-element solver for the Earth.           !
!   It uses a mesh generated by program meshfem3D                       !
!                                                                       !
!=======================================================================!
!
! If you use this code for your own research, please send an email
! to Jeroen Tromp <jtromp@caltech.edu> for information, and cite:
!
! @ARTICLE{KoRiTr02,
! author={D. Komatitsch and J. Ritsema and J. Tromp},
! year=2002,
! title={The Spectral-Element Method, {B}eowulf Computing, and Global Seismology},
! journal={Science},
! volume=298,
! pages={1737-1742}}
!
! @ARTICLE{KoTr02a,
! author={D. Komatitsch and J. Tromp},
! year=2002,
! title={Spectral-Element Simulations of Global Seismic Wave Propagation{-I. V}alidation},
! journal={Geophys. J. Int.},
! volume=149,
! pages={390-412}}
!
! @ARTICLE{KoTr02b,
! author={D. Komatitsch and J. Tromp},
! year=2002,
! title={Spectral-Element Simulations of Global Seismic Wave Propagation{-II. 3-D} Models, Oceans, Rotation, and Self-Gravitation},
! journal={Geophys. J. Int.},
! volume=150,
! pages={303-318}}
!
! @ARTICLE{KoTr99,
! author={D. Komatitsch and J. Tromp},
! year=1999,
! title={Introduction to the spectral-element method for 3-{D} seismic wave propagation},
! journal={Geophys. J. Int.},
! volume=139,
! pages={806-822}}
!
! If you use 3-D model S20RTS, please cite
!
! @ARTICLE{RiVa00,
! author={J. Ritsema and H. J. {Van Heijst}},
! year=2000,
! title={Seismic imaging of structural heterogeneity in {E}arth's mantle: Evidence for large-scale mantle flow},
! journal={Science Progress},
! volume=83,
! pages={243-259}}
!
! Reference frame - convention:
! ----------------------------
!
! The code uses the following convention for the reference frame:
!
!  - X axis is East
!  - Y axis is North
!  - Z axis is up
!
! Note that this convention is different from both the Aki-Richards convention
! and the Harvard CMT convention.
!
! Let us recall that the Aki-Richards convention is:
!
!  - X axis is North
!  - Y axis is East
!  - Z axis is down
!
! and that the Harvard CMT convention is:
!
!  - X axis is South
!  - Y axis is East
!  - Z axis is up
!
! Evolution of the code:
! ---------------------
!
! v. 3.5 Dimitri Komatitsch, Brian Savage and Jeroen Tromp, Caltech, July 2004:
!      any size of chunk, 3D attenuation, case of two chunks,
!      more precise topography/bathymetry model, new Par_file structure
! v. 3.4 Dimitri Komatitsch and Jeroen Tromp, Caltech, August 2003:
!      merged global and regional codes, no iterations in fluid, better movies
! v. 3.3 Dimitri Komatitsch, Caltech, September 2002:
!      flexible mesh doubling in outer core, inlined code, OpenDX support
! v. 3.2 Jeroen Tromp, Caltech, July 2002:
!      multiple sources and flexible PREM reading
! v. 3.1 Dimitri Komatitsch, Caltech, June 2002:
!      vectorized loops in solver and merged central cube
! v. 3.0 Dimitri Komatitsch and Jeroen Tromp, Caltech, May 2002:
!   ported to SGI and Compaq, double precision solver, more general anisotropy
! v. 2.3 Dimitri Komatitsch and Jeroen Tromp, Caltech, August 2001:
!                       gravity, rotation, oceans and 3-D models
! v. 2.2 Dimitri Komatitsch and Jeroen Tromp, Caltech, March 2001:
!                       final MPI package
! v. 2.0 Dimitri Komatitsch, Harvard, January 2000: MPI code for the globe
! v. 1.0 Dimitri Komatitsch, Mexico, June 1999: first MPI code for a chunk
! Jeroen Tromp, Harvard, July 1998: first chunk solver using OpenMP on Sun
! Dimitri Komatitsch, IPG Paris, December 1996: first 3-D solver for the CM5
!
! From Dahlen and Tromp (1998):
! ----------------------------
!
! Gravity is approximated by solving eq (3.259) without the Phi_E' term
! The ellipsoidal reference model is that of section 14.1
! The transversely isotropic expression for PREM is that of eq (8.190)
!
! the potential in the outer core is called displ_outer_core for simplicity
!

! memory variables and standard linear solids for attenuation
  double precision, dimension(N_SLS) :: tau_mu_dble,tau_sigma_dble,beta_dble
  double precision factor_scale_dble,one_minus_sum_beta_dble
  double precision, dimension(:,:,:,:), allocatable   :: omsb_crust_mantle_dble, factor_scale_crust_mantle_dble
  double precision, dimension(:,:,:,:), allocatable   :: omsb_inner_core_dble, factor_scale_inner_core_dble
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable   :: one_minus_sum_beta_crust_mantle, factor_scale_crust_mantle
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable   :: one_minus_sum_beta_inner_core, factor_scale_inner_core

  real(kind=CUSTOM_REAL) mul

  double precision, dimension(N_SLS) :: alphaval_dble, betaval_dble, gammaval_dble
  double precision, dimension(N_SLS) :: tauinv
  real(kind=CUSTOM_REAL), dimension(N_SLS) :: alphaval, betaval, gammaval
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:), allocatable :: factor_common_crust_mantle
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:), allocatable :: factor_common_inner_core
  double precision, dimension(:,:,:,:,:), allocatable :: factor_common_crust_mantle_dble
  double precision, dimension(:,:,:,:,:), allocatable :: factor_common_inner_core_dble

  integer iregion_attenuation
  double precision dist,scale_factor,scale_factor_minus_one

  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:), allocatable :: epsilondev_crust_mantle,epsilondev_inner_core
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:,:), allocatable :: R_memory_crust_mantle,R_memory_inner_core

! for matching with central cube in inner core
  integer nb_msgs_theor_in_cube
  integer receiver_cube_from_slices,iproc_xi_loop
  integer nspec2D_xmin_inner_core,nspec2D_xmax_inner_core,nspec2D_ymin_inner_core,nspec2D_ymax_inner_core
  integer ipoin,idimension
  integer npoin2D_cube_from_slices
  integer isender,ireceiver,imsg

  double precision x_target,y_target,z_target
  double precision x_current,y_current,z_current

  integer, dimension(:), allocatable :: sender_from_slices_to_cube
  integer, dimension(:,:), allocatable :: ibool_central_cube
  double precision, dimension(:,:), allocatable :: buffer_slices
  double precision, dimension(:,:,:), allocatable :: buffer_all_cube_from_slices

  real(kind=CUSTOM_REAL), dimension(:), allocatable :: array_central_cube

! to save movie frames
  real(kind=CUSTOM_REAL), dimension(:), allocatable :: &
      store_val_x,store_val_y,store_val_z, &
      store_val_ux,store_val_uy,store_val_uz
  real(kind=CUSTOM_REAL), dimension(:,:), allocatable :: &
      store_val_x_all,store_val_y_all,store_val_z_all, &
      store_val_ux_all,store_val_uy_all,store_val_uz_all

! to save full 3D snapshot of velocity
  integer itotal_spec,itotal_poin,l
  real(kind=CUSTOM_REAL) xixl,xiyl,xizl,etaxl,etayl,etazl,gammaxl,gammayl,gammazl
  real(kind=CUSTOM_REAL) tempx1l,tempx2l,tempx3l,tempy1l,tempy2l,tempy3l,tempz1l,tempz2l,tempz3l
  real(kind=CUSTOM_REAL) xcoord,ycoord,zcoord
  real(kind=CUSTOM_REAL) hp1,hp2,hp3
  real(kind=CUSTOM_REAL) div,curl_x,curl_y,curl_z
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ) :: dvxdxl,dvxdyl,dvxdzl,dvydxl,dvydyl,dvydzl,dvzdxl,dvzdyl,dvzdzl
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ) :: dpotentialdxl,dpotentialdyl,dpotentialdzl
  integer, dimension(:), allocatable :: indirect_poin
  logical, dimension(:), allocatable :: mask_poin

! use integer array to store values
  integer ibathy_topo(NX_BATHY,NY_BATHY)

! MPI status of messages to be received
  integer msg_status(MPI_STATUS_SIZE)

! for crust/oceans coupling
  integer, dimension(:), allocatable :: ibelm_xmin_crust_mantle,ibelm_xmax_crust_mantle, &
    ibelm_ymin_crust_mantle,ibelm_ymax_crust_mantle,ibelm_bottom_crust_mantle,ibelm_top_crust_mantle

  logical, dimension(:), allocatable :: updated_dof_ocean_load

  real(kind=CUSTOM_REAL), dimension(:,:,:), allocatable :: jacobian2D_bottom_crust_mantle,jacobian2D_top_crust_mantle, &
    jacobian2D_xmin_crust_mantle,jacobian2D_xmax_crust_mantle, &
    jacobian2D_ymin_crust_mantle,jacobian2D_ymax_crust_mantle
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: normal_xmin_crust_mantle, &
    normal_xmax_crust_mantle,normal_ymin_crust_mantle,normal_ymax_crust_mantle, &
    normal_bottom_crust_mantle,normal_top_crust_mantle

! Stacey
  real(kind=CUSTOM_REAL) sn,tx,ty,tz

  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: rho_vp_crust_mantle,rho_vs_crust_mantle

  integer nspec2D_xmin_crust_mantle,nspec2D_xmax_crust_mantle,nspec2D_ymin_crust_mantle,nspec2D_ymax_crust_mantle
  integer, dimension(:,:), allocatable :: nimin_crust_mantle, &
    nimax_crust_mantle,njmin_crust_mantle,njmax_crust_mantle, &
    nkmin_xi_crust_mantle,nkmin_eta_crust_mantle

  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: vp_outer_core

  integer nspec2D_xmin_outer_core,nspec2D_xmax_outer_core,nspec2D_ymin_outer_core,nspec2D_ymax_outer_core
  integer, dimension(:,:), allocatable :: nimin_outer_core, &
    nimax_outer_core,njmin_outer_core,njmax_outer_core, &
    nkmin_xi_outer_core,nkmin_eta_outer_core

! arrays to couple with the fluid regions by pointwise matching
  integer, dimension(:), allocatable :: ibelm_xmin_outer_core, &
    ibelm_xmax_outer_core,ibelm_ymin_outer_core,ibelm_ymax_outer_core, &
    ibelm_bottom_outer_core,ibelm_top_outer_core
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: normal_xmin_outer_core, &
    normal_xmax_outer_core,normal_ymin_outer_core,normal_ymax_outer_core, &
    normal_bottom_outer_core,normal_top_outer_core
  real(kind=CUSTOM_REAL), dimension(:,:,:), allocatable :: jacobian2D_bottom_outer_core,jacobian2D_top_outer_core, &
    jacobian2D_xmin_outer_core,jacobian2D_xmax_outer_core, &
    jacobian2D_ymin_outer_core,jacobian2D_ymax_outer_core

  integer, dimension(:), allocatable :: ibelm_xmin_inner_core, &
    ibelm_xmax_inner_core,ibelm_ymin_inner_core,ibelm_ymax_inner_core, &
    ibelm_bottom_inner_core,ibelm_top_inner_core

! for matching between fluid and solid regions
  integer ispec2D,k_corresp,ispec_selected
  real(kind=CUSTOM_REAL) vx,vy,vz,nx,ny,nz,vn,weight,pressure

! for ellipticity
  integer nspl
  double precision rspl(NR),espl(NR),espl2(NR)
  double precision ell_d80_dble
  real(kind=CUSTOM_REAL) cost,p20,theta,ell_d80

! for conversion from x y z to r theta phi
  real(kind=CUSTOM_REAL) rval,thetaval,phival

! ---- arrays to assemble between chunks

! communication pattern for faces between chunks
  integer, dimension(:), allocatable :: iprocfrom_faces,iprocto_faces,imsg_type

! communication pattern for corners between chunks
  integer, dimension(:), allocatable :: iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners

! indirect addressing for each message for faces and corners of the chunks
! a given slice can belong to at most one corner and at most two faces
  integer NPOIN2DMAX_XY
  integer, dimension(:,:), allocatable :: iboolfaces_crust_mantle
  integer, dimension(:,:), allocatable :: iboolfaces_outer_core
  integer, dimension(:,:), allocatable :: iboolfaces_inner_core

! buffers for send and receive between faces of the slices and the chunks
  real(kind=CUSTOM_REAL), dimension(:), allocatable :: buffer_send_faces_scalar,buffer_received_faces_scalar
  real(kind=CUSTOM_REAL), dimension(:,:), allocatable :: buffer_send_faces_vector,buffer_received_faces_vector

! PvK: Flag indicating whether topology and coordinates need to be output
! for first movie file only
  logical ifirst_movie
  integer IOUT_COORD,IOUT_TOPOLOGY

! -------- arrays specific to each region here -----------

! ----------------- crust, mantle and oceans ---------------------

! mesh parameters
  integer, dimension(:,:,:,:), allocatable :: ibool_crust_mantle

  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: &
        xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle,&
        etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
        gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,jacobian_crust_mantle

  real(kind=CUSTOM_REAL), dimension(:), allocatable :: &
        xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle

! arrays for isotropic elements stored only where needed to save space
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: &
        kappavstore_crust_mantle,muvstore_crust_mantle

! arrays for anisotropic elements stored only where needed to save space
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: &
        kappahstore_crust_mantle,muhstore_crust_mantle,eta_anisostore_crust_mantle

! arrays for full anisotropy only when needed
  integer nspec_iso,nspec_tiso,nspec_ani
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: &
        c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle, &
        c14store_crust_mantle,c15store_crust_mantle,c16store_crust_mantle, &
        c22store_crust_mantle,c23store_crust_mantle,c24store_crust_mantle, &
        c25store_crust_mantle,c26store_crust_mantle,c33store_crust_mantle, &
        c34store_crust_mantle,c35store_crust_mantle,c36store_crust_mantle, &
        c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
        c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle

! local to global mapping
  integer, dimension(:), allocatable :: idoubling_crust_mantle

! mass matrix
  real(kind=CUSTOM_REAL), dimension(:), allocatable :: rmass_crust_mantle

! displacement, velocity, acceleration
  real(kind=CUSTOM_REAL), dimension(:,:), allocatable :: &
     displ_crust_mantle,veloc_crust_mantle,accel_crust_mantle

! additional mass matrix for ocean load
! ocean load mass matrix is always allocated even if no oceans
  real(kind=CUSTOM_REAL), dimension(:), allocatable :: rmass_ocean_load
  real(kind=CUSTOM_REAL) additional_term,force_normal_comp

! ----------------- outer core ---------------------

! mesh parameters
  integer, dimension(:,:,:,:), allocatable :: ibool_outer_core

  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: &
        xix_outer_core,xiy_outer_core,xiz_outer_core,&
        etax_outer_core,etay_outer_core,etaz_outer_core, &
        gammax_outer_core,gammay_outer_core,gammaz_outer_core,jacobian_outer_core

  real(kind=CUSTOM_REAL), dimension(:), allocatable :: &
        xstore_outer_core,ystore_outer_core,zstore_outer_core

! local to global mapping
  integer, dimension(:), allocatable :: idoubling_outer_core

! mass matrix
  real(kind=CUSTOM_REAL), dimension(:), allocatable :: rmass_outer_core

! velocity potential
  real(kind=CUSTOM_REAL), dimension(:), allocatable :: displ_outer_core,veloc_outer_core,accel_outer_core

! ----------------- inner core ---------------------

! mesh parameters
  integer, dimension(:,:,:,:), allocatable :: ibool_inner_core

  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: &
        xix_inner_core,xiy_inner_core,xiz_inner_core,&
        etax_inner_core,etay_inner_core,etaz_inner_core, &
        gammax_inner_core,gammay_inner_core,gammaz_inner_core,jacobian_inner_core, &
        kappavstore_inner_core,muvstore_inner_core

  real(kind=CUSTOM_REAL), dimension(:), allocatable :: xstore_inner_core,ystore_inner_core,zstore_inner_core

! arrays for inner-core anisotropy only when needed
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: &
        c11store_inner_core,c33store_inner_core,c12store_inner_core,c13store_inner_core,c44store_inner_core

! local to global mapping
  integer, dimension(:), allocatable :: idoubling_inner_core

! mass matrix
  real(kind=CUSTOM_REAL), dimension(:), allocatable :: rmass_inner_core

! displacement, velocity, acceleration
  real(kind=CUSTOM_REAL), dimension(:,:), allocatable :: displ_inner_core,veloc_inner_core,accel_inner_core

! --------

  integer npoin2D_faces_crust_mantle(NUMFACES_SHARED)
  integer npoin2D_faces_outer_core(NUMFACES_SHARED)
  integer npoin2D_faces_inner_core(NUMFACES_SHARED)

! parameters for the source
  integer it,isource
  integer, dimension(:), allocatable :: islice_selected_source,ispec_selected_source
  integer yr,jda,ho,mi
  real(kind=CUSTOM_REAL) stf_used
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: sourcearray
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:), allocatable :: sourcearrays
  double precision sec,stf
  double precision, dimension(:), allocatable :: Mxx,Myy,Mzz,Mxy,Mxz,Myz
  double precision, dimension(:), allocatable :: xi_source,eta_source,gamma_source
  double precision, dimension(:), allocatable :: t_cmt,hdur,hdur_gaussian
  double precision, dimension(:), allocatable :: theta_source,phi_source
  double precision, external :: comp_source_time_function
  double precision t0

! Newmark time scheme parameters and non-dimensionalization
  real(kind=CUSTOM_REAL) time,deltat,deltatover2,deltatsqover2
  double precision scale_t,scale_displ,scale_veloc

! receiver information
  integer nrec,nrec_local,nrec_tot_found
  integer irec_local
  integer, allocatable, dimension(:) :: islice_selected_rec,ispec_selected_rec,number_receiver_global
  double precision, allocatable, dimension(:) :: xi_receiver,eta_receiver,gamma_receiver
  double precision hlagrange

! timing information for the stations
  double precision, allocatable, dimension(:,:,:) :: nu
  character(len=MAX_LENGTH_STATION_NAME), allocatable, dimension(:) :: station_name
  character(len=MAX_LENGTH_NETWORK_NAME), allocatable, dimension(:) :: network_name

! seismograms
  integer it_begin,it_end
  double precision uxd,uyd,uzd
  real(kind=CUSTOM_REAL), dimension(:,:,:), allocatable :: seismograms

! non-dimensionalized rotation rate of the Earth times two
  real(kind=CUSTOM_REAL) two_omega_earth

! for the Euler scheme for rotation
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: A_array_rotation,B_array_rotation

  integer i,j,k,ispec,irec,iglob,iglob_mantle,iglob_inner_core

! number of faces between chunks
  integer NUM_FACES,NUMMSGS_FACES

! number of corners between chunks
  integer NCORNERSCHUNKS

! number of message types
  integer NUM_MSG_TYPES

! indirect addressing for each corner of the chunks
  integer, dimension(:,:), allocatable :: iboolcorner_crust_mantle,iboolcorner_outer_core,iboolcorner_inner_core

! buffers for send and receive between corners of the chunks
  real(kind=CUSTOM_REAL), dimension(:), allocatable :: buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar
  real(kind=CUSTOM_REAL), dimension(:,:), allocatable :: buffer_send_chunkcorners_vector,buffer_recv_chunkcorners_vector

! Gauss-Lobatto-Legendre points of integration and weights
  double precision, dimension(NGLLX) :: xigll,wxgll
  double precision, dimension(NGLLY) :: yigll,wygll
  double precision, dimension(NGLLZ) :: zigll,wzgll

! product of weights for gravity term
  double precision, dimension(NGLLX,NGLLY,NGLLZ) :: wgll_cube

! array with derivatives of Lagrange polynomials and precalculated products
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLX) :: hprime_xx,hprimewgll_xx
  real(kind=CUSTOM_REAL), dimension(NGLLY,NGLLY) :: hprime_yy,hprimewgll_yy
  real(kind=CUSTOM_REAL), dimension(NGLLZ,NGLLZ) :: hprime_zz,hprimewgll_zz
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY) :: wgllwgll_xy
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLZ) :: wgllwgll_xz
  real(kind=CUSTOM_REAL), dimension(NGLLY,NGLLZ) :: wgllwgll_yz

! Lagrange interpolators at receivers
  double precision, dimension(:), allocatable :: hxir,hetar,hgammar,hpxir,hpetar,hpgammar
  double precision, dimension(:,:), allocatable :: hxir_store,hetar_store,hgammar_store

! 2-D addressing and buffers for summation between slices
  integer, dimension(:), allocatable :: iboolleft_xi_crust_mantle, &
    iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle
  integer, dimension(:), allocatable :: iboolleft_xi_outer_core, &
    iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core
  integer, dimension(:), allocatable :: iboolleft_xi_inner_core, &
    iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core

! for addressing of the slices
  integer, dimension(:,:,:), allocatable :: addressing
  integer, dimension(:), allocatable :: ichunk_slice,iproc_xi_slice,iproc_eta_slice

! proc numbers for MPI
  integer myrank,sizeprocs,ier

! number of spectral elements and total number of global points
  integer nspec_crust_mantle,nglob_crust_mantle
  integer nspec_outer_core,nglob_outer_core
  integer nspec_inner_core,nglob_inner_core

  integer npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle
  integer npoin2D_xi_outer_core,npoin2D_eta_outer_core
  integer npoin2D_xi_inner_core,npoin2D_eta_inner_core

  integer ichunk,iproc_xi,iproc_eta,iproc,iproc_read
  integer NPROC_ONE_DIRECTION

! maximum of the norm of the displacement and of the potential in the fluid
  real(kind=CUSTOM_REAL) Usolidnorm,Usolidnorm_all,Ufluidnorm,Ufluidnorm_all

! timer MPI
  integer ihours,iminutes,iseconds,int_tCPU
  double precision time_start,tCPU

! for defining size of arrays to allocate dynamically
  integer NSPECMAX_ANISO_IC,NSPECMAX_ISO_MANTLE,NSPECMAX_TISO_MANTLE,nspec_aniso_mantle
  integer NSPECMAX_ANISO_MANTLE,NSPECMAX_CRUST_MANTLE_ATTENUAT,NSPEC_INNER_CORE_ATTENUATION,NSPECMAX_OUTER_CORE_ROTATION

! parameters read from parameter file
  integer MIN_ATTENUATION_PERIOD,MAX_ATTENUATION_PERIOD,NER_CRUST, &
          NER_220_MOHO,NER_400_220,NER_600_400,NER_670_600,NER_771_670, &
          NER_TOPDDOUBLEPRIME_771,NER_CMB_TOPDDOUBLEPRIME,NER_ICB_CMB, &
          NER_TOP_CENTRAL_CUBE_ICB,NEX_XI,NEX_ETA,NER_DOUBLING_OUTER_CORE, &
          NPROC_XI,NPROC_ETA,NTSTEP_BETWEEN_OUTPUT_SEISMOS,NSTEP,NSOURCES,NTSTEP_BETWEEN_FRAMES, &
          NER_ICB_BOTTOMDBL,NER_TOPDBL_CMB,NTSTEP_BETWEEN_OUTPUT_INFO,NUMBER_OF_RUNS, &
          NUMBER_OF_THIS_RUN,NCHUNKS

  double precision DT,RATIO_BOTTOM_DBL_OC,RATIO_TOP_DBL_OC, &
          ANGULAR_WIDTH_XI_IN_DEGREES,ANGULAR_WIDTH_ETA_IN_DEGREES,CENTER_LONGITUDE_IN_DEGREES, &
          CENTER_LATITUDE_IN_DEGREES,GAMMA_ROTATION_AZIMUTH,ROCEAN,RMIDDLE_CRUST, &
          RMOHO,R80,R220,R400,R600,R670,R771,RTOPDDOUBLEPRIME,RCMB,RICB, &
          R_CENTRAL_CUBE,RHO_TOP_OC,RHO_BOTTOM_OC,RHO_OCEANS,HDUR_MOVIE

  logical TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE,ANISOTROPIC_INNER_CORE, &
          CRUSTAL,ELLIPTICITY,GRAVITY,ONE_CRUST,ROTATION,ISOTROPIC_3D_MANTLE, &
          TOPOGRAPHY,OCEANS,MOVIE_SURFACE,MOVIE_VOLUME,ATTENUATION_3D, &
          RECEIVERS_CAN_BE_BURIED,PRINT_SOURCE_TIME_FUNCTION, &
          SAVE_MESH_FILES,ATTENUATION,IASPEI, &
          ABSORBING_CONDITIONS,INCLUDE_CENTRAL_CUBE,INFLATE_CENTRAL_CUBE

  character(len=150) LOCAL_PATH,MODEL

! parameters deduced from parameters read from file
  integer NPROC,NPROCTOT,NEX_PER_PROC_XI,NEX_PER_PROC_ETA
  integer NER,NER_CMB_670,NER_670_400,NER_CENTRAL_CUBE_CMB

! this for all the regions
  integer, dimension(MAX_NUM_REGIONS) :: NSPEC_AB,NSPEC_AC,NSPEC_BC, &
               NSPEC2D_A_XI,NSPEC2D_B_XI,NSPEC2D_C_XI, &
               NSPEC2D_A_ETA,NSPEC2D_B_ETA,NSPEC2D_C_ETA, &
               NSPEC2DMAX_XMIN_XMAX,NSPEC2DMAX_YMIN_YMAX, &
               NSPEC2D_BOTTOM,NSPEC2D_TOP, &
               NSPEC1D_RADIAL,NPOIN1D_RADIAL, &
               NPOIN2DMAX_XMIN_XMAX,NPOIN2DMAX_YMIN_YMAX, &
               NGLOB_AB,NGLOB_AC,NGLOB_BC

  character(len=150) clean_LOCAL_PATH,final_LOCAL_PATH,prname

! lookup table every km for gravity
  integer int_radius,nspl_gravity,idoubling
  real(kind=CUSTOM_REAL) minus_g_cmb,minus_g_icb
  double precision radius,radius_km,g,dg,rho,vp,vs,Qkappa,Qmu
  double precision g_cmb_dble,g_icb_dble
  double precision, dimension(NRAD_GRAVITY) :: minus_gravity_table, &
    minus_deriv_gravity_table,density_table,minus_rho_g_over_kappa_fluid
  double precision rspl_gravity(NR),gspl(NR),gspl2(NR)

! flags to read kappa and mu and anisotropy arrays in regions where needed
  logical READ_KAPPA_MU,READ_TISO

! dummy value to be used instead of arrays that do not need to be read
  real(kind=CUSTOM_REAL) dummyval

! names of the data files for all the processors in MPI
  character(len=150) outputname

! ************** PROGRAM STARTS HERE **************

! initialize the MPI communicator and start the NPROCTOT MPI processes.
! sizeprocs returns number of processes started
! (should be equal to NPROCTOT if no inner core, NPROCTOT+1 if inner core).
! myrank is the rank of each process, between 0 and sizeprocs-1.
! as usual in MPI, process 0 is in charge of coordinating everything
! and also takes care of the main output
  call MPI_INIT(ier)
  call MPI_COMM_SIZE(MPI_COMM_WORLD,sizeprocs,ier)
  call MPI_COMM_RANK(MPI_COMM_WORLD,myrank,ier)

! read the parameter file
  call read_parameter_file(MIN_ATTENUATION_PERIOD,MAX_ATTENUATION_PERIOD,NER_CRUST, &
          NER_220_MOHO,NER_400_220,NER_600_400,NER_670_600,NER_771_670, &
          NER_TOPDDOUBLEPRIME_771,NER_CMB_TOPDDOUBLEPRIME,NER_ICB_CMB, &
          NER_TOP_CENTRAL_CUBE_ICB,NEX_XI,NEX_ETA,NER_DOUBLING_OUTER_CORE, &
          NPROC_XI,NPROC_ETA,NTSTEP_BETWEEN_OUTPUT_SEISMOS,NSTEP,NSOURCES,NTSTEP_BETWEEN_FRAMES, &
          NER_ICB_BOTTOMDBL,NER_TOPDBL_CMB,NTSTEP_BETWEEN_OUTPUT_INFO,NUMBER_OF_RUNS, &
          NUMBER_OF_THIS_RUN,NCHUNKS,DT,RATIO_BOTTOM_DBL_OC,RATIO_TOP_DBL_OC, &
          ANGULAR_WIDTH_XI_IN_DEGREES,ANGULAR_WIDTH_ETA_IN_DEGREES,CENTER_LONGITUDE_IN_DEGREES, &
          CENTER_LATITUDE_IN_DEGREES,GAMMA_ROTATION_AZIMUTH,ROCEAN,RMIDDLE_CRUST, &
          RMOHO,R80,R220,R400,R600,R670,R771,RTOPDDOUBLEPRIME,RCMB,RICB, &
          R_CENTRAL_CUBE,RHO_TOP_OC,RHO_BOTTOM_OC,RHO_OCEANS,HDUR_MOVIE, &
          TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE, &
          ANISOTROPIC_INNER_CORE,CRUSTAL,ELLIPTICITY,GRAVITY,ONE_CRUST, &
          ROTATION,ISOTROPIC_3D_MANTLE,TOPOGRAPHY,OCEANS,MOVIE_SURFACE, &
          MOVIE_VOLUME,ATTENUATION_3D,RECEIVERS_CAN_BE_BURIED, &
          PRINT_SOURCE_TIME_FUNCTION,SAVE_MESH_FILES, &
          ATTENUATION,IASPEI,ABSORBING_CONDITIONS, &
          INCLUDE_CENTRAL_CUBE,INFLATE_CENTRAL_CUBE,LOCAL_PATH,MODEL)

! compute other parameters based upon values read
  call compute_parameters(NER_CRUST,NER_220_MOHO,NER_400_220, &
      NER_600_400,NER_670_600,NER_771_670,NER_TOPDDOUBLEPRIME_771, &
      NER_CMB_TOPDDOUBLEPRIME,NER_ICB_CMB,NER_TOP_CENTRAL_CUBE_ICB, &
      NER,NER_CMB_670,NER_670_400,NER_CENTRAL_CUBE_CMB, &
      NEX_XI,NEX_ETA,NPROC_XI,NPROC_ETA, &
      NPROC,NPROCTOT,NEX_PER_PROC_XI,NEX_PER_PROC_ETA, &
      NSPEC_AB,NSPEC_AC,NSPEC_BC, &
      NSPEC2D_A_XI,NSPEC2D_B_XI,NSPEC2D_C_XI, &
      NSPEC2D_A_ETA,NSPEC2D_B_ETA,NSPEC2D_C_ETA, &
      NSPEC2DMAX_XMIN_XMAX,NSPEC2DMAX_YMIN_YMAX,NSPEC2D_BOTTOM,NSPEC2D_TOP, &
      NSPEC1D_RADIAL,NPOIN1D_RADIAL, &
      NPOIN2DMAX_XMIN_XMAX,NPOIN2DMAX_YMIN_YMAX, &
      NGLOB_AB,NGLOB_AC,NGLOB_BC,NER_ICB_BOTTOMDBL,NER_TOPDBL_CMB,NCHUNKS,INCLUDE_CENTRAL_CUBE)

! open main output file, only written to by process 0
  if(myrank == 0 .and. IMAIN /= ISTANDARD_OUTPUT) &
    open(unit=IMAIN,file='OUTPUT_FILES/output_solver.txt',status='unknown')

  if(myrank == 0) then

  write(IMAIN,*)
  write(IMAIN,*) '******************************'
  write(IMAIN,*) '**** Specfem3D MPI Solver ****'
  write(IMAIN,*) '******************************'
  write(IMAIN,*)
  write(IMAIN,*)

  if(FIX_UNDERFLOW_PROBLEM) write(IMAIN,*) 'Fixing slow underflow trapping problem using small initial field'

  write(IMAIN,*)
  write(IMAIN,*) 'There are ',sizeprocs,' MPI processes'
  write(IMAIN,*) 'Processes are numbered from 0 to ',sizeprocs-1
  write(IMAIN,*)

  write(IMAIN,*) 'There are ',NEX_XI,' elements along xi in each chunk'
  write(IMAIN,*) 'There are ',NEX_ETA,' elements along eta in each chunk'
  write(IMAIN,*)
  write(IMAIN,*) 'There are ',NPROC_XI,' slices along xi in each chunk'
  write(IMAIN,*) 'There are ',NPROC_ETA,' slices along eta in each chunk'
  write(IMAIN,*) 'There is a total of ',NPROC,' slices in each chunk'
  write(IMAIN,*) 'There are ',NCHUNKS,' chunks'
  write(IMAIN,*) 'There is a total of ',NPROCTOT,' slices in all the chunks'

  write(IMAIN,*)
  write(IMAIN,*) 'NDIM = ',NDIM
  write(IMAIN,*)
  write(IMAIN,*) 'NGLLX = ',NGLLX
  write(IMAIN,*) 'NGLLY = ',NGLLY
  write(IMAIN,*) 'NGLLZ = ',NGLLZ
  write(IMAIN,*)

! write information about precision used for floating-point operations
  if(CUSTOM_REAL == SIZE_REAL) then
    write(IMAIN,*) 'using single precision for the calculations'
  else
    write(IMAIN,*) 'using double precision for the calculations'
  endif
  write(IMAIN,*)
  write(IMAIN,*) 'smallest and largest possible floating-point numbers are: ',tiny(1._CUSTOM_REAL),huge(1._CUSTOM_REAL)
  write(IMAIN,*)

  endif

! check that the code is running with the requested nb of processes
  if(sizeprocs /= NPROCTOT) call exit_MPI(myrank,'wrong number of MPI processes')

! dynamic allocation of arrays

! indirect addressing for each corner of the chunks
! maximum size is found in the mantle which has the largest number of points
  allocate(iboolcorner_crust_mantle(NPOIN1D_RADIAL(IREGION_CRUST_MANTLE),NUMCORNERS_SHARED))
  allocate(iboolcorner_outer_core(NPOIN1D_RADIAL(IREGION_OUTER_CORE),NUMCORNERS_SHARED))
  allocate(iboolcorner_inner_core(NPOIN1D_RADIAL(IREGION_INNER_CORE),NUMCORNERS_SHARED))

! buffers for send and receive between corners of the chunks
  allocate(buffer_send_chunkcorners_scalar(NPOIN1D_RADIAL(IREGION_CRUST_MANTLE)))
  allocate(buffer_recv_chunkcorners_scalar(NPOIN1D_RADIAL(IREGION_CRUST_MANTLE)))

  allocate(buffer_send_chunkcorners_vector(NDIM,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE)))
  allocate(buffer_recv_chunkcorners_vector(NDIM,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE)))

! 2-D addressing and buffers for summation between slices, and point codes
! use number of elements found in the mantle since it is the largest region

! crust and mantle
  allocate(iboolleft_xi_crust_mantle(NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(iboolright_xi_crust_mantle(NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(iboolleft_eta_crust_mantle(NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(iboolright_eta_crust_mantle(NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))

! outer core
  allocate(iboolleft_xi_outer_core(NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(iboolright_xi_outer_core(NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(iboolleft_eta_outer_core(NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(iboolright_eta_outer_core(NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))

! inner core
  allocate(iboolleft_xi_inner_core(NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE)))
  allocate(iboolright_xi_inner_core(NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE)))
  allocate(iboolleft_eta_inner_core(NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE)))
  allocate(iboolright_eta_inner_core(NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE)))

! for addressing of the slices
  allocate(addressing(NCHUNKS,0:NPROC_XI-1,0:NPROC_ETA-1))
  allocate(ichunk_slice(0:NPROCTOT-1))
  allocate(iproc_xi_slice(0:NPROCTOT-1))
  allocate(iproc_eta_slice(0:NPROCTOT-1))

! open file with global slice number addressing
  open(unit=IIN,file='OUTPUT_FILES/addressing.txt',status='old')
  do iproc = 0,NPROCTOT-1
    read(IIN,*) iproc_read,ichunk,iproc_xi,iproc_eta
    if(iproc_read /= iproc) call exit_MPI(myrank,'incorrect slice number read')
    addressing(ichunk,iproc_xi,iproc_eta) = iproc
    ichunk_slice(iproc) = ichunk
    iproc_xi_slice(iproc) = iproc_xi
    iproc_eta_slice(iproc) = iproc_eta
  enddo
  close(IIN)

! determine chunk number and local slice coordinates using addressing
  ichunk = ichunk_slice(myrank)
  iproc_xi = iproc_xi_slice(myrank)
  iproc_eta = iproc_eta_slice(myrank)

! check chunk number and assign theoretical number of elements
  if(ichunk == CHUNK_AB .or. ichunk == CHUNK_AB_ANTIPODE) then
    nspec_crust_mantle = NSPEC_AB(IREGION_CRUST_MANTLE)
    nglob_crust_mantle = NGLOB_AB(IREGION_CRUST_MANTLE)
    nspec_outer_core = NSPEC_AB(IREGION_OUTER_CORE)
    nglob_outer_core = NGLOB_AB(IREGION_OUTER_CORE)
  else if(ichunk == CHUNK_AC .or. ichunk == CHUNK_AC_ANTIPODE) then
    nspec_crust_mantle = NSPEC_AC(IREGION_CRUST_MANTLE)
    nglob_crust_mantle = NGLOB_AC(IREGION_CRUST_MANTLE)
    nspec_outer_core = NSPEC_AC(IREGION_OUTER_CORE)
    nglob_outer_core = NGLOB_AC(IREGION_OUTER_CORE)
  else if(ichunk == CHUNK_BC .or. ichunk == CHUNK_BC_ANTIPODE) then
    nspec_crust_mantle = NSPEC_BC(IREGION_CRUST_MANTLE)
    nglob_crust_mantle = NGLOB_BC(IREGION_CRUST_MANTLE)
    nspec_outer_core = NSPEC_BC(IREGION_OUTER_CORE)
    nglob_outer_core = NGLOB_BC(IREGION_OUTER_CORE)
  else
    call exit_MPI(myrank,'incorrect chunk number')
  endif

  nspec_inner_core = NSPEC_AB(IREGION_INNER_CORE)
  nglob_inner_core = nglob_AB(IREGION_INNER_CORE)

  if(ANISOTROPIC_INNER_CORE) then
    NSPECMAX_ANISO_IC = NSPEC_AB(IREGION_INNER_CORE)
  else
    NSPECMAX_ANISO_IC = 1
  endif

! read number of anisotropic elements found in the mantle by the mesher from a file
  open(unit=IIN,file='OUTPUT_FILES/nspec_aniso_mantle.txt',status='old')
  read(IIN,*) nspec_aniso_mantle
  close(IIN)

  if(ANISOTROPIC_3D_MANTLE) then
    NSPECMAX_ISO_MANTLE = 1
    NSPECMAX_TISO_MANTLE = 1
    NSPECMAX_ANISO_MANTLE = nspec_crust_mantle
  else

    NSPECMAX_ISO_MANTLE = nspec_crust_mantle
    if(TRANSVERSE_ISOTROPY) then
      NSPECMAX_TISO_MANTLE = nspec_aniso_mantle
    else
      NSPECMAX_TISO_MANTLE = 1
    endif

    NSPECMAX_ANISO_MANTLE = 1
  endif

! if attenuation is off, set dummy size of arrays to one
  if(ATTENUATION) then
    NSPECMAX_CRUST_MANTLE_ATTENUAT = nspec_crust_mantle
    NSPEC_INNER_CORE_ATTENUATION = nspec_inner_core
  else
    NSPECMAX_CRUST_MANTLE_ATTENUAT = 1
    NSPEC_INNER_CORE_ATTENUATION = 1
  endif

  if(ROTATION) then
    NSPECMAX_OUTER_CORE_ROTATION = nspec_outer_core
  else
    NSPECMAX_OUTER_CORE_ROTATION = 1
  endif

  allocate(array_central_cube(nglob_inner_core))

  allocate(R_memory_crust_mantle(5,N_SLS,NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE_ATTENUAT))
  allocate(R_memory_inner_core(5,N_SLS,NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE_ATTENUATION))

  allocate(epsilondev_crust_mantle(5,NGLLX,NGLLY,NGLLZ,NSPECMAX_CRUST_MANTLE_ATTENUAT))
  allocate(epsilondev_inner_core(5,NGLLX,NGLLY,NGLLZ,NSPEC_INNER_CORE_ATTENUATION))

  allocate(updated_dof_ocean_load(nglob_crust_mantle))

  allocate(rho_vp_crust_mantle(NGLLX,NGLLY,NGLLZ,nspec_crust_mantle))
  allocate(rho_vs_crust_mantle(NGLLX,NGLLY,NGLLZ,nspec_crust_mantle))

  allocate(vp_outer_core(NGLLX,NGLLY,NGLLZ,nspec_outer_core))

  allocate(A_array_rotation(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE_ROTATION))
  allocate(B_array_rotation(NGLLX,NGLLY,NGLLZ,NSPECMAX_OUTER_CORE_ROTATION))

! -------- arrays specific to each region here -----------

! ----------------- crust, mantle and oceans ---------------------

! mesh parameters
  allocate(ibool_crust_mantle(NGLLX,NGLLY,NGLLZ,nspec_crust_mantle))

  allocate(xix_crust_mantle(NGLLX,NGLLY,NGLLZ,nspec_crust_mantle))
  allocate(xiy_crust_mantle(NGLLX,NGLLY,NGLLZ,nspec_crust_mantle))
  allocate(xiz_crust_mantle(NGLLX,NGLLY,NGLLZ,nspec_crust_mantle))
  allocate(etax_crust_mantle(NGLLX,NGLLY,NGLLZ,nspec_crust_mantle))
  allocate(etay_crust_mantle(NGLLX,NGLLY,NGLLZ,nspec_crust_mantle))
  allocate(etaz_crust_mantle(NGLLX,NGLLY,NGLLZ,nspec_crust_mantle))
  allocate(gammax_crust_mantle(NGLLX,NGLLY,NGLLZ,nspec_crust_mantle))
  allocate(gammay_crust_mantle(NGLLX,NGLLY,NGLLZ,nspec_crust_mantle))
  allocate(gammaz_crust_mantle(NGLLX,NGLLY,NGLLZ,nspec_crust_mantle))
  allocate(jacobian_crust_mantle(NGLLX,NGLLY,NGLLZ,nspec_crust_mantle))

  allocate(xstore_crust_mantle(nglob_crust_mantle))
  allocate(ystore_crust_mantle(nglob_crust_mantle))
  allocate(zstore_crust_mantle(nglob_crust_mantle))

! arrays for isotropic elements stored only where needed to save space
  allocate(kappavstore_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ISO_MANTLE))
  allocate(muvstore_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ISO_MANTLE))

! arrays for anisotropic elements stored only where needed to save space
  allocate(kappahstore_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_TISO_MANTLE))
  allocate(muhstore_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_TISO_MANTLE))
  allocate(eta_anisostore_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_TISO_MANTLE))

! arrays for full anisotropy only when needed
  allocate(c11store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c12store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c13store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c14store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c15store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c16store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c22store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c23store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c24store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c25store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c26store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c33store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c34store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c35store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c36store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c44store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c45store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c46store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c55store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c56store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))
  allocate(c66store_crust_mantle(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_MANTLE))

! local to global mapping
  allocate(idoubling_crust_mantle(nspec_crust_mantle))

! mass matrix
  allocate(rmass_crust_mantle(nglob_crust_mantle))

! displacement, velocity, acceleration
  allocate(displ_crust_mantle(NDIM,nglob_crust_mantle))
  allocate(veloc_crust_mantle(NDIM,nglob_crust_mantle))
  allocate(accel_crust_mantle(NDIM,nglob_crust_mantle))

! additional mass matrix for ocean load
! ocean load mass matrix is always allocated even if no oceans
  allocate(rmass_ocean_load(nglob_crust_mantle))

! ----------------- outer core ---------------------

! mesh parameters
  allocate(ibool_outer_core(NGLLX,NGLLY,NGLLZ,nspec_outer_core))

  allocate(xix_outer_core(NGLLX,NGLLY,NGLLZ,nspec_outer_core))
  allocate(xiy_outer_core(NGLLX,NGLLY,NGLLZ,nspec_outer_core))
  allocate(xiz_outer_core(NGLLX,NGLLY,NGLLZ,nspec_outer_core))
  allocate(etax_outer_core(NGLLX,NGLLY,NGLLZ,nspec_outer_core))
  allocate(etay_outer_core(NGLLX,NGLLY,NGLLZ,nspec_outer_core))
  allocate(etaz_outer_core(NGLLX,NGLLY,NGLLZ,nspec_outer_core))
  allocate(gammax_outer_core(NGLLX,NGLLY,NGLLZ,nspec_outer_core))
  allocate(gammay_outer_core(NGLLX,NGLLY,NGLLZ,nspec_outer_core))
  allocate(gammaz_outer_core(NGLLX,NGLLY,NGLLZ,nspec_outer_core))
  allocate(jacobian_outer_core(NGLLX,NGLLY,NGLLZ,nspec_outer_core))

  allocate(xstore_outer_core(nglob_outer_core))
  allocate(ystore_outer_core(nglob_outer_core))
  allocate(zstore_outer_core(nglob_outer_core))

! local to global mapping
  allocate(idoubling_outer_core(nspec_outer_core))

! mass matrix
  allocate(rmass_outer_core(nglob_outer_core))

! velocity potential
  allocate(displ_outer_core(nglob_outer_core))
  allocate(veloc_outer_core(nglob_outer_core))
  allocate(accel_outer_core(nglob_outer_core))

! ----------------- inner core ---------------------

! mesh parameters
  allocate(ibool_inner_core(NGLLX,NGLLY,NGLLZ,nspec_inner_core))

  allocate(xix_inner_core(NGLLX,NGLLY,NGLLZ,nspec_inner_core))
  allocate(xiy_inner_core(NGLLX,NGLLY,NGLLZ,nspec_inner_core))
  allocate(xiz_inner_core(NGLLX,NGLLY,NGLLZ,nspec_inner_core))
  allocate(etax_inner_core(NGLLX,NGLLY,NGLLZ,nspec_inner_core))
  allocate(etay_inner_core(NGLLX,NGLLY,NGLLZ,nspec_inner_core))
  allocate(etaz_inner_core(NGLLX,NGLLY,NGLLZ,nspec_inner_core))
  allocate(gammax_inner_core(NGLLX,NGLLY,NGLLZ,nspec_inner_core))
  allocate(gammay_inner_core(NGLLX,NGLLY,NGLLZ,nspec_inner_core))
  allocate(gammaz_inner_core(NGLLX,NGLLY,NGLLZ,nspec_inner_core))
  allocate(jacobian_inner_core(NGLLX,NGLLY,NGLLZ,nspec_inner_core))
  allocate(kappavstore_inner_core(NGLLX,NGLLY,NGLLZ,nspec_inner_core))
  allocate(muvstore_inner_core(NGLLX,NGLLY,NGLLZ,nspec_inner_core))

  allocate(xstore_inner_core(nglob_inner_core))
  allocate(ystore_inner_core(nglob_inner_core))
  allocate(zstore_inner_core(nglob_inner_core))

! arrays for inner-core anisotropy only when needed
  allocate(c11store_inner_core(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_IC))
  allocate(c33store_inner_core(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_IC))
  allocate(c12store_inner_core(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_IC))
  allocate(c13store_inner_core(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_IC))
  allocate(c44store_inner_core(NGLLX,NGLLY,NGLLZ,NSPECMAX_ANISO_IC))

! local to global mapping
  allocate(idoubling_inner_core(nspec_inner_core))

! mass matrix
  allocate(rmass_inner_core(nglob_inner_core))

! displacement, velocity, acceleration
  allocate(displ_inner_core(NDIM,nglob_inner_core))
  allocate(veloc_inner_core(NDIM,nglob_inner_core))
  allocate(accel_inner_core(NDIM,nglob_inner_core),stat=ier)

! exit if there is not enough memory to allocate all the arrays
  if(ier /= 0) call exit_MPI(myrank,'not enough memory to allocate arrays')

! --------

! make ellipticity
  if(ELLIPTICITY) then
    call make_ellipticity(nspl,rspl,espl,espl2,ONE_CRUST,ROCEAN,RMIDDLE_CRUST, &
          RMOHO,R80,R220,R400,R600,R670,R771,RTOPDDOUBLEPRIME,RCMB,RICB)

! compute ellipticity at d80 once and for all for attenuation
    radius = R80/R_EARTH
    call splint(rspl,espl,espl2,nspl,radius,ell_d80_dble)

! distinguish between single and double precision for reals
    if(CUSTOM_REAL == SIZE_REAL) then
      ell_d80 = sngl(ell_d80_dble)
    else
      ell_d80 = ell_d80_dble
    endif

  endif

! define maximum size for message buffers
! use number of elements found in the mantle since it is the largest region
  NPOIN2DMAX_XY = max(NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE))

! allocate arrays for message buffers with maximum size

  allocate(iboolfaces_crust_mantle(NPOIN2DMAX_XY,NUMFACES_SHARED))
  allocate(iboolfaces_outer_core(NPOIN2DMAX_XY,NUMFACES_SHARED))
  allocate(iboolfaces_inner_core(NPOIN2DMAX_XY,NUMFACES_SHARED))

  allocate(buffer_send_faces_scalar(NPOIN2DMAX_XY))
  allocate(buffer_received_faces_scalar(NPOIN2DMAX_XY))

  allocate(buffer_send_faces_vector(NDIM,NPOIN2DMAX_XY))
  allocate(buffer_received_faces_vector(NDIM,NPOIN2DMAX_XY))

! number of corners and faces shared between chunks and number of message types
  if(NCHUNKS == 1 .or. NCHUNKS == 2) then
    NCORNERSCHUNKS = 1
    NUM_FACES = 1
    NUM_MSG_TYPES = 1
  else if(NCHUNKS == 3) then
    NCORNERSCHUNKS = 1
    NUM_FACES = 1
    NUM_MSG_TYPES = 3
  else if(NCHUNKS == 6) then
    NCORNERSCHUNKS = 8
    NUM_FACES = 4
    NUM_MSG_TYPES = 3
  else
    call exit_MPI(myrank,'number of chunks must be either 1, 2, 3 or 6')
  endif

! if more than one chunk then same number of processors in each direction
  NPROC_ONE_DIRECTION = NPROC_XI

! total number of messages corresponding to these common faces
  NUMMSGS_FACES = NPROC_ONE_DIRECTION*NUM_FACES*NUM_MSG_TYPES

! allocate array for messages for faces
  allocate(iprocfrom_faces(NUMMSGS_FACES))
  allocate(iprocto_faces(NUMMSGS_FACES))
  allocate(imsg_type(NUMMSGS_FACES))

! allocate array for messages for corners
  allocate(iproc_master_corners(NCORNERSCHUNKS))
  allocate(iproc_slave1_corners(NCORNERSCHUNKS))
  allocate(iproc_slave2_corners(NCORNERSCHUNKS))

! attenuation
  if(ATTENUATION) then
     if(ATTENUATION_3D) then
        ! for all points in the mesh
        ! Allocate CRUST MANTLE
        allocate(      factor_scale_crust_mantle(       NGLLX, NGLLY, NGLLZ, nspec_crust_mantle))
        allocate(one_minus_sum_beta_crust_mantle(       NGLLX, NGLLY, NGLLZ, nspec_crust_mantle))
        allocate(     factor_common_crust_mantle(N_SLS, NGLLX, NGLLY, NGLLZ, nspec_crust_mantle))

        allocate( factor_scale_crust_mantle_dble(       NGLLX, NGLLY, NGLLZ, nspec_crust_mantle))
        allocate(         omsb_crust_mantle_dble(       NGLLX, NGLLY, NGLLZ, nspec_crust_mantle))
        allocate(factor_common_crust_mantle_dble(N_SLS, NGLLX, NGLLY, NGLLZ, nspec_crust_mantle))
        ! Allocate INNER CORE
        allocate(      factor_scale_inner_core(       NGLLX, NGLLY, NGLLZ, nspec_inner_core))
        allocate(one_minus_sum_beta_inner_core(       NGLLX, NGLLY, NGLLZ, nspec_inner_core))
        allocate(     factor_common_inner_core(N_SLS, NGLLX, NGLLY, NGLLZ, nspec_inner_core))

        allocate( factor_scale_inner_core_dble(       NGLLX, NGLLY, NGLLZ, nspec_inner_core))
        allocate(         omsb_inner_core_dble(       NGLLX, NGLLY, NGLLZ, nspec_inner_core))
        allocate(factor_common_inner_core_dble(N_SLS, NGLLX, NGLLY, NGLLZ, nspec_inner_core))
     else
        ! Allocate CRUST MANTLE
        allocate(      factor_scale_crust_mantle(       1, 1, 1, NUM_REGIONS_ATTENUATION))
        allocate(one_minus_sum_beta_crust_mantle(       1, 1, 1, NUM_REGIONS_ATTENUATION))
        allocate(     factor_common_crust_mantle(N_SLS, 1, 1, 1, NUM_REGIONS_ATTENUATION))

        allocate(factor_scale_crust_mantle_dble(       1, 1, 1, NUM_REGIONS_ATTENUATION))
        allocate(        omsb_crust_mantle_dble(       1, 1, 1, NUM_REGIONS_ATTENUATION))
        allocate(factor_common_crust_mantle_dble(N_SLS, 1, 1, 1, NUM_REGIONS_ATTENUATION))
        ! Allocate INNER CORE
        allocate(      factor_scale_inner_core(       1, 1, 1, 1))
        allocate(one_minus_sum_beta_inner_core(       1, 1, 1, 1))
        allocate(     factor_common_inner_core(N_SLS, 1, 1, 1, 1))

        allocate( factor_scale_inner_core_dble(       1, 1, 1, 1))
        allocate(         omsb_inner_core_dble(       1, 1, 1, 1))
        allocate(factor_common_inner_core_dble(N_SLS, 1, 1, 1, 1))
     endif
  endif

! start reading the databases

! read arrays created by the mesher

! crust and mantle

  if(ANISOTROPIC_3D_MANTLE) then
    READ_KAPPA_MU = .false.
    READ_TISO = .false.
    nspec_iso = 1
    nspec_tiso = 1
    nspec_ani = nspec_crust_mantle
  else
    nspec_iso = nspec_crust_mantle
    if(TRANSVERSE_ISOTROPY) then
      nspec_tiso = NSPECMAX_TISO_MANTLE
    else
      nspec_tiso = 1
    endif
    nspec_ani = 1
    READ_KAPPA_MU = .true.
    READ_TISO = .true.
  endif
  call read_arrays_solver(IREGION_CRUST_MANTLE,myrank, &
            rho_vp_crust_mantle,rho_vs_crust_mantle, &
            xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
            xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle, &
            etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
            gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,jacobian_crust_mantle, &
            kappavstore_crust_mantle,muvstore_crust_mantle, &
            kappahstore_crust_mantle,muhstore_crust_mantle,eta_anisostore_crust_mantle, &
            nspec_iso,nspec_tiso,nspec_ani, &
            c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle, &
            c14store_crust_mantle,c15store_crust_mantle,c16store_crust_mantle, &
            c22store_crust_mantle,c23store_crust_mantle,c24store_crust_mantle, &
            c25store_crust_mantle,c26store_crust_mantle,c33store_crust_mantle, &
            c34store_crust_mantle,c35store_crust_mantle,c36store_crust_mantle, &
            c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
            c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
            ibool_crust_mantle,idoubling_crust_mantle,rmass_crust_mantle,rmass_ocean_load, &
            nspec_crust_mantle,nglob_crust_mantle, &
            READ_KAPPA_MU,READ_TISO,TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE, &
            ANISOTROPIC_INNER_CORE,OCEANS,LOCAL_PATH,NCHUNKS)

! outer core (no anisotropy nor S velocity)
! rmass_ocean_load is not modified in routine
  READ_KAPPA_MU = .false.
  READ_TISO = .false.
  nspec_iso = 1
  nspec_tiso = 1
  nspec_ani = 1
  call read_arrays_solver(IREGION_OUTER_CORE,myrank, &
            vp_outer_core,dummyval, &
            xstore_outer_core,ystore_outer_core,zstore_outer_core, &
            xix_outer_core,xiy_outer_core,xiz_outer_core, &
            etax_outer_core,etay_outer_core,etaz_outer_core, &
            gammax_outer_core,gammay_outer_core,gammaz_outer_core,jacobian_outer_core, &
            dummyval,dummyval, &
            dummyval,dummyval,dummyval, &
            nspec_iso,nspec_tiso,nspec_ani, &
            dummyval,dummyval,dummyval,dummyval,dummyval,dummyval,dummyval, &
            dummyval,dummyval,dummyval,dummyval,dummyval,dummyval,dummyval, &
            dummyval,dummyval,dummyval,dummyval,dummyval,dummyval,dummyval, &
            ibool_outer_core,idoubling_outer_core,rmass_outer_core,rmass_ocean_load, &
            nspec_outer_core,nglob_outer_core, &
            READ_KAPPA_MU,READ_TISO,TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE, &
            ANISOTROPIC_INNER_CORE,OCEANS,LOCAL_PATH,NCHUNKS)

! inner core (no anisotropy)
! rmass_ocean_load is not modified in routine
  READ_KAPPA_MU = .true.
  READ_TISO = .false.
  nspec_iso = nspec_inner_core
  nspec_tiso = 1
  if(ANISOTROPIC_INNER_CORE) then
    nspec_ani = nspec_inner_core
  else
    nspec_ani = 1
  endif
  call read_arrays_solver(IREGION_INNER_CORE,myrank, &
            dummyval,dummyval, &
            xstore_inner_core,ystore_inner_core,zstore_inner_core, &
            xix_inner_core,xiy_inner_core,xiz_inner_core, &
            etax_inner_core,etay_inner_core,etaz_inner_core, &
            gammax_inner_core,gammay_inner_core,gammaz_inner_core,jacobian_inner_core, &
            kappavstore_inner_core,muvstore_inner_core, &
            dummyval,dummyval,dummyval, &
            nspec_iso,nspec_tiso,nspec_ani, &
            c11store_inner_core,c12store_inner_core,c13store_inner_core,dummyval,dummyval,dummyval,dummyval, &
            dummyval,dummyval,dummyval,dummyval,c33store_inner_core,dummyval,dummyval, &
            dummyval,c44store_inner_core,dummyval,dummyval,dummyval,dummyval,dummyval, &
            ibool_inner_core,idoubling_inner_core,rmass_inner_core,rmass_ocean_load, &
            nspec_inner_core,nglob_inner_core, &
            READ_KAPPA_MU,READ_TISO,TRANSVERSE_ISOTROPY,ANISOTROPIC_3D_MANTLE, &
            ANISOTROPIC_INNER_CORE,OCEANS,LOCAL_PATH,NCHUNKS)

! check that the number of points in this slice is correct

  if(minval(ibool_crust_mantle(:,:,:,1:nspec_crust_mantle)) /= 1 .or. &
    maxval(ibool_crust_mantle(:,:,:,1:nspec_crust_mantle)) /= nglob_crust_mantle) &
      call exit_MPI(myrank,'incorrect global numbering: iboolmax does not equal nglob in crust and mantle')

  if(minval(ibool_outer_core(:,:,:,1:nspec_outer_core)) /= 1 .or. &
     maxval(ibool_outer_core(:,:,:,1:nspec_outer_core)) /= nglob_outer_core) &
    call exit_MPI(myrank,'incorrect global numbering: iboolmax does not equal nglob in outer core')

  if(minval(ibool_inner_core(:,:,:,:)) /= 1 .or. maxval(ibool_inner_core(:,:,:,:)) /= nglob_inner_core) &
    call exit_MPI(myrank,'incorrect global numbering: iboolmax does not equal nglob in inner core')

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

! set up GLL points, weights and derivation matrices
  call define_derivation_matrices(xigll,yigll,zigll,wxgll,wygll,wzgll, &
         hprime_xx,hprime_yy,hprime_zz, &
         hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
         wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube)

! read topography and bathymetry file
  if(TOPOGRAPHY .or. OCEANS) call read_topo_bathy_file(ibathy_topo)

! allocate arrays for source
  allocate(sourcearray(NDIM,NGLLX,NGLLY,NGLLZ))
  allocate(sourcearrays(NSOURCES,NDIM,NGLLX,NGLLY,NGLLZ))
  allocate(islice_selected_source(NSOURCES))
  allocate(ispec_selected_source(NSOURCES))
  allocate(Mxx(NSOURCES))
  allocate(Myy(NSOURCES))
  allocate(Mzz(NSOURCES))
  allocate(Mxy(NSOURCES))
  allocate(Mxz(NSOURCES))
  allocate(Myz(NSOURCES))
  allocate(xi_source(NSOURCES))
  allocate(eta_source(NSOURCES))
  allocate(gamma_source(NSOURCES))
  allocate(t_cmt(NSOURCES))
  allocate(hdur(NSOURCES))
  allocate(hdur_gaussian(NSOURCES))
  allocate(theta_source(NSOURCES))
  allocate(phi_source(NSOURCES))

! locate sources in the mesh
  call locate_sources(NSOURCES,myrank,nspec_crust_mantle, &
            nglob_crust_mantle,idoubling_crust_mantle,ibool_crust_mantle, &
            xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
            xigll,yigll,zigll,NPROCTOT,ELLIPTICITY,TOPOGRAPHY, &
            sec,t_cmt,yr,jda,ho,mi,theta_source,phi_source, &
            NSTEP,DT,hdur,Mxx,Myy,Mzz,Mxy,Mxz,Myz, &
            islice_selected_source,ispec_selected_source, &
            xi_source,eta_source,gamma_source, &
            rspl,espl,espl2,nspl,ibathy_topo,NEX_XI,PRINT_SOURCE_TIME_FUNCTION)

  if(minval(t_cmt) /= 0.) call exit_MPI(myrank,'one t_cmt must be zero, others must be positive')

! filter source time function by Gaussian with hdur = HDUR_MOVIE when outputing movies or shakemaps
  if (MOVIE_SURFACE .or. MOVIE_VOLUME ) then
     hdur = sqrt(hdur**2 + HDUR_MOVIE**2)
     if(myrank == 0) then
        write(IMAIN,*)
        write(IMAIN,*) 'Each source is being convolved with HDUR_MOVIE = ',HDUR_MOVIE
        write(IMAIN,*)
     endif
  endif
! convert the half duration for triangle STF to the one for gaussian STF
  hdur_gaussian = hdur/SOURCE_DECAY_RATE

! define t0 as the earliest start time
  t0 = - 1.5d0*minval(t_cmt-hdur)

  open(unit=IIN,file='DATA/STATIONS',status='old')
  read(IIN,*) nrec
  close(IIN)

  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'Total number of receivers = ',nrec
    write(IMAIN,*)
  endif

  if(nrec < 1) call exit_MPI(myrank,'need at least one receiver')

! allocate memory for receiver arrays
  allocate(islice_selected_rec(nrec))
  allocate(ispec_selected_rec(nrec))
  allocate(xi_receiver(nrec))
  allocate(eta_receiver(nrec))
  allocate(gamma_receiver(nrec))
  allocate(station_name(nrec))
  allocate(network_name(nrec))
  allocate(nu(NDIM,NDIM,nrec))

! locate receivers in the crust in the mesh
  call locate_receivers(myrank,DT,NSTEP,nspec_crust_mantle, &
            nglob_crust_mantle,idoubling_crust_mantle,ibool_crust_mantle, &
            xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
            xigll,yigll,nrec,islice_selected_rec,ispec_selected_rec, &
            xi_receiver,eta_receiver,gamma_receiver,station_name,network_name,nu, &
            yr,jda,ho,mi,sec, &
            NPROCTOT,ELLIPTICITY,TOPOGRAPHY, &
            theta_source(1),phi_source(1),rspl,espl,espl2,nspl,ibathy_topo,RECEIVERS_CAN_BE_BURIED)

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

! read 2-D addressing for summation between slices with MPI

! mantle and crust
  call read_arrays_buffers_solver(IREGION_CRUST_MANTLE,myrank,iboolleft_xi_crust_mantle, &
     iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
     npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
     iprocfrom_faces,iprocto_faces,imsg_type, &
     iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
     iboolfaces_crust_mantle,npoin2D_faces_crust_mantle, &
     iboolcorner_crust_mantle, &
     NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE), &
     NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_XY,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE), &
     NUMMSGS_FACES,NCORNERSCHUNKS,NPROCTOT,NPROC_XI,NPROC_ETA,LOCAL_PATH,NCHUNKS)

! outer core
  call read_arrays_buffers_solver(IREGION_OUTER_CORE,myrank, &
     iboolleft_xi_outer_core,iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core, &
     npoin2D_xi_outer_core,npoin2D_eta_outer_core, &
     iprocfrom_faces,iprocto_faces,imsg_type, &
     iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
     iboolfaces_outer_core,npoin2D_faces_outer_core, &
     iboolcorner_outer_core, &
     NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE), &
     NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE),NPOIN2DMAX_XY,NPOIN1D_RADIAL(IREGION_OUTER_CORE), &
     NUMMSGS_FACES,NCORNERSCHUNKS,NPROCTOT,NPROC_XI,NPROC_ETA,LOCAL_PATH,NCHUNKS)

! inner core
  call read_arrays_buffers_solver(IREGION_INNER_CORE,myrank, &
     iboolleft_xi_inner_core,iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core, &
     npoin2D_xi_inner_core,npoin2D_eta_inner_core, &
     iprocfrom_faces,iprocto_faces,imsg_type, &
     iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
     iboolfaces_inner_core,npoin2D_faces_inner_core, &
     iboolcorner_inner_core, &
     NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE), &
     NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE),NPOIN2DMAX_XY,NPOIN1D_RADIAL(IREGION_INNER_CORE), &
     NUMMSGS_FACES,NCORNERSCHUNKS,NPROCTOT,NPROC_XI,NPROC_ETA,LOCAL_PATH,NCHUNKS)

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

  if(myrank == 0) then
    write(IMAIN,*) '**************************************************'
    write(IMAIN,*) 'There are ',NEX_XI,' elements along xi in each chunk'
    write(IMAIN,*) 'There are ',NEX_ETA,' elements along eta in each chunk'
    write(IMAIN,*)
    write(IMAIN,*) 'There are ',NPROC_XI,' slices along xi in each chunk'
    write(IMAIN,*) 'There are ',NPROC_ETA,' slices along eta in each chunk'
    write(IMAIN,*) 'There is a total of ',NPROC,' slices in each chunk'
    write(IMAIN,*) '**************************************************'
    write(IMAIN,*)
  endif

! allocate 1-D Lagrange interpolators and derivatives
  allocate(hxir(NGLLX))
  allocate(hpxir(NGLLX))
  allocate(hetar(NGLLY))
  allocate(hpetar(NGLLY))
  allocate(hgammar(NGLLZ))
  allocate(hpgammar(NGLLZ))

! to couple mantle with outer core

! create name of database
  call create_name_database(prname,myrank,IREGION_CRUST_MANTLE,LOCAL_PATH)

! dynamic allocation of arrays

! boundary parameters locator
  allocate(ibelm_xmin_crust_mantle(NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(ibelm_xmax_crust_mantle(NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(ibelm_ymin_crust_mantle(NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(ibelm_ymax_crust_mantle(NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(ibelm_bottom_crust_mantle(NSPEC2D_BOTTOM(IREGION_CRUST_MANTLE)))
  allocate(ibelm_top_crust_mantle(NSPEC2D_TOP(IREGION_CRUST_MANTLE)))

  allocate(jacobian2D_xmin_crust_mantle(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(jacobian2D_xmax_crust_mantle(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(jacobian2D_ymin_crust_mantle(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(jacobian2D_ymax_crust_mantle(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(jacobian2D_bottom_crust_mantle(NGLLX,NGLLY,NSPEC2D_BOTTOM(IREGION_CRUST_MANTLE)))
  allocate(jacobian2D_top_crust_mantle(NGLLX,NGLLY,NSPEC2D_TOP(IREGION_CRUST_MANTLE)))

! normals
  allocate(normal_xmin_crust_mantle(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(normal_xmax_crust_mantle(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(normal_ymin_crust_mantle(NDIM,NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(normal_ymax_crust_mantle(NDIM,NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(normal_bottom_crust_mantle(NDIM,NGLLX,NGLLY,NSPEC2D_BOTTOM(IREGION_CRUST_MANTLE)))
  allocate(normal_top_crust_mantle(NDIM,NGLLX,NGLLY,NSPEC2D_TOP(IREGION_CRUST_MANTLE)))

! Stacey
  allocate(nimin_crust_mantle(2,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(nimax_crust_mantle(2,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))
  allocate(njmin_crust_mantle(2,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(njmax_crust_mantle(2,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(nkmin_xi_crust_mantle(2,NSPEC2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE)))
  allocate(nkmin_eta_crust_mantle(2,NSPEC2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE)))

! boundary parameters
  open(unit=27,file=prname(1:len_trim(prname))//'ibelm.bin',status='old',form='unformatted')
  read(27) ibelm_xmin_crust_mantle
  read(27) ibelm_xmax_crust_mantle
  read(27) ibelm_ymin_crust_mantle
  read(27) ibelm_ymax_crust_mantle
  read(27) ibelm_bottom_crust_mantle
  read(27) ibelm_top_crust_mantle
  close(27)

  open(unit=27,file=prname(1:len_trim(prname))//'normal.bin',status='old',form='unformatted')
  read(27) normal_xmin_crust_mantle
  read(27) normal_xmax_crust_mantle
  read(27) normal_ymin_crust_mantle
  read(27) normal_ymax_crust_mantle
  read(27) normal_bottom_crust_mantle
  read(27) normal_top_crust_mantle
  close(27)

  open(unit=27,file=prname(1:len_trim(prname))//'jacobian2D.bin',status='old',form='unformatted')
  read(27) jacobian2D_xmin_crust_mantle
  read(27) jacobian2D_xmax_crust_mantle
  read(27) jacobian2D_ymin_crust_mantle
  read(27) jacobian2D_ymax_crust_mantle
  read(27) jacobian2D_bottom_crust_mantle
  read(27) jacobian2D_top_crust_mantle
  close(27)

! Stacey put back
  open(unit=27,file=prname(1:len_trim(prname))//'nspec2D.bin',status='unknown',form='unformatted')
  read(27) nspec2D_xmin_crust_mantle
  read(27) nspec2D_xmax_crust_mantle
  read(27) nspec2D_ymin_crust_mantle
  read(27) nspec2D_ymax_crust_mantle
  close(27)

! read arrays for Stacey conditions

  if(ABSORBING_CONDITIONS) then
      open(unit=27,file=prname(1:len_trim(prname))//'nimin.bin',status='unknown',form='unformatted')
      read(27) nimin_crust_mantle
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nimax.bin',status='unknown',form='unformatted')
      read(27) nimax_crust_mantle
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'njmin.bin',status='unknown',form='unformatted')
      read(27) njmin_crust_mantle
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'njmax.bin',status='unknown',form='unformatted')
      read(27) njmax_crust_mantle
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nkmin_xi.bin',status='unknown',form='unformatted')
      read(27) nkmin_xi_crust_mantle
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nkmin_eta.bin',status='unknown',form='unformatted')
      read(27) nkmin_eta_crust_mantle
      close(27)
  endif

! read parameters to couple fluid and solid regions

!
!---- outer core
!

! create name of database
  call create_name_database(prname,myrank,IREGION_OUTER_CORE,LOCAL_PATH)

! dynamic allocation of arrays

! boundary parameters locator
  allocate(ibelm_xmin_outer_core(NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(ibelm_xmax_outer_core(NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(ibelm_ymin_outer_core(NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(ibelm_ymax_outer_core(NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(ibelm_bottom_outer_core(NSPEC2D_BOTTOM(IREGION_OUTER_CORE)))
  allocate(ibelm_top_outer_core(NSPEC2D_TOP(IREGION_OUTER_CORE)))

! normals
  allocate(normal_xmin_outer_core(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(normal_xmax_outer_core(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(normal_ymin_outer_core(NDIM,NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(normal_ymax_outer_core(NDIM,NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(normal_bottom_outer_core(NDIM,NGLLX,NGLLY,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)))
  allocate(normal_top_outer_core(NDIM,NGLLX,NGLLY,NSPEC2D_TOP(IREGION_OUTER_CORE)))

! jacobian on 2D edges
  allocate(jacobian2D_xmin_outer_core(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(jacobian2D_xmax_outer_core(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(jacobian2D_ymin_outer_core(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(jacobian2D_ymax_outer_core(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(jacobian2D_bottom_outer_core(NGLLX,NGLLY,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)))
  allocate(jacobian2D_top_outer_core(NGLLX,NGLLY,NSPEC2D_TOP(IREGION_OUTER_CORE)))

! Stacey
  allocate(nimin_outer_core(2,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(nimax_outer_core(2,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))
  allocate(njmin_outer_core(2,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(njmax_outer_core(2,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(nkmin_xi_outer_core(2,NSPEC2DMAX_XMIN_XMAX(IREGION_OUTER_CORE)))
  allocate(nkmin_eta_outer_core(2,NSPEC2DMAX_YMIN_YMAX(IREGION_OUTER_CORE)))

! boundary parameters
  open(unit=27,file=prname(1:len_trim(prname))//'ibelm.bin',status='old',form='unformatted')
  read(27) ibelm_xmin_outer_core
  read(27) ibelm_xmax_outer_core
  read(27) ibelm_ymin_outer_core
  read(27) ibelm_ymax_outer_core
  read(27) ibelm_bottom_outer_core
  read(27) ibelm_top_outer_core
  close(27)

  open(unit=27,file=prname(1:len_trim(prname))//'normal.bin',status='old',form='unformatted')
  read(27) normal_xmin_outer_core
  read(27) normal_xmax_outer_core
  read(27) normal_ymin_outer_core
  read(27) normal_ymax_outer_core
  read(27) normal_bottom_outer_core
  read(27) normal_top_outer_core
  close(27)

! Stacey put back
  open(unit=27,file=prname(1:len_trim(prname))//'nspec2D.bin',status='unknown',form='unformatted')
  read(27) nspec2D_xmin_outer_core
  read(27) nspec2D_xmax_outer_core
  read(27) nspec2D_ymin_outer_core
  read(27) nspec2D_ymax_outer_core
  close(27)

  open(unit=27,file=prname(1:len_trim(prname))//'jacobian2D.bin',status='old',form='unformatted')
  read(27) jacobian2D_xmin_outer_core
  read(27) jacobian2D_xmax_outer_core
  read(27) jacobian2D_ymin_outer_core
  read(27) jacobian2D_ymax_outer_core
  read(27) jacobian2D_bottom_outer_core
  read(27) jacobian2D_top_outer_core
  close(27)

! read arrays for Stacey conditions

  if(ABSORBING_CONDITIONS) then
      open(unit=27,file=prname(1:len_trim(prname))//'nimin.bin',status='unknown',form='unformatted')
      read(27) nimin_outer_core
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nimax.bin',status='unknown',form='unformatted')
      read(27) nimax_outer_core
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'njmin.bin',status='unknown',form='unformatted')
      read(27) njmin_outer_core
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'njmax.bin',status='unknown',form='unformatted')
      read(27) njmax_outer_core
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nkmin_xi.bin',status='unknown',form='unformatted')
      read(27) nkmin_xi_outer_core
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nkmin_eta.bin',status='unknown',form='unformatted')
      read(27) nkmin_eta_outer_core
      close(27)
  endif

!
!---- inner core
!

! create name of database
  call create_name_database(prname,myrank,IREGION_INNER_CORE,LOCAL_PATH)

! dynamic allocation of arrays

! boundary parameters locator
  allocate(ibelm_xmin_inner_core(NSPEC2DMAX_XMIN_XMAX(IREGION_INNER_CORE)))
  allocate(ibelm_xmax_inner_core(NSPEC2DMAX_XMIN_XMAX(IREGION_INNER_CORE)))
  allocate(ibelm_ymin_inner_core(NSPEC2DMAX_YMIN_YMAX(IREGION_INNER_CORE)))
  allocate(ibelm_ymax_inner_core(NSPEC2DMAX_YMIN_YMAX(IREGION_INNER_CORE)))
  allocate(ibelm_bottom_inner_core(NSPEC2D_BOTTOM(IREGION_INNER_CORE)))
  allocate(ibelm_top_inner_core(NSPEC2D_TOP(IREGION_INNER_CORE)))

! boundary parameters
  open(unit=27,file=prname(1:len_trim(prname))//'ibelm.bin',status='old',form='unformatted')
  read(27) ibelm_xmin_inner_core
  read(27) ibelm_xmax_inner_core
  read(27) ibelm_ymin_inner_core
  read(27) ibelm_ymax_inner_core
  read(27) ibelm_bottom_inner_core
  read(27) ibelm_top_inner_core
  close(27)

! read info for vertical edges for central cube matching in inner core
  open(unit=27,file=prname(1:len_trim(prname))//'nspec2D.bin',status='old',form='unformatted')
  read(27) nspec2D_xmin_inner_core
  read(27) nspec2D_xmax_inner_core
  read(27) nspec2D_ymin_inner_core
  read(27) nspec2D_ymax_inner_core
  close(27)

  do isource = 1,NSOURCES

!   check that the source slice number is okay
    if(islice_selected_source(isource) < 0 .or. islice_selected_source(isource) > NPROCTOT-1) &
      call exit_MPI(myrank,'something is wrong with the source slice number')

!   compute source arrays in source slice
    if(myrank == islice_selected_source(isource)) then
      call compute_arrays_source(ispec_selected_source(isource), &
             xi_source(isource),eta_source(isource),gamma_source(isource),sourcearray, &
             Mxx(isource),Myy(isource),Mzz(isource),Mxy(isource),Mxz(isource),Myz(isource), &
             xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle, &
             etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
             gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle, &
             xigll,yigll,zigll,nspec_crust_mantle)
      sourcearrays(isource,:,:,:,:) = sourcearray(:,:,:,:)
    endif

  enddo

  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'Total number of samples for seismograms = ',NSTEP
    write(IMAIN,*)
  endif

!--- select local receivers

! count number of receivers located in this slice
  nrec_local = 0

  do irec = 1,nrec

! check that the receiver slice number is okay
  if(islice_selected_rec(irec) < 0 .or. islice_selected_rec(irec) > NPROCTOT-1) &
    call exit_MPI(myrank,'something is wrong with the receiver slice number')

! write info about that receiver
  if(myrank == islice_selected_rec(irec)) then

    nrec_local = nrec_local + 1

  endif

  enddo

! allocate seismogram array
  allocate(seismograms(NDIM,nrec_local,NSTEP))

! allocate Lagrange interpolators for receivers
  allocate(hxir_store(nrec_local,NGLLX))
  allocate(hetar_store(nrec_local,NGLLY))
  allocate(hgammar_store(nrec_local,NGLLZ))

! define local to global receiver numbering mapping
  allocate(number_receiver_global(nrec_local))
  irec_local = 0
  do irec = 1,nrec
    if(myrank == islice_selected_rec(irec)) then
      irec_local = irec_local + 1
      number_receiver_global(irec_local) = irec
    endif
  enddo

! define and store Lagrange interpolators at all the receivers
  do irec_local = 1,nrec_local
    irec = number_receiver_global(irec_local)
    call lagrange_any(xi_receiver(irec),NGLLX,xigll,hxir,hpxir)
    call lagrange_any(eta_receiver(irec),NGLLY,yigll,hetar,hpetar)
    call lagrange_any(gamma_receiver(irec),NGLLZ,zigll,hgammar,hpgammar)
    hxir_store(irec_local,:) = hxir(:)
    hetar_store(irec_local,:) = hetar(:)
    hgammar_store(irec_local,:) = hgammar(:)
  enddo

! check that the sum of the number of receivers in each slice is nrec
  call MPI_REDUCE(nrec_local,nrec_tot_found,1,MPI_INTEGER,MPI_SUM,0, &
                          MPI_COMM_WORLD,ier)
  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'found a total of ',nrec_tot_found,' receivers in all the slices'
    if(nrec_tot_found /= nrec) then
      call exit_MPI(myrank,'problem when dispatching the receivers')
    else
      write(IMAIN,*) 'this total is okay'
    endif
  endif

! initialize seismograms
  seismograms(:,:,:) = 0._CUSTOM_REAL

  if(myrank == 0) then

  write(IMAIN,*)
  write(IMAIN,*) 'Reference radius of the Earth used is ',R_EARTH_KM,' km'
  write(IMAIN,*)

  if(NSOURCES > 1) write(IMAIN,*) 'Using ',NSOURCES,' point sources'

  write(IMAIN,*)
  if(ELLIPTICITY) then
    write(IMAIN,*) 'incorporating ellipticity'
  else
    write(IMAIN,*) 'no ellipticity'
  endif

  write(IMAIN,*)
  if(TOPOGRAPHY) then
    write(IMAIN,*) 'incorporating surface topography'
  else
    write(IMAIN,*) 'no surface topography'
  endif

  write(IMAIN,*)
  if(ISOTROPIC_3D_MANTLE) then
    write(IMAIN,*) 'incorporating 3-D lateral variations'
  else
    write(IMAIN,*) 'no 3-D lateral variations'
  endif

  write(IMAIN,*)
  if(CRUSTAL) then
    write(IMAIN,*) 'incorporating crustal variations'
  else
    write(IMAIN,*) 'no crustal variations'
  endif

  write(IMAIN,*)
  if(ONE_CRUST) then
    write(IMAIN,*) 'using one layer only in PREM crust'
  else
    write(IMAIN,*) 'using real PREM crust with two layers'
  endif

  write(IMAIN,*)
  if(GRAVITY) then
    write(IMAIN,*) 'incorporating self-gravitation (Cowling approximation)'
  else
    write(IMAIN,*) 'no self-gravitation'
  endif

  write(IMAIN,*)
  if(ROTATION) then
    write(IMAIN,*) 'incorporating rotation'
  else
    write(IMAIN,*) 'no rotation'
  endif

  write(IMAIN,*)
  if(TRANSVERSE_ISOTROPY) then
    write(IMAIN,*) 'incorporating transverse isotropy'
  else
    write(IMAIN,*) 'no transverse isotropy'
  endif

  write(IMAIN,*)
  if(ATTENUATION) then
    write(IMAIN,*) 'incorporating attenuation using ',N_SLS,' standard linear solids'
    if(ATTENUATION_3D) write(IMAIN,*) 'using 3D attenuation'
  else
    write(IMAIN,*) 'no attenuation'
  endif

  write(IMAIN,*)
  if(OCEANS) then
    write(IMAIN,*) 'incorporating the oceans using equivalent load'
  else
    write(IMAIN,*) 'no oceans'
  endif

  write(IMAIN,*)
  if(ANISOTROPIC_INNER_CORE) then
    write(IMAIN,*) 'incorporating anisotropic inner core'
  else
    write(IMAIN,*) 'no inner-core anisotropy'
  endif

  write(IMAIN,*)
  if(ANISOTROPIC_3D_MANTLE) then
    write(IMAIN,*) 'incorporating anisotropic mantle'
  else
    write(IMAIN,*) 'no general mantle anisotropy'
  endif
  write(IMAIN,*)
  write(IMAIN,*)

  endif

! synchronize all the processes before assembling the mass matrix
! to make sure all the nodes have finished to read their databases
  call MPI_BARRIER(MPI_COMM_WORLD,ier)

! the mass matrix needs to be assembled with MPI here once and for all

! ocean load
  call assemble_MPI_scalar(myrank,rmass_ocean_load,nglob_crust_mantle, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_crust_mantle,iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
            npoin2D_faces_crust_mantle,npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
            iboolfaces_crust_mantle,iboolcorner_crust_mantle, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_XY,NCHUNKS)

! crust and mantle
  call assemble_MPI_scalar(myrank,rmass_crust_mantle,nglob_crust_mantle, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_crust_mantle,iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
            npoin2D_faces_crust_mantle,npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
            iboolfaces_crust_mantle,iboolcorner_crust_mantle, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_XY,NCHUNKS)

! outer core
  call assemble_MPI_scalar(myrank,rmass_outer_core,nglob_outer_core, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_outer_core,iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core, &
            npoin2D_faces_outer_core,npoin2D_xi_outer_core,npoin2D_eta_outer_core, &
            iboolfaces_outer_core,iboolcorner_outer_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_OUTER_CORE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE),NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE),NPOIN2DMAX_XY,NCHUNKS)

! inner core
  call assemble_MPI_scalar(myrank,rmass_inner_core,nglob_inner_core, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_inner_core,iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core, &
            npoin2D_faces_inner_core,npoin2D_xi_inner_core,npoin2D_eta_inner_core, &
            iboolfaces_inner_core,iboolcorner_inner_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_INNER_CORE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE),NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE),NPOIN2DMAX_XY,NCHUNKS)

  if(myrank == 0) write(IMAIN,*) 'end assembling MPI mass matrix'

!
!--- create buffers to assemble with central cube
!

  if(INCLUDE_CENTRAL_CUBE) then
  if(myrank == 0) write(IMAIN,*) 'including central cube'
!--- number of messages to expect in cube
!--- take into account vertical sides and bottom side

! only for slices in central cube
  if(ichunk == CHUNK_AB) then
    if(NPROC_XI == 1) then
! five sides if only one processor in cube
      nb_msgs_theor_in_cube = 5
    else
! case of corner
      if((iproc_xi == 0 .or. iproc_xi == NPROC_XI-1).and. &
         (iproc_eta == 0 .or. iproc_eta == NPROC_ETA-1)) then
        nb_msgs_theor_in_cube = 2*NPROC_XI + 1
! case of edge
      else if(iproc_xi == 0 .or. iproc_xi == NPROC_XI-1 .or. &
              iproc_eta == 0 .or. iproc_eta == NPROC_ETA-1) then
        nb_msgs_theor_in_cube = NPROC_XI + 1
      else
! bottom element only
        nb_msgs_theor_in_cube = 1
      endif
    endif
  else
! not in chunk AB
    nb_msgs_theor_in_cube = 0
  endif

!--- processor to send information to in cube from slices

! only for slices that are not in central cube
  if(ichunk /= CHUNK_AB) then

! four vertical sides first
    if(ichunk == CHUNK_AC) then
      receiver_cube_from_slices = addressing(CHUNK_AB,0,iproc_eta)

    else if(ichunk == CHUNK_BC) then
      receiver_cube_from_slices = addressing(CHUNK_AB,iproc_eta,NPROC_ETA-1)

    else if(ichunk == CHUNK_AC_ANTIPODE) then
      receiver_cube_from_slices = addressing(CHUNK_AB,NPROC_XI-1,iproc_eta)

    else if(ichunk == CHUNK_BC_ANTIPODE) then
      receiver_cube_from_slices = addressing(CHUNK_AB,NPROC_XI-1-iproc_eta,0)

! bottom of cube, direct correspondence but with inverted xi axis
    else if(ichunk == CHUNK_AB_ANTIPODE) then
      receiver_cube_from_slices = addressing(CHUNK_AB,NPROC_XI-1-iproc_xi,iproc_eta)

    endif

  else
! dummy value in cube
    receiver_cube_from_slices = -1
  endif


!--- list of processors to receive information from in cube

! only for slices in central cube
  if(ichunk == CHUNK_AB) then

    allocate(sender_from_slices_to_cube(nb_msgs_theor_in_cube))

! initialize index of sender
    imsg = 0

! define sender for bottom edge
! bottom of cube, direct correspondence but with inverted xi axis
    imsg = imsg + 1
    sender_from_slices_to_cube(imsg) = addressing(CHUNK_AB_ANTIPODE,NPROC_XI-1-iproc_xi,iproc_eta)

! define sender for xi = xi_min edge
    if(iproc_xi == 0) then
      do iproc_xi_loop = 0,NPROC_XI-1
        imsg = imsg + 1
        sender_from_slices_to_cube(imsg) = addressing(CHUNK_AC,iproc_xi_loop,iproc_eta)
      enddo
    endif

! define sender for xi = xi_max edge
    if(iproc_xi == NPROC_XI-1) then
      do iproc_xi_loop = 0,NPROC_XI-1
        imsg = imsg + 1
        sender_from_slices_to_cube(imsg) = addressing(CHUNK_AC_ANTIPODE,iproc_xi_loop,iproc_eta)
      enddo
    endif

! define sender for eta = eta_min edge
    if(iproc_eta == 0) then
      do iproc_xi_loop = 0,NPROC_XI-1
        imsg = imsg + 1
        sender_from_slices_to_cube(imsg) = addressing(CHUNK_BC_ANTIPODE,iproc_xi_loop,NPROC_ETA-1-iproc_xi)
      enddo
    endif

! define sender for eta = eta_max edge
    if(iproc_eta == NPROC_ETA-1) then
      do iproc_xi_loop = 0,NPROC_XI-1
        imsg = imsg + 1
        sender_from_slices_to_cube(imsg) = addressing(CHUNK_BC,iproc_xi_loop,iproc_xi)
      enddo
    endif

! check that total number of faces found is correct
   if(imsg /= nb_msgs_theor_in_cube) call exit_MPI(myrank,'wrong number of faces found for central cube')

  else

! dummy value in slices
    allocate(sender_from_slices_to_cube(1))
    sender_from_slices_to_cube(1) = -1

  endif

! number of points to send or receive (bottom of slices)
  npoin2D_cube_from_slices = NSPEC2D_BOTTOM(IREGION_INNER_CORE) * NGLLX * NGLLY

! allocate buffers for cube and slices
  allocate(buffer_all_cube_from_slices(nb_msgs_theor_in_cube,npoin2D_cube_from_slices,NDIM))
  allocate(buffer_slices(npoin2D_cube_from_slices,NDIM))
  allocate(ibool_central_cube(nb_msgs_theor_in_cube,npoin2D_cube_from_slices))

! on chunk AB, receive all the messages from slices
  if(ichunk == CHUNK_AB) then

   do imsg = 1,nb_msgs_theor_in_cube

! receive buffers from slices
  isender = sender_from_slices_to_cube(imsg)
  call MPI_RECV(buffer_slices, &
              NDIM*npoin2D_cube_from_slices,MPI_DOUBLE_PRECISION,isender, &
              itag,MPI_COMM_WORLD,msg_status,ier)

! copy buffer in 2D array for each slice
   buffer_all_cube_from_slices(imsg,:,:) = buffer_slices(:,:)

   enddo
   endif


! send info to central cube from all the slices except those in CHUNK_AB
  if(ichunk /= CHUNK_AB) then

! for bottom elements in contact with central cube from the slices side
    ipoin = 0
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_INNER_CORE)

      ispec = ibelm_bottom_inner_core(ispec2D)

! only for DOFs exactly on surface of central cube (bottom of these elements)
      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX
          ipoin = ipoin + 1
          iglob = ibool_inner_core(i,j,k,ispec)
          buffer_slices(ipoin,1) = dble(xstore_inner_core(iglob))
          buffer_slices(ipoin,2) = dble(ystore_inner_core(iglob))
          buffer_slices(ipoin,3) = dble(zstore_inner_core(iglob))
        enddo
      enddo
    enddo

! send buffer to central cube
    ireceiver = receiver_cube_from_slices
    call MPI_SEND(buffer_slices,NDIM*npoin2D_cube_from_slices, &
              MPI_DOUBLE_PRECISION,ireceiver,itag,MPI_COMM_WORLD,ier)

 endif  ! end sending info to central cube

!--- now we need to find the points received and create indirect addressing

  if(ichunk == CHUNK_AB) then

   do imsg = 1,nb_msgs_theor_in_cube

   do ipoin = 1,npoin2D_cube_from_slices

     x_target = buffer_all_cube_from_slices(imsg,ipoin,1)
     y_target = buffer_all_cube_from_slices(imsg,ipoin,2)
     z_target = buffer_all_cube_from_slices(imsg,ipoin,3)

! x = x_min

  do ispec2D = 1,nspec2D_xmin_inner_core

      ispec = ibelm_xmin_inner_core(ispec2D)

! do not loop on elements outside of the central cube
     if(idoubling_inner_core(ispec) /= IFLAG_IN_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_BOTTOM_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_TOP_CENTRAL_CUBE) cycle

     i = 1
     do k = 1,NGLLZ
       do j = 1,NGLLY

         iglob = ibool_inner_core(i,j,k,ispec)
         x_current = dble(xstore_inner_core(iglob))
         y_current = dble(ystore_inner_core(iglob))
         z_current = dble(zstore_inner_core(iglob))

! look for matching point
         if(dsqrt((x_current-x_target)**2 + (y_current-y_target)**2 + (z_current-z_target)**2) < SMALLVALTOL) then
           ibool_central_cube(imsg,ipoin) = ibool_inner_core(i,j,k,ispec)
           goto 100
         endif

       enddo
     enddo

   enddo

! x = x_max

  do ispec2D = 1,nspec2D_xmax_inner_core

      ispec = ibelm_xmax_inner_core(ispec2D)

! do not loop on elements outside of the central cube
     if(idoubling_inner_core(ispec) /= IFLAG_IN_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_BOTTOM_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_TOP_CENTRAL_CUBE) cycle

     i = NGLLX
     do k = 1,NGLLZ
       do j = 1,NGLLY

         iglob = ibool_inner_core(i,j,k,ispec)
         x_current = dble(xstore_inner_core(iglob))
         y_current = dble(ystore_inner_core(iglob))
         z_current = dble(zstore_inner_core(iglob))

! look for matching point
         if(dsqrt((x_current-x_target)**2 + (y_current-y_target)**2 + (z_current-z_target)**2) < SMALLVALTOL) then
           ibool_central_cube(imsg,ipoin) = ibool_inner_core(i,j,k,ispec)
           goto 100
         endif

       enddo
     enddo

   enddo

! y = y_min

  do ispec2D = 1,nspec2D_ymin_inner_core

      ispec = ibelm_ymin_inner_core(ispec2D)

! do not loop on elements outside of the central cube
     if(idoubling_inner_core(ispec) /= IFLAG_IN_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_BOTTOM_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_TOP_CENTRAL_CUBE) cycle

     j = 1
     do k = 1,NGLLZ
       do i = 1,NGLLX

         iglob = ibool_inner_core(i,j,k,ispec)
         x_current = dble(xstore_inner_core(iglob))
         y_current = dble(ystore_inner_core(iglob))
         z_current = dble(zstore_inner_core(iglob))

! look for matching point
         if(dsqrt((x_current-x_target)**2 + (y_current-y_target)**2 + (z_current-z_target)**2) < SMALLVALTOL) then
           ibool_central_cube(imsg,ipoin) = ibool_inner_core(i,j,k,ispec)
           goto 100
         endif

       enddo
     enddo

   enddo

! y = y_max

  do ispec2D = 1,nspec2D_ymax_inner_core

      ispec = ibelm_ymax_inner_core(ispec2D)

! do not loop on elements outside of the central cube
     if(idoubling_inner_core(ispec) /= IFLAG_IN_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_BOTTOM_CENTRAL_CUBE .and. &
        idoubling_inner_core(ispec) /= IFLAG_TOP_CENTRAL_CUBE) cycle

     j = NGLLY
     do k = 1,NGLLZ
       do i = 1,NGLLX

         iglob = ibool_inner_core(i,j,k,ispec)
         x_current = dble(xstore_inner_core(iglob))
         y_current = dble(ystore_inner_core(iglob))
         z_current = dble(zstore_inner_core(iglob))

! look for matching point
         if(dsqrt((x_current-x_target)**2 + (y_current-y_target)**2 + (z_current-z_target)**2) < SMALLVALTOL) then
           ibool_central_cube(imsg,ipoin) = ibool_inner_core(i,j,k,ispec)
           goto 100
         endif

       enddo
     enddo

   enddo

! bottom of cube

  do ispec = 1,nspec_inner_core

! loop on elements at the bottom of the cube only
     if(idoubling_inner_core(ispec) /= IFLAG_BOTTOM_CENTRAL_CUBE) cycle

     k = 1
     do j = 1,NGLLY
       do i = 1,NGLLX

         iglob = ibool_inner_core(i,j,k,ispec)
         x_current = dble(xstore_inner_core(iglob))
         y_current = dble(ystore_inner_core(iglob))
         z_current = dble(zstore_inner_core(iglob))

! look for matching point
         if(dsqrt((x_current-x_target)**2 + (y_current-y_target)**2 + (z_current-z_target)**2) < SMALLVALTOL) then
           ibool_central_cube(imsg,ipoin) = ibool_inner_core(i,j,k,ispec)
           goto 100
         endif

       enddo
     enddo

   enddo

! check that a matching point is found in all cases
  call exit_MPI(myrank,'point never found in central cube')

 100 continue

   enddo
   enddo
   endif

!---
!---  now use buffers to assemble mass matrix with central cube once and for all
!---

! on chunk AB, receive all the messages from slices
  if(ichunk == CHUNK_AB) then

   do imsg = 1,nb_msgs_theor_in_cube

! receive buffers from slices
  isender = sender_from_slices_to_cube(imsg)
  call MPI_RECV(buffer_slices, &
              npoin2D_cube_from_slices,MPI_DOUBLE_PRECISION,isender, &
              itag,MPI_COMM_WORLD,msg_status,ier)

! copy buffer in 2D array for each slice
   buffer_all_cube_from_slices(imsg,:,1) = buffer_slices(:,1)

   enddo
   endif


! send info to central cube from all the slices except those in CHUNK_AB
  if(ichunk /= CHUNK_AB) then

! for bottom elements in contact with central cube from the slices side
    ipoin = 0
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_INNER_CORE)

      ispec = ibelm_bottom_inner_core(ispec2D)

! only for DOFs exactly on surface of central cube (bottom of these elements)
      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX
          ipoin = ipoin + 1
          buffer_slices(ipoin,1) = dble(rmass_inner_core(ibool_inner_core(i,j,k,ispec)))
        enddo
      enddo
    enddo

! send buffer to central cube
    ireceiver = receiver_cube_from_slices
    call MPI_SEND(buffer_slices,npoin2D_cube_from_slices, &
              MPI_DOUBLE_PRECISION,ireceiver,itag,MPI_COMM_WORLD,ier)

 endif  ! end sending info to central cube

!--- now we need to assemble the contributions

  if(ichunk == CHUNK_AB) then

! erase contributions to central cube array
   array_central_cube(:) = 0._CUSTOM_REAL

! use indirect addressing to store contributions only once
! distinguish between single and double precision for reals
   do imsg = 1,nb_msgs_theor_in_cube
   do ipoin = 1,npoin2D_cube_from_slices
     if(CUSTOM_REAL == SIZE_REAL) then
       array_central_cube(ibool_central_cube(imsg,ipoin)) = sngl(buffer_all_cube_from_slices(imsg,ipoin,1))
     else
       array_central_cube(ibool_central_cube(imsg,ipoin)) = buffer_all_cube_from_slices(imsg,ipoin,1)
     endif
   enddo
   enddo

! suppress degrees of freedom already assembled at top of cube on edges
  do ispec = 1,nspec_inner_core
    if(idoubling_inner_core(ispec) == IFLAG_TOP_CENTRAL_CUBE) then
      k = NGLLZ
      do j = 1,NGLLY
        do i = 1,NGLLX
          array_central_cube(ibool_inner_core(i,j,k,ispec)) = 0._CUSTOM_REAL
        enddo
      enddo
    endif
  enddo

! assemble contributions
  rmass_inner_core(:) = rmass_inner_core(:) + array_central_cube(:)

! copy sum back
   do imsg = 1,nb_msgs_theor_in_cube
   do ipoin = 1,npoin2D_cube_from_slices
     buffer_all_cube_from_slices(imsg,ipoin,1) = rmass_inner_core(ibool_central_cube(imsg,ipoin))
   enddo
   enddo

   endif


!----------

! receive info from central cube on all the slices except those in CHUNK_AB
  if(ichunk /= CHUNK_AB) then

! receive buffers from slices
  isender = receiver_cube_from_slices
  call MPI_RECV(buffer_slices, &
              npoin2D_cube_from_slices,MPI_DOUBLE_PRECISION,isender, &
              itag,MPI_COMM_WORLD,msg_status,ier)

! for bottom elements in contact with central cube from the slices side
    ipoin = 0
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_INNER_CORE)

      ispec = ibelm_bottom_inner_core(ispec2D)

! only for DOFs exactly on surface of central cube (bottom of these elements)
      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX
          ipoin = ipoin + 1

! distinguish between single and double precision for reals
          if(CUSTOM_REAL == SIZE_REAL) then
            rmass_inner_core(ibool_inner_core(i,j,k,ispec)) = sngl(buffer_slices(ipoin,1))
          else
            rmass_inner_core(ibool_inner_core(i,j,k,ispec)) = buffer_slices(ipoin,1)
          endif

        enddo
      enddo
    enddo

 endif  ! end receiving info from central cube

!------- send info back from central cube to slices

! on chunk AB, send all the messages to slices
  if(ichunk == CHUNK_AB) then

   do imsg = 1,nb_msgs_theor_in_cube

! copy buffer in 2D array for each slice
   buffer_slices(:,1) = buffer_all_cube_from_slices(imsg,:,1)

! send buffers to slices
    ireceiver = sender_from_slices_to_cube(imsg)
    call MPI_SEND(buffer_slices,npoin2D_cube_from_slices, &
              MPI_DOUBLE_PRECISION,ireceiver,itag,MPI_COMM_WORLD,ier)

   enddo
   endif

  if(myrank == 0) write(IMAIN,*) 'done including central cube'
  endif   ! end of assembling mass matrix for matching with central cube


! suppress fictitious mass matrix elements in central cube
  if(INCLUDE_CENTRAL_CUBE) where(rmass_inner_core(:) <= 0.) rmass_inner_core = 1.

! check that mass matrix is positive
  if((OCEANS .and. minval(rmass_ocean_load(1:nglob_crust_mantle)) <= 0.) .or. &
     minval(rmass_crust_mantle(1:nglob_crust_mantle)) <= 0. .or. &
     (minval(rmass_inner_core) <= 0. .or. &
     minval(rmass_outer_core(1:nglob_outer_core)) <= 0.)) &
       call exit_MPI(myrank,'negative mass matrix term')

! for efficiency, invert final mass matrix once and for all on each slice
  if(OCEANS) rmass_ocean_load(1:nglob_crust_mantle) = 1. / rmass_ocean_load(1:nglob_crust_mantle)
  rmass_crust_mantle(1:nglob_crust_mantle) = 1. / rmass_crust_mantle(1:nglob_crust_mantle)
  rmass_outer_core(1:nglob_outer_core) = 1. / rmass_outer_core(1:nglob_outer_core)
  rmass_inner_core(:) = 1. / rmass_inner_core(:)

! change x, y, z to r, theta and phi once and for all
! IMPROVE dangerous: old name kept (xstore ystore zstore) for new values

! convert in the crust and mantle
    do iglob = 1,nglob_crust_mantle
      call xyz_2_rthetaphi(xstore_crust_mantle(iglob), &
    ystore_crust_mantle(iglob),zstore_crust_mantle(iglob),rval,thetaval,phival)
      xstore_crust_mantle(iglob) = rval
      ystore_crust_mantle(iglob) = thetaval
      zstore_crust_mantle(iglob) = phival
    enddo

! convert in the outer core
    do iglob = 1,nglob_outer_core
      call xyz_2_rthetaphi(xstore_outer_core(iglob), &
    ystore_outer_core(iglob),zstore_outer_core(iglob),rval,thetaval,phival)
      xstore_outer_core(iglob) = rval
      ystore_outer_core(iglob) = thetaval
      zstore_outer_core(iglob) = phival
    enddo

! convert in the inner core
    do iglob = 1,nglob_inner_core
      call xyz_2_rthetaphi(xstore_inner_core(iglob), &
    ystore_inner_core(iglob),zstore_inner_core(iglob),rval,thetaval,phival)
      xstore_inner_core(iglob) = rval
      ystore_inner_core(iglob) = thetaval
      zstore_inner_core(iglob) = phival
    enddo

! if attenuation is on, shift PREM to right frequency
! rescale mu in PREM to average frequency for attenuation

  if(ATTENUATION) then

! get and store PREM attenuation model

! ATTENUATION_3D get values from mesher
     if(ATTENUATION_3D) then
        ! CRUST_MANTLE ATTENUATION
        call create_name_database(prname, myrank, IREGION_CRUST_MANTLE, LOCAL_PATH)
        call get_attenuation_model_3D(myrank, prname, omsb_crust_mantle_dble, &
             factor_common_crust_mantle_dble, factor_scale_crust_mantle_dble, tau_sigma_dble, nspec_crust_mantle)
        ! INNER_CORE ATTENUATION
        call create_name_database(prname, myrank, IREGION_INNER_CORE, LOCAL_PATH)
        call get_attenuation_model_3D(myrank, prname, omsb_inner_core_dble, &
             factor_common_inner_core_dble, factor_scale_inner_core_dble, tau_sigma_dble, nspec_inner_core)
     else

    do iregion_attenuation = 1,NUM_REGIONS_ATTENUATION
      call get_attenuation_model(myrank,iregion_attenuation,MIN_ATTENUATION_PERIOD,MAX_ATTENUATION_PERIOD,tau_mu_dble, &
        tau_sigma_dble,beta_dble,one_minus_sum_beta_dble,factor_scale_dble)

      tauinv(:) = -1.0 / tau_sigma_dble(:)
      if(iregion_attenuation .EQ. IREGION_ATTENUATION_INNER_CORE) then
         factor_common_inner_core_dble(:,1,1,1,1) = 2.0 * beta_dble(:) * tauinv(:)
      endif
      factor_common_crust_mantle_dble(:,1,1,1,iregion_attenuation) = 2.0 * beta_dble(:) * tauinv(:)

      if(iregion_attenuation .EQ. IREGION_ATTENUATION_INNER_CORE) then
         factor_scale_inner_core_dble(1,1,1,1) = factor_scale_dble
         omsb_inner_core_dble(1,1,1,1) = one_minus_sum_beta_dble
      endif
      factor_scale_crust_mantle_dble(1,1,1,iregion_attenuation) = factor_scale_dble
      omsb_crust_mantle_dble(1,1,1,iregion_attenuation) = one_minus_sum_beta_dble

   enddo ! iregion_attenuation = 1, NUM_REGIONS_ATTENUATION

   endif ! ATTENUATION_3D

   if(CUSTOM_REAL == SIZE_REAL) then
      factor_scale_crust_mantle       = sngl(factor_scale_crust_mantle_dble)
      one_minus_sum_beta_crust_mantle = sngl(omsb_crust_mantle_dble)
      factor_common_crust_mantle      = sngl(factor_common_crust_mantle_dble)

      factor_scale_inner_core         = sngl(factor_scale_inner_core_dble)
      one_minus_sum_beta_inner_core   = sngl(omsb_inner_core_dble)
      factor_common_inner_core        = sngl(factor_common_inner_core_dble)
   else
      factor_scale_crust_mantle       = factor_scale_crust_mantle_dble
      one_minus_sum_beta_crust_mantle = omsb_crust_mantle_dble
      factor_common_crust_mantle      = factor_common_crust_mantle_dble

      factor_scale_inner_core         = factor_scale_inner_core_dble
      one_minus_sum_beta_inner_core   = omsb_inner_core_dble
      factor_common_inner_core        = factor_common_inner_core_dble
   endif

   deallocate(factor_scale_crust_mantle_dble)
   deallocate(omsb_crust_mantle_dble)
   deallocate(factor_common_crust_mantle_dble)

   deallocate(factor_scale_inner_core_dble)
   deallocate(omsb_inner_core_dble)
   deallocate(factor_common_inner_core_dble)

! rescale in crust and mantle

    do ispec = 1,nspec_crust_mantle
      do k=1,NGLLZ
        do j=1,NGLLY
          do i=1,NGLLX

! ATTENUATION_3D get scale_factor
             if(ATTENUATION_3D) then
                ! tau_mu and tau_sigma need to reference a point in the mesh
                scale_factor = factor_scale_crust_mantle(i,j,k,ispec)
             else

  if(idoubling_crust_mantle(ispec) == IFLAG_DOUBLING_670 .or. &
     idoubling_crust_mantle(ispec) == IFLAG_MANTLE_NORMAL .or. &
     idoubling_crust_mantle(ispec) == IFLAG_BOTTOM_MANTLE) then

     scale_factor = factor_scale_crust_mantle(1,1,1,IREGION_ATTENUATION_CMB_670)

  else if(idoubling_crust_mantle(ispec) == IFLAG_670_220) then

     scale_factor = factor_scale_crust_mantle(1,1,1,IREGION_ATTENUATION_670_220)

  else if(idoubling_crust_mantle(ispec) == IFLAG_220_MOHO .or. idoubling_crust_mantle(ispec) == IFLAG_CRUST) then

! special case of d80 which is not honored by the mesh
! xstore contains the radius
    iglob = ibool_crust_mantle(i,j,k,ispec)
    dist = xstore_crust_mantle(iglob)

! map ellipticity back for d80 detection
! ystore contains theta
    if(ELLIPTICITY) then
      theta = ystore_crust_mantle(iglob)
      cost = cos(theta)
      p20 = 0.5*(3.*cost*cost-1.)
      dist = dist*(1.+(2./3.)*ell_d80*p20)
    endif

    if(dist > R80/R_EARTH) then
      scale_factor = factor_scale_crust_mantle(1,1,1,IREGION_ATTENUATION_80_SURFACE)
    else
      scale_factor = factor_scale_crust_mantle(1,1,1,IREGION_ATTENUATION_220_80)
    endif

  else

    call exit_MPI(myrank,'wrong attenuation doubling flag')

  endif

  endif ! ATTENUATION_3D

    if(ANISOTROPIC_3D_MANTLE) then
      scale_factor_minus_one = scale_factor - 1.
      mul = c44store_crust_mantle(i,j,k,ispec)
      c11store_crust_mantle(i,j,k,ispec) = c11store_crust_mantle(i,j,k,ispec) &
              + FOUR_THIRDS * scale_factor_minus_one * mul
      c12store_crust_mantle(i,j,k,ispec) = c12store_crust_mantle(i,j,k,ispec) &
              - TWO_THIRDS * scale_factor_minus_one * mul
      c13store_crust_mantle(i,j,k,ispec) = c13store_crust_mantle(i,j,k,ispec) &
              - TWO_THIRDS * scale_factor_minus_one * mul
      c22store_crust_mantle(i,j,k,ispec) = c22store_crust_mantle(i,j,k,ispec) &
              + FOUR_THIRDS * scale_factor_minus_one * mul
      c23store_crust_mantle(i,j,k,ispec) = c23store_crust_mantle(i,j,k,ispec) &
              - TWO_THIRDS * scale_factor_minus_one * mul
      c33store_crust_mantle(i,j,k,ispec) = c33store_crust_mantle(i,j,k,ispec) &
              + FOUR_THIRDS * scale_factor_minus_one * mul
      c44store_crust_mantle(i,j,k,ispec) = c44store_crust_mantle(i,j,k,ispec) &
              + scale_factor_minus_one * mul
      c55store_crust_mantle(i,j,k,ispec) = c55store_crust_mantle(i,j,k,ispec) &
              + scale_factor_minus_one * mul
      c66store_crust_mantle(i,j,k,ispec) = c66store_crust_mantle(i,j,k,ispec) &
              + scale_factor_minus_one * mul
    else
      muvstore_crust_mantle(i,j,k,ispec) = muvstore_crust_mantle(i,j,k,ispec) * scale_factor
      if(TRANSVERSE_ISOTROPY .and. idoubling_crust_mantle(ispec) == IFLAG_220_MOHO) &
        muhstore_crust_mantle(i,j,k,ispec) = muhstore_crust_mantle(i,j,k,ispec) * scale_factor
    endif

          enddo
        enddo
      enddo
    enddo ! END DO CRUST MANTLE

! rescale in inner core
    if(.not. ATTENUATION_3D) scale_factor_minus_one = factor_scale_inner_core(1,1,1,1) - 1.

    do ispec = 1,nspec_inner_core
      do k=1,NGLLZ
        do j=1,NGLLY
          do i=1,NGLLX

            if(ATTENUATION_3D) scale_factor_minus_one = factor_scale_inner_core(i,j,k,ispec) - 1.0

        if(ANISOTROPIC_INNER_CORE) then
          mul = muvstore_inner_core(i,j,k,ispec)
          c11store_inner_core(i,j,k,ispec) = c11store_inner_core(i,j,k,ispec) &
                  + FOUR_THIRDS * scale_factor_minus_one * mul
          c12store_inner_core(i,j,k,ispec) = c12store_inner_core(i,j,k,ispec) &
                  - TWO_THIRDS * scale_factor_minus_one * mul
          c13store_inner_core(i,j,k,ispec) = c13store_inner_core(i,j,k,ispec) &
                  - TWO_THIRDS * scale_factor_minus_one * mul
          c33store_inner_core(i,j,k,ispec) = c33store_inner_core(i,j,k,ispec) &
                  + FOUR_THIRDS * scale_factor_minus_one * mul
          c44store_inner_core(i,j,k,ispec) = c44store_inner_core(i,j,k,ispec) &
                  + scale_factor_minus_one * mul
        endif

            if(ATTENUATION_3D) then
               muvstore_inner_core(i,j,k,ispec) = muvstore_inner_core(i,j,k,ispec) * factor_scale_inner_core(i,j,k,ispec)
            else
               muvstore_inner_core(i,j,k,ispec) = muvstore_inner_core(i,j,k,ispec) * factor_scale_inner_core(1,1,1,1)
            endif

          enddo
        enddo
      enddo
    enddo ! END DO INNER CORE

! deallocate arrays
    deallocate(factor_scale_crust_mantle)
    deallocate(factor_scale_inner_core)

  endif ! END IF(ATTENUATION)

! initialize arrays to zero

  displ_crust_mantle(:,:) = 0._CUSTOM_REAL
  veloc_crust_mantle(:,:) = 0._CUSTOM_REAL
  accel_crust_mantle(:,:) = 0._CUSTOM_REAL

  displ_outer_core(:) = 0._CUSTOM_REAL
  veloc_outer_core(:) = 0._CUSTOM_REAL
  accel_outer_core(:) = 0._CUSTOM_REAL

  displ_inner_core(:,:) = 0._CUSTOM_REAL
  veloc_inner_core(:,:) = 0._CUSTOM_REAL
  accel_inner_core(:,:) = 0._CUSTOM_REAL

! put negligible initial value to avoid very slow underflow trapping
  if(FIX_UNDERFLOW_PROBLEM) then
    displ_crust_mantle(:,:) = VERYSMALLVAL
    displ_outer_core(:) = VERYSMALLVAL
    displ_inner_core(:,:) = VERYSMALLVAL
  endif

! store g, rho and dg/dr=dg using normalized radius in lookup table every 100 m
! get density and velocity from PREM model using dummy doubling flag
! this assumes that the gravity perturbations are small and smooth
! and that we can neglect the 3D model and use PREM every 100 m in all cases
! this is probably a rather reasonable assumption
  if(GRAVITY) then
    call make_gravity(nspl_gravity,rspl_gravity,gspl,gspl2,ONE_CRUST,RICB,RCMB, &
      RTOPDDOUBLEPRIME,R600,R670,R220,R771,R400,R80,RMOHO,RMIDDLE_CRUST)
    do int_radius = 1,NRAD_GRAVITY
      radius = dble(int_radius) / (R_EARTH_KM * 10.d0)
      call splint(rspl_gravity,gspl,gspl2,nspl_gravity,radius,g)
      idoubling = 0
      call prem_iso(myrank,radius,rho,vp,vs,Qkappa,Qmu,idoubling,.false., &
        ONE_CRUST,.false.,IASPEI,RICB,RCMB,RTOPDDOUBLEPRIME, &
        R600,R670,R220,R771,R400,R80,RMOHO,RMIDDLE_CRUST,ROCEAN)
      dg = 4.0d0*rho - 2.0d0*g/radius
      minus_gravity_table(int_radius) = - g
      minus_deriv_gravity_table(int_radius) = - dg
      density_table(int_radius) = rho
      minus_rho_g_over_kappa_fluid(int_radius) = - g / vp**2
    enddo

! make sure fluid array is only assigned in outer core between 1222 and 3478 km
! lookup table is defined every 100 m
    do int_radius = 1,NRAD_GRAVITY
      radius_km = dble(int_radius) / 10.d0
      if(radius_km > RCMB/1000.d0 - 3.d0) &
        minus_rho_g_over_kappa_fluid(int_radius) = minus_rho_g_over_kappa_fluid(nint((RCMB/1000.d0 - 3.d0)*10.d0))
      if(radius_km < RICB/1000.d0 + 3.d0) &
        minus_rho_g_over_kappa_fluid(int_radius) = minus_rho_g_over_kappa_fluid(nint((RICB/1000.d0 + 3.d0)*10.d0))
    enddo

! compute gravity value at CMB and ICB once and for all
    radius = RCMB / R_EARTH
    call splint(rspl_gravity,gspl,gspl2,nspl_gravity,radius,g_cmb_dble)

    radius = RICB / R_EARTH
    call splint(rspl_gravity,gspl,gspl2,nspl_gravity,radius,g_icb_dble)

! distinguish between single and double precision for reals
    if(CUSTOM_REAL == SIZE_REAL) then
      minus_g_cmb = sngl(- g_cmb_dble)
      minus_g_icb = sngl(- g_icb_dble)
    else
      minus_g_cmb = - g_cmb_dble
      minus_g_icb = - g_icb_dble
    endif

   endif

! synchronize all processes to make sure everybody is ready to start time loop
  call MPI_BARRIER(MPI_COMM_WORLD,ier)
  if(myrank == 0) write(IMAIN,*) 'All processes are synchronized before time loop'

! allocate files to save movies
  if(MOVIE_SURFACE) then
    allocate(store_val_x(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE)))
    allocate(store_val_y(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE)))
    allocate(store_val_z(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE)))
    allocate(store_val_ux(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE)))
    allocate(store_val_uy(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE)))
    allocate(store_val_uz(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE)))

    allocate(store_val_x_all(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE),0:NPROCTOT-1))
    allocate(store_val_y_all(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE),0:NPROCTOT-1))
    allocate(store_val_z_all(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE),0:NPROCTOT-1))
    allocate(store_val_ux_all(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE),0:NPROCTOT-1))
    allocate(store_val_uy_all(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE),0:NPROCTOT-1))
    allocate(store_val_uz_all(NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE),0:NPROCTOT-1))
  endif

!
!   s t a r t   t i m e   i t e r a t i o n s
!

  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) '           time step: ',sngl(DT),' s'
    write(IMAIN,*) 'number of time steps: ',NSTEP
    write(IMAIN,*) 'total simulated time: ',sngl(((NSTEP-1)*DT-t0)/60.d0),' minutes'
    write(IMAIN,*) 'start time:',sngl(-t0),' seconds'
    write(IMAIN,*)
  endif

! define constants for the time integration
! scaling to make displacement in meters
  scale_t = ONE/dsqrt(PI*GRAV*RHOAV)
  scale_displ = R_EARTH

! distinguish between single and double precision for reals
  if(CUSTOM_REAL == SIZE_REAL) then
    deltat = sngl(DT/scale_t)
    deltatover2 = sngl(0.5d0*DT/scale_t)
    deltatsqover2 = sngl(0.5d0*DT*DT/(scale_t*scale_t))
  else
    deltat = DT/scale_t
    deltatover2 = 0.5d0*DT/scale_t
    deltatsqover2 = 0.5d0*DT*DT/(scale_t*scale_t)
  endif

! non-dimensionalized rotation rate of the Earth times two
  if(ROTATION) then
! distinguish between single and double precision for reals
    if(CUSTOM_REAL == SIZE_REAL) then
      two_omega_earth = sngl(2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t))
    else
      two_omega_earth = 2.d0 * TWO_PI / (HOURS_PER_DAY * 3600.d0 / scale_t)
    endif
  else
    two_omega_earth = 0._CUSTOM_REAL
  endif

! precompute Runge-Kutta coefficients if attenuation
  if(ATTENUATION) then
     call attenuation_memory_values(tau_sigma_dble, deltat, alphaval_dble, betaval_dble, gammaval_dble)
     if(CUSTOM_REAL == SIZE_REAL) then
        alphaval = sngl(alphaval_dble)
        betaval  = sngl(betaval_dble)
        gammaval = sngl(gammaval_dble)
     else
        alphaval = alphaval_dble
        betaval  = betaval_dble
        gammaval = gammaval_dble
     endif
  endif

  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'Starting time iteration loop...'
    write(IMAIN,*)
  endif

! create an empty file to monitor the start of the simulation
  if(myrank == 0) then
    open(unit=IOUT,file='OUTPUT_FILES/starttimeloop.txt',status='unknown')
    write(IOUT,*) 'hello, starting time loop'
    close(IOUT)
  endif

! clear memory variables if attenuation
  if(ATTENUATION) then
    R_memory_crust_mantle(:,:,:,:,:,:) = 0._CUSTOM_REAL
    R_memory_inner_core(:,:,:,:,:,:) = 0._CUSTOM_REAL

    epsilondev_crust_mantle(:,:,:,:,:) = 0._CUSTOM_REAL
    epsilondev_inner_core(:,:,:,:,:) = 0._CUSTOM_REAL

    if(FIX_UNDERFLOW_PROBLEM) then
      R_memory_crust_mantle(:,:,:,:,:,:) = VERYSMALLVAL
      R_memory_inner_core(:,:,:,:,:,:) = VERYSMALLVAL

      epsilondev_crust_mantle(:,:,:,:,:) = VERYSMALLVAL
      epsilondev_inner_core(:,:,:,:,:) = VERYSMALLVAL
    endif

  endif

! get MPI starting time
  time_start = MPI_WTIME()

! *********************************************************
! ************* MAIN LOOP OVER THE TIME STEPS *************
! *********************************************************

! define correct time steps if restart files
  if(NUMBER_OF_RUNS < 1 .or. NUMBER_OF_RUNS > 3) stop 'number of restart runs can be 1, 2 or 3'
  if(NUMBER_OF_THIS_RUN < 1 .or. NUMBER_OF_THIS_RUN > NUMBER_OF_RUNS) stop 'incorrect run number'

  if(NUMBER_OF_RUNS == 3) then
    if(NUMBER_OF_THIS_RUN == 1) then
      it_begin = 1
      it_end = NSTEP/3
    else if(NUMBER_OF_THIS_RUN == 2) then
      it_begin = NSTEP/3 + 1
      it_end = 2*(NSTEP/3)
    else
      it_begin = 2*(NSTEP/3) + 1
      it_end = NSTEP
    endif

  else if(NUMBER_OF_RUNS == 2) then
    if(NUMBER_OF_THIS_RUN == 1) then
      it_begin = 1
      it_end = NSTEP/2
    else
      it_begin = NSTEP/2 + 1
      it_end = NSTEP
    endif

  else
    it_begin = 1
    it_end = NSTEP
  endif

! suppress white spaces if any
  clean_LOCAL_PATH = adjustl(LOCAL_PATH)

! create full final local path
  final_LOCAL_PATH = clean_LOCAL_PATH(1:len_trim(clean_LOCAL_PATH)) // '/'

! read files back from local disk or MT tape system if restart file
  if(NUMBER_OF_THIS_RUN > 1) then
    write(outputname,"('dump_all_arrays',i4.4)") myrank
    open(unit=55,file=final_LOCAL_PATH(1:len_trim(final_LOCAL_PATH))//outputname,status='old',form='unformatted')
    read(55) displ_crust_mantle
    read(55) veloc_crust_mantle
    read(55) accel_crust_mantle
    read(55) displ_inner_core
    read(55) veloc_inner_core
    read(55) accel_inner_core
    read(55) displ_outer_core
    read(55) veloc_outer_core
    read(55) accel_outer_core
    read(55) R_memory_crust_mantle
    read(55) R_memory_inner_core
    read(55) epsilondev_crust_mantle
    read(55) epsilondev_inner_core
    read(55) A_array_rotation
    read(55) B_array_rotation
    close(55)
  endif

! PvK Initialize movie parameter (needs to be moved to constants.h)
  ifirst_movie=.true.
  IOUT_COORD=21
  IOUT_TOPOLOGY=22

  do it=it_begin,it_end

! compute predictors

! mantle
  do i=1,nglob_crust_mantle
    displ_crust_mantle(:,i) = displ_crust_mantle(:,i) + deltat*veloc_crust_mantle(:,i) + deltatsqover2*accel_crust_mantle(:,i)
    veloc_crust_mantle(:,i) = veloc_crust_mantle(:,i) + deltatover2*accel_crust_mantle(:,i)
  enddo

! outer core
  do i=1,nglob_outer_core
    displ_outer_core(i) = displ_outer_core(i) + deltat*veloc_outer_core(i) + deltatsqover2*accel_outer_core(i)
    veloc_outer_core(i) = veloc_outer_core(i) + deltatover2*accel_outer_core(i)
  enddo

! inner core
  do i=1,nglob_inner_core
    displ_inner_core(:,i) = displ_inner_core(:,i) + deltat*veloc_inner_core(:,i) + deltatsqover2*accel_inner_core(:,i)
    veloc_inner_core(:,i) = veloc_inner_core(:,i) + deltatover2*accel_inner_core(:,i)
  enddo

! compute the maximum of the norm of the displacement
! in all the slices using an MPI reduction
! and output timestamp file to check that simulation is running fine
  if(mod(it,NTSTEP_BETWEEN_OUTPUT_INFO) == 0 .or. it == 5) then

! compute maximum of norm of displacement in each slice
    Usolidnorm = max( &
        maxval(sqrt(displ_crust_mantle(1,1:nglob_crust_mantle)**2 + &
          displ_crust_mantle(2,1:nglob_crust_mantle)**2 + displ_crust_mantle(3,1:nglob_crust_mantle)**2)), &
        maxval(sqrt(displ_inner_core(1,:)**2 + displ_inner_core(2,:)**2 + displ_inner_core(3,:)**2)))

    Ufluidnorm = maxval(abs(displ_outer_core(1:nglob_outer_core)))

! compute the maximum of the maxima for all the slices using an MPI reduction
    call MPI_REDUCE(Usolidnorm,Usolidnorm_all,1,CUSTOM_MPI_TYPE,MPI_MAX,0, &
                          MPI_COMM_WORLD,ier)
    call MPI_REDUCE(Ufluidnorm,Ufluidnorm_all,1,CUSTOM_MPI_TYPE,MPI_MAX,0, &
                          MPI_COMM_WORLD,ier)

    if(myrank == 0) then

      write(IMAIN,*) 'Time step # ',it
      write(IMAIN,*) 'Time: ',sngl(((it-1)*DT-t0)/60.d0),' minutes'

! elapsed time since beginning of the simulation
      tCPU = MPI_WTIME() - time_start
      int_tCPU = int(tCPU)
      ihours = int_tCPU / 3600
      iminutes = (int_tCPU - 3600*ihours) / 60
      iseconds = int_tCPU - 3600*ihours - 60*iminutes
      write(IMAIN,*) 'Elapsed time in seconds = ',tCPU
      write(IMAIN,"(' Elapsed time in hh:mm:ss = ',i4,' h ',i2.2,' m ',i2.2,' s')") ihours,iminutes,iseconds
      write(IMAIN,*) 'Mean elapsed time per time step in seconds = ',tCPU/dble(it)

! rescale maximum displacement to correct dimensions
      Usolidnorm_all = Usolidnorm_all * sngl(scale_displ)
      write(IMAIN,*) 'Max norm displacement vector U in solid in all slices (m) = ',Usolidnorm_all
      write(IMAIN,*) 'Max non-dimensional potential Ufluid in fluid in all slices = ',Ufluidnorm_all
      write(IMAIN,*)

! write time stamp file to give information about progression of simulation
      write(outputname,"('OUTPUT_FILES/timestamp',i6.6)") it
      open(unit=IOUT,file=outputname,status='unknown')
      write(IOUT,*) 'Time step # ',it
      write(IOUT,*) 'Time: ',sngl(((it-1)*DT-t0)/60.d0),' minutes'
      write(IOUT,*) 'Elapsed time in seconds = ',tCPU
      write(IOUT,"(' Elapsed time in hh:mm:ss = ',i4,' h ',i2.2,' m ',i2.2,' s')") ihours,iminutes,iseconds
      write(IOUT,*) 'Mean elapsed time per time step in seconds = ',tCPU/dble(it)
      write(IOUT,*) 'Max norm displacement vector U in solid in all slices (m) = ',Usolidnorm_all
      write(IOUT,*) 'Max non-dimensional potential Ufluid in fluid in all slices = ',Ufluidnorm_all
      close(IOUT)

! check stability of the code, exit if unstable
      if(Usolidnorm_all > STABILITY_THRESHOLD) call exit_MPI(myrank,'code became unstable and blew up in solid')
      if(Ufluidnorm_all > STABILITY_THRESHOLD) call exit_MPI(myrank,'code became unstable and blew up in fluid')
    endif
  endif

! ****************************************************
!   big loop over all spectral elements in the fluid
! ****************************************************

! compute internal forces in the fluid region
  if(CUSTOM_REAL == SIZE_REAL) then
    time = sngl((dble(it-1)*DT-t0)/scale_t)
  else
    time = (dble(it-1)*DT-t0)/scale_t
  endif

  call compute_forces_outer_core(time,deltat,two_omega_earth, &
         A_array_rotation,B_array_rotation, &
         minus_rho_g_over_kappa_fluid,displ_outer_core,accel_outer_core, &
         xstore_outer_core,ystore_outer_core,zstore_outer_core, &
         xix_outer_core,xiy_outer_core,xiz_outer_core, &
         etax_outer_core,etay_outer_core,etaz_outer_core, &
         gammax_outer_core,gammay_outer_core,gammaz_outer_core, &
         jacobian_outer_core,hprime_xx,hprime_yy,hprime_zz, &
         hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
         wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube, &
         ibool_outer_core,nspec_outer_core,nglob_outer_core, &
         NSPECMAX_OUTER_CORE_ROTATION,GRAVITY,ROTATION)

! Stacey
  if(NCHUNKS /= 6 .and. ABSORBING_CONDITIONS) then

!   xmin
! if two chunks exclude this face for one of them
  if(NCHUNKS == 1 .or. ichunk == CHUNK_AC) then

    do ispec2D=1,nspec2D_xmin_outer_core

      ispec=ibelm_xmin_outer_core(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_xi_outer_core(1,ispec2D) == 0 .or. njmin_outer_core(1,ispec2D) == 0) cycle

      i=1
      do k=nkmin_xi_outer_core(1,ispec2D),NGLLZ
        do j=njmin_outer_core(1,ispec2D),njmax_outer_core(1,ispec2D)
          iglob=ibool_outer_core(i,j,k,ispec)

          sn = veloc_outer_core(iglob)/vp_outer_core(i,j,k,ispec)

          weight = jacobian2D_xmin_outer_core(j,k,ispec2D)*wgllwgll_yz(j,k)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn
        enddo
      enddo
    enddo
  endif

!   xmax
! if two chunks exclude this face for one of them
  if(NCHUNKS == 1 .or. ichunk == CHUNK_AB) then
    do ispec2D=1,nspec2D_xmax_outer_core

      ispec=ibelm_xmax_outer_core(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_xi_outer_core(2,ispec2D) == 0 .or. njmin_outer_core(2,ispec2D) == 0) cycle

      i=NGLLX
      do k=nkmin_xi_outer_core(2,ispec2D),NGLLZ
        do j=njmin_outer_core(2,ispec2D),njmax_outer_core(2,ispec2D)
          iglob=ibool_outer_core(i,j,k,ispec)

          sn = veloc_outer_core(iglob)/vp_outer_core(i,j,k,ispec)

          weight = jacobian2D_xmax_outer_core(j,k,ispec2D)*wgllwgll_yz(j,k)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn
        enddo
      enddo
    enddo
  endif

!   ymin
    do ispec2D=1,nspec2D_ymin_outer_core

      ispec=ibelm_ymin_outer_core(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_eta_outer_core(1,ispec2D) == 0 .or. nimin_outer_core(1,ispec2D) == 0) cycle

      j=1
      do k=nkmin_eta_outer_core(1,ispec2D),NGLLZ
        do i=nimin_outer_core(1,ispec2D),nimax_outer_core(1,ispec2D)
          iglob=ibool_outer_core(i,j,k,ispec)

          sn = veloc_outer_core(iglob)/vp_outer_core(i,j,k,ispec)

          weight=jacobian2D_ymin_outer_core(i,k,ispec2D)*wgllwgll_xz(i,k)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn
        enddo
      enddo
    enddo

!   ymax
    do ispec2D=1,nspec2D_ymax_outer_core

      ispec=ibelm_ymax_outer_core(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_eta_outer_core(2,ispec2D) == 0 .or. nimin_outer_core(2,ispec2D) == 0) cycle

      j=NGLLY
      do k=nkmin_eta_outer_core(2,ispec2D),NGLLZ
        do i=nimin_outer_core(2,ispec2D),nimax_outer_core(2,ispec2D)
          iglob=ibool_outer_core(i,j,k,ispec)

          sn = veloc_outer_core(iglob)/vp_outer_core(i,j,k,ispec)

          weight=jacobian2D_ymax_outer_core(i,k,ispec2D)*wgllwgll_xz(i,k)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn
        enddo
      enddo
    enddo

! for surface elements exactly on the ICB
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)

      ispec = ibelm_bottom_outer_core(ispec2D)

      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX
          iglob = ibool_outer_core(i,j,k,ispec)

          sn = veloc_outer_core(iglob)/vp_outer_core(i,j,k,ispec)

          weight = jacobian2D_bottom_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*sn

        enddo
      enddo
    enddo

  endif ! Stacey conditions


! ****************************************************
! **********  add matching with solid part  **********
! ****************************************************

! only for elements in first matching layer in the fluid

!---
!--- couple with mantle at the top of the outer core
!---

  if(ACTUALLY_COUPLE_FLUID_CMB) then

! for surface elements exactly on the CMB
    do ispec2D = 1,NSPEC2D_TOP(IREGION_OUTER_CORE)
      ispec = ibelm_top_outer_core(ispec2D)

! only for DOFs exactly on the CMB (top of these elements)
      k = NGLLZ
      do j = 1,NGLLY
        do i = 1,NGLLX

! get velocity on the solid side using pointwise matching
          ispec_selected = ibelm_bottom_crust_mantle(ispec2D)

! corresponding points are located at the bottom of the mantle
          k_corresp = 1
          iglob = ibool_crust_mantle(i,j,k_corresp,ispec_selected)

          vx = displ_crust_mantle(1,iglob)
          vy = displ_crust_mantle(2,iglob)
          vz = displ_crust_mantle(3,iglob)

! get global point number
          iglob = ibool_outer_core(i,j,k,ispec)

! get normal on the CMB
          nx = normal_top_outer_core(1,i,j,ispec2D)
          ny = normal_top_outer_core(2,i,j,ispec2D)
          nz = normal_top_outer_core(3,i,j,ispec2D)

! compute dot product
          vn = vx*nx+vy*ny+vz*nz

! formulation with generalized potential
          weight = jacobian2D_top_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel_outer_core(iglob) = accel_outer_core(iglob) + weight*vn

        enddo
      enddo
    enddo

    endif

!---
!--- couple with inner core at the bottom of the outer core
!---

  if(ACTUALLY_COUPLE_FLUID_ICB .and. NCHUNKS == 6) then

! for surface elements exactly on the ICB
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_OUTER_CORE)
      ispec = ibelm_bottom_outer_core(ispec2D)

! only for DOFs exactly on the ICB (bottom of these elements)
      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX

! get velocity on the solid side using pointwise matching
          ispec_selected = ibelm_top_inner_core(ispec2D)

! corresponding points are located at the bottom of the mantle
          k_corresp = NGLLZ
          iglob = ibool_inner_core(i,j,k_corresp,ispec_selected)

          vx = displ_inner_core(1,iglob)
          vy = displ_inner_core(2,iglob)
          vz = displ_inner_core(3,iglob)

! get global point number
          iglob = ibool_outer_core(i,j,k,ispec)

! get normal on the ICB
          nx = normal_bottom_outer_core(1,i,j,ispec2D)
          ny = normal_bottom_outer_core(2,i,j,ispec2D)
          nz = normal_bottom_outer_core(3,i,j,ispec2D)

! compute dot product
          vn = vx*nx+vy*ny+vz*nz

! formulation with generalized potential
          weight = jacobian2D_bottom_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel_outer_core(iglob) = accel_outer_core(iglob) - weight*vn

        enddo
      enddo
    enddo

  endif

! assemble all the contributions between slices using MPI

! outer core
  call assemble_MPI_scalar(myrank,accel_outer_core,nglob_outer_core, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_outer_core,iboolright_xi_outer_core,iboolleft_eta_outer_core,iboolright_eta_outer_core, &
            npoin2D_faces_outer_core,npoin2D_xi_outer_core,npoin2D_eta_outer_core, &
            iboolfaces_outer_core,iboolcorner_outer_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
            buffer_send_faces_scalar,buffer_received_faces_scalar, &
            buffer_send_chunkcorners_scalar,buffer_recv_chunkcorners_scalar, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_OUTER_CORE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_OUTER_CORE),NPOIN2DMAX_YMIN_YMAX(IREGION_OUTER_CORE),NPOIN2DMAX_XY,NCHUNKS)

! multiply by the inverse of the mass matrix and update velocity
  do i=1,nglob_outer_core
    accel_outer_core(i) = accel_outer_core(i)*rmass_outer_core(i)
    veloc_outer_core(i) = veloc_outer_core(i) + deltatover2*accel_outer_core(i)
  enddo

! ****************************************************
!   big loop over all spectral elements in the solid
! ****************************************************

! compute internal forces in the solid regions

! for anisotropy and gravity, x y and z contain r theta and phi
  call compute_forces_crust_mantle(ell_d80,minus_gravity_table,density_table,minus_deriv_gravity_table, &
          displ_crust_mantle,accel_crust_mantle, &
          xstore_crust_mantle,ystore_crust_mantle,zstore_crust_mantle, &
          xix_crust_mantle,xiy_crust_mantle,xiz_crust_mantle, &
          etax_crust_mantle,etay_crust_mantle,etaz_crust_mantle, &
          gammax_crust_mantle,gammay_crust_mantle,gammaz_crust_mantle,jacobian_crust_mantle, &
          hprime_xx,hprime_yy,hprime_zz, &
          hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
          wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube, &
          kappavstore_crust_mantle,kappahstore_crust_mantle,muvstore_crust_mantle, &
          muhstore_crust_mantle,eta_anisostore_crust_mantle, &
          c11store_crust_mantle,c12store_crust_mantle,c13store_crust_mantle, &
          c14store_crust_mantle,c15store_crust_mantle,c16store_crust_mantle, &
          c22store_crust_mantle,c23store_crust_mantle,c24store_crust_mantle, &
          c25store_crust_mantle,c26store_crust_mantle,c33store_crust_mantle, &
          c34store_crust_mantle,c35store_crust_mantle,c36store_crust_mantle, &
          c44store_crust_mantle,c45store_crust_mantle,c46store_crust_mantle, &
          c55store_crust_mantle,c56store_crust_mantle,c66store_crust_mantle, &
          ibool_crust_mantle,idoubling_crust_mantle, &
          R_memory_crust_mantle,epsilondev_crust_mantle,one_minus_sum_beta_crust_mantle, &
          alphaval,betaval,gammaval,factor_common_crust_mantle, &
          size(factor_common_crust_mantle,2), size(factor_common_crust_mantle,3), &
          size(factor_common_crust_mantle,4), size(factor_common_crust_mantle,5),R80, &
          nspec_crust_mantle,nglob_crust_mantle,NSPECMAX_CRUST_MANTLE_ATTENUAT, &
          NSPECMAX_ISO_MANTLE,NSPECMAX_TISO_MANTLE,NSPECMAX_ANISO_MANTLE, &
          GRAVITY,ATTENUATION,ATTENUATION_3D,ANISOTROPIC_3D_MANTLE,TRANSVERSE_ISOTROPY,ELLIPTICITY)

! Stacey
  if(NCHUNKS /= 6 .and. ABSORBING_CONDITIONS) then

! crust & mantle

!   xmin
! if two chunks exclude this face for one of them
  if(NCHUNKS == 1 .or. ichunk == CHUNK_AC) then
    do ispec2D=1,nspec2D_xmin_crust_mantle

      ispec=ibelm_xmin_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_xi_crust_mantle(1,ispec2D) == 0 .or. njmin_crust_mantle(1,ispec2D) == 0) cycle

      i=1
      do k=nkmin_xi_crust_mantle(1,ispec2D),NGLLZ
        do j=njmin_crust_mantle(1,ispec2D),njmax_crust_mantle(1,ispec2D)
          iglob=ibool_crust_mantle(i,j,k,ispec)

          vx=veloc_crust_mantle(1,iglob)
          vy=veloc_crust_mantle(2,iglob)
          vz=veloc_crust_mantle(3,iglob)

          nx=normal_xmin_crust_mantle(1,j,k,ispec2D)
          ny=normal_xmin_crust_mantle(2,j,k,ispec2D)
          nz=normal_xmin_crust_mantle(3,j,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp_crust_mantle(i,j,k,ispec)*vn*nx+rho_vs_crust_mantle(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp_crust_mantle(i,j,k,ispec)*vn*ny+rho_vs_crust_mantle(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp_crust_mantle(i,j,k,ispec)*vn*nz+rho_vs_crust_mantle(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_xmin_crust_mantle(j,k,ispec2D)*wgllwgll_yz(j,k)

          accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
          accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
          accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

        enddo
      enddo
    enddo
  endif

!   xmax
! if two chunks exclude this face for one of them
  if(NCHUNKS == 1 .or. ichunk == CHUNK_AB) then
    do ispec2D=1,nspec2D_xmax_crust_mantle

      ispec=ibelm_xmax_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_xi_crust_mantle(2,ispec2D) == 0 .or. njmin_crust_mantle(2,ispec2D) == 0) cycle

      i=NGLLX
      do k=nkmin_xi_crust_mantle(2,ispec2D),NGLLZ
        do j=njmin_crust_mantle(2,ispec2D),njmax_crust_mantle(2,ispec2D)
          iglob=ibool_crust_mantle(i,j,k,ispec)

          vx=veloc_crust_mantle(1,iglob)
          vy=veloc_crust_mantle(2,iglob)
          vz=veloc_crust_mantle(3,iglob)

          nx=normal_xmax_crust_mantle(1,j,k,ispec2D)
          ny=normal_xmax_crust_mantle(2,j,k,ispec2D)
          nz=normal_xmax_crust_mantle(3,j,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp_crust_mantle(i,j,k,ispec)*vn*nx+rho_vs_crust_mantle(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp_crust_mantle(i,j,k,ispec)*vn*ny+rho_vs_crust_mantle(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp_crust_mantle(i,j,k,ispec)*vn*nz+rho_vs_crust_mantle(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_xmax_crust_mantle(j,k,ispec2D)*wgllwgll_yz(j,k)

          accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
          accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
          accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

        enddo
      enddo
    enddo
  endif

!   ymin
    do ispec2D=1,nspec2D_ymin_crust_mantle

      ispec=ibelm_ymin_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_eta_crust_mantle(1,ispec2D) == 0 .or. nimin_crust_mantle(1,ispec2D) == 0) cycle

      j=1
      do k=nkmin_eta_crust_mantle(1,ispec2D),NGLLZ
        do i=nimin_crust_mantle(1,ispec2D),nimax_crust_mantle(1,ispec2D)
          iglob=ibool_crust_mantle(i,j,k,ispec)

          vx=veloc_crust_mantle(1,iglob)
          vy=veloc_crust_mantle(2,iglob)
          vz=veloc_crust_mantle(3,iglob)

          nx=normal_ymin_crust_mantle(1,i,k,ispec2D)
          ny=normal_ymin_crust_mantle(2,i,k,ispec2D)
          nz=normal_ymin_crust_mantle(3,i,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp_crust_mantle(i,j,k,ispec)*vn*nx+rho_vs_crust_mantle(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp_crust_mantle(i,j,k,ispec)*vn*ny+rho_vs_crust_mantle(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp_crust_mantle(i,j,k,ispec)*vn*nz+rho_vs_crust_mantle(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_ymin_crust_mantle(i,k,ispec2D)*wgllwgll_xz(i,k)

          accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
          accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
          accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

        enddo
      enddo
    enddo

!   ymax
    do ispec2D=1,nspec2D_ymax_crust_mantle

      ispec=ibelm_ymax_crust_mantle(ispec2D)

! exclude elements that are not on absorbing edges
      if(nkmin_eta_crust_mantle(2,ispec2D) == 0 .or. nimin_crust_mantle(2,ispec2D) == 0) cycle

      j=NGLLY
      do k=nkmin_eta_crust_mantle(2,ispec2D),NGLLZ
        do i=nimin_crust_mantle(2,ispec2D),nimax_crust_mantle(2,ispec2D)
          iglob=ibool_crust_mantle(i,j,k,ispec)

          vx=veloc_crust_mantle(1,iglob)
          vy=veloc_crust_mantle(2,iglob)
          vz=veloc_crust_mantle(3,iglob)

          nx=normal_ymax_crust_mantle(1,i,k,ispec2D)
          ny=normal_ymax_crust_mantle(2,i,k,ispec2D)
          nz=normal_ymax_crust_mantle(3,i,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp_crust_mantle(i,j,k,ispec)*vn*nx+rho_vs_crust_mantle(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp_crust_mantle(i,j,k,ispec)*vn*ny+rho_vs_crust_mantle(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp_crust_mantle(i,j,k,ispec)*vn*nz+rho_vs_crust_mantle(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_ymax_crust_mantle(i,k,ispec2D)*wgllwgll_xz(i,k)

          accel_crust_mantle(1,iglob)=accel_crust_mantle(1,iglob) - tx*weight
          accel_crust_mantle(2,iglob)=accel_crust_mantle(2,iglob) - ty*weight
          accel_crust_mantle(3,iglob)=accel_crust_mantle(3,iglob) - tz*weight

        enddo
      enddo
    enddo

  endif ! Stacey conditions

  call compute_forces_inner_core(minus_gravity_table,density_table,minus_deriv_gravity_table, &
          displ_inner_core,accel_inner_core, &
          xstore_inner_core,ystore_inner_core,zstore_inner_core, &
          xix_inner_core,xiy_inner_core,xiz_inner_core, &
          etax_inner_core,etay_inner_core,etaz_inner_core, &
          gammax_inner_core,gammay_inner_core,gammaz_inner_core,jacobian_inner_core, &
          hprime_xx,hprime_yy,hprime_zz, &
          hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
          wgllwgll_xy,wgllwgll_xz,wgllwgll_yz,wgll_cube, &
          kappavstore_inner_core,muvstore_inner_core,ibool_inner_core,idoubling_inner_core, &
          c11store_inner_core,c33store_inner_core,c12store_inner_core,c13store_inner_core,c44store_inner_core, &
          R_memory_inner_core,epsilondev_inner_core, &
          one_minus_sum_beta_inner_core, &
          alphaval,betaval,gammaval, &
          factor_common_inner_core, &
          size(factor_common_inner_core,2), size(factor_common_inner_core,3), &
          size(factor_common_inner_core,4), size(factor_common_inner_core,5), &
          nspec_inner_core,nglob_inner_core,NSPEC_INNER_CORE_ATTENUATION, &
          ATTENUATION,ATTENUATION_3D,GRAVITY,ANISOTROPIC_INNER_CORE)

  do isource = 1,NSOURCES

!   add the source (only if this proc carries the source)
    if(myrank == islice_selected_source(isource)) then

      stf = comp_source_time_function(dble(it-1)*DT-t0-t_cmt(isource),hdur_gaussian(isource))

!     distinguish between single and double precision for reals
      if(CUSTOM_REAL == SIZE_REAL) then
        stf_used = sngl(stf)
      else
        stf_used = stf
      endif

!     add source array
      do k=1,NGLLZ
        do j=1,NGLLY
          do i=1,NGLLX
            iglob = ibool_crust_mantle(i,j,k,ispec_selected_source(isource))
            accel_crust_mantle(:,iglob) = accel_crust_mantle(:,iglob) + sourcearrays(isource,:,i,j,k)*stf_used
          enddo
        enddo
      enddo

    endif

  enddo

! ****************************************************
! **********  add matching with fluid part  **********
! ****************************************************

! only for elements in first matching layer in the solid

!---
!--- couple with outer core at the bottom of the mantle
!---

  if(ACTUALLY_COUPLE_FLUID_CMB) then

! for surface elements exactly on the CMB
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_CRUST_MANTLE)

      ispec = ibelm_bottom_crust_mantle(ispec2D)

! only for DOFs exactly on the CMB (bottom of these elements)
      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX

! get velocity potential on the fluid side using pointwise matching
          ispec_selected = ibelm_top_outer_core(ispec2D)
          k_corresp = NGLLZ

! get normal at the CMB
          nx = normal_top_outer_core(1,i,j,ispec2D)
          ny = normal_top_outer_core(2,i,j,ispec2D)
          nz = normal_top_outer_core(3,i,j,ispec2D)

! get global point number
! corresponding points are located at the top of the outer core
          iglob = ibool_outer_core(i,j,NGLLZ,ispec_selected)
          iglob_mantle = ibool_crust_mantle(i,j,k,ispec)

! compute pressure, taking gravity into account
          if(GRAVITY) then
            pressure = RHO_TOP_OC * (- accel_outer_core(iglob) &
               + minus_g_cmb *(displ_crust_mantle(1,iglob_mantle)*nx &
               + displ_crust_mantle(2,iglob_mantle)*ny + displ_crust_mantle(3,iglob_mantle)*nz))
          else
            pressure = - RHO_TOP_OC * accel_outer_core(iglob)
          endif

! formulation with generalized potential
          weight = jacobian2D_top_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel_crust_mantle(1,iglob_mantle) = accel_crust_mantle(1,iglob_mantle) + weight*nx*pressure
          accel_crust_mantle(2,iglob_mantle) = accel_crust_mantle(2,iglob_mantle) + weight*ny*pressure
          accel_crust_mantle(3,iglob_mantle) = accel_crust_mantle(3,iglob_mantle) + weight*nz*pressure

        enddo
      enddo
    enddo

  endif

!---
!--- couple with outer core at the top of the inner core
!---

  if(ACTUALLY_COUPLE_FLUID_ICB .and. NCHUNKS == 6) then

! for surface elements exactly on the ICB
    do ispec2D = 1,NSPEC2D_TOP(IREGION_INNER_CORE)

      ispec = ibelm_top_inner_core(ispec2D)

! only for DOFs exactly on the ICB (top of these elements)
      k = NGLLZ
      do j = 1,NGLLY
        do i = 1,NGLLX

! get velocity potential on the fluid side using pointwise matching
          ispec_selected = ibelm_bottom_outer_core(ispec2D)
          k_corresp = 1

! get normal at the ICB
          nx = normal_bottom_outer_core(1,i,j,ispec2D)
          ny = normal_bottom_outer_core(2,i,j,ispec2D)
          nz = normal_bottom_outer_core(3,i,j,ispec2D)

! get global point number
! corresponding points are located at the bottom of the outer core
          iglob = ibool_outer_core(i,j,k_corresp,ispec_selected)
          iglob_inner_core = ibool_inner_core(i,j,k,ispec)

! compute pressure, taking gravity into account
          if(GRAVITY) then
            pressure = RHO_BOTTOM_OC * (- accel_outer_core(iglob) &
               + minus_g_icb *(displ_inner_core(1,iglob_inner_core)*nx &
               + displ_inner_core(2,iglob_inner_core)*ny + displ_inner_core(3,iglob_inner_core)*nz))
          else
            pressure = - RHO_BOTTOM_OC * accel_outer_core(iglob)
          endif

! formulation with generalized potential
          weight = jacobian2D_bottom_outer_core(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel_inner_core(1,iglob_inner_core) = accel_inner_core(1,iglob_inner_core) - weight*nx*pressure
          accel_inner_core(2,iglob_inner_core) = accel_inner_core(2,iglob_inner_core) - weight*ny*pressure
          accel_inner_core(3,iglob_inner_core) = accel_inner_core(3,iglob_inner_core) - weight*nz*pressure

        enddo
      enddo
    enddo

    endif

! assemble all the contributions between slices using MPI

! crust and mantle
  call assemble_MPI_vector(myrank,accel_crust_mantle,nglob_crust_mantle, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_crust_mantle,iboolright_xi_crust_mantle,iboolleft_eta_crust_mantle,iboolright_eta_crust_mantle, &
            npoin2D_faces_crust_mantle,npoin2D_xi_crust_mantle,npoin2D_eta_crust_mantle, &
            iboolfaces_crust_mantle,iboolcorner_crust_mantle, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
            buffer_send_faces_vector,buffer_received_faces_vector, &
            buffer_send_chunkcorners_vector,buffer_recv_chunkcorners_vector, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_CRUST_MANTLE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_YMIN_YMAX(IREGION_CRUST_MANTLE),NPOIN2DMAX_XY,NCHUNKS)

! inner core
  call assemble_MPI_vector(myrank,accel_inner_core,nglob_inner_core, &
            iproc_xi,iproc_eta,ichunk,addressing, &
            iboolleft_xi_inner_core,iboolright_xi_inner_core,iboolleft_eta_inner_core,iboolright_eta_inner_core, &
            npoin2D_faces_inner_core,npoin2D_xi_inner_core,npoin2D_eta_inner_core, &
            iboolfaces_inner_core,iboolcorner_inner_core, &
            iprocfrom_faces,iprocto_faces,imsg_type, &
            iproc_master_corners,iproc_slave1_corners,iproc_slave2_corners, &
            buffer_send_faces_vector,buffer_received_faces_vector, &
            buffer_send_chunkcorners_vector,buffer_recv_chunkcorners_vector, &
            NUMMSGS_FACES,NUM_MSG_TYPES,NCORNERSCHUNKS, &
            NPROC_XI,NPROC_ETA,NPOIN1D_RADIAL(IREGION_INNER_CORE), &
            NPOIN2DMAX_XMIN_XMAX(IREGION_INNER_CORE),NPOIN2DMAX_YMIN_YMAX(IREGION_INNER_CORE),NPOIN2DMAX_XY,NCHUNKS)

!---
!---  use buffers to assemble forces with the central cube
!---

  if(INCLUDE_CENTRAL_CUBE) then

! on chunk AB, receive all the messages from slices
  if(ichunk == CHUNK_AB) then

   do imsg = 1,nb_msgs_theor_in_cube

! receive buffers from slices
  isender = sender_from_slices_to_cube(imsg)
  call MPI_RECV(buffer_slices, &
              NDIM*npoin2D_cube_from_slices,MPI_DOUBLE_PRECISION,isender, &
              itag,MPI_COMM_WORLD,msg_status,ier)

! copy buffer in 2D array for each slice
   buffer_all_cube_from_slices(imsg,:,:) = buffer_slices(:,:)

   enddo
   endif


! send info to central cube from all the slices except those in CHUNK_AB
  if(ichunk /= CHUNK_AB) then

! for bottom elements in contact with central cube from the slices side
    ipoin = 0
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_INNER_CORE)

      ispec = ibelm_bottom_inner_core(ispec2D)

! only for DOFs exactly on surface of central cube (bottom of these elements)
      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX
          ipoin = ipoin + 1
          buffer_slices(ipoin,:) = dble(accel_inner_core(:,ibool_inner_core(i,j,k,ispec)))
        enddo
      enddo
    enddo

! send buffer to central cube
    ireceiver = receiver_cube_from_slices
    call MPI_SEND(buffer_slices,NDIM*npoin2D_cube_from_slices, &
              MPI_DOUBLE_PRECISION,ireceiver,itag,MPI_COMM_WORLD,ier)

 endif  ! end sending info to central cube

!--- now we need to assemble the contributions

  if(ichunk == CHUNK_AB) then

! loop on the three dimensions of the array
  do idimension = 1,NDIM

! erase contributions to central cube array
  array_central_cube(:) = 0._CUSTOM_REAL

! use indirect addressing to store contributions only once
! distinguish between single and double precision for reals
   do imsg = 1,nb_msgs_theor_in_cube
   do ipoin = 1,npoin2D_cube_from_slices
     if(CUSTOM_REAL == SIZE_REAL) then
       array_central_cube(ibool_central_cube(imsg,ipoin)) = sngl(buffer_all_cube_from_slices(imsg,ipoin,idimension))
     else
       array_central_cube(ibool_central_cube(imsg,ipoin)) = buffer_all_cube_from_slices(imsg,ipoin,idimension)
     endif
   enddo
   enddo

! suppress degrees of freedom already assembled at top of cube on edges
  do ispec = 1,nspec_inner_core
    if(idoubling_inner_core(ispec) == IFLAG_TOP_CENTRAL_CUBE) then
      k = NGLLZ
      do j = 1,NGLLY
        do i = 1,NGLLX
          array_central_cube(ibool_inner_core(i,j,k,ispec)) = 0._CUSTOM_REAL
        enddo
      enddo
    endif
  enddo

! assemble contributions
  accel_inner_core(idimension,:) = accel_inner_core(idimension,:) + array_central_cube(:)

! copy sum back
   do imsg = 1,nb_msgs_theor_in_cube
   do ipoin = 1,npoin2D_cube_from_slices
     buffer_all_cube_from_slices(imsg,ipoin,idimension) = accel_inner_core(idimension,ibool_central_cube(imsg,ipoin))
   enddo
   enddo

   enddo

   endif


!----------

! receive info from central cube on all the slices except those in CHUNK_AB
  if(ichunk /= CHUNK_AB) then

! receive buffers from slices
  isender = receiver_cube_from_slices
  call MPI_RECV(buffer_slices, &
              NDIM*npoin2D_cube_from_slices,MPI_DOUBLE_PRECISION,isender, &
              itag,MPI_COMM_WORLD,msg_status,ier)

! for bottom elements in contact with central cube from the slices side
    ipoin = 0
    do ispec2D = 1,NSPEC2D_BOTTOM(IREGION_INNER_CORE)

      ispec = ibelm_bottom_inner_core(ispec2D)

! only for DOFs exactly on surface of central cube (bottom of these elements)
      k = 1
      do j = 1,NGLLY
        do i = 1,NGLLX
          ipoin = ipoin + 1

! distinguish between single and double precision for reals
          if(CUSTOM_REAL == SIZE_REAL) then
            accel_inner_core(:,ibool_inner_core(i,j,k,ispec)) = sngl(buffer_slices(ipoin,:))
          else
            accel_inner_core(:,ibool_inner_core(i,j,k,ispec)) = buffer_slices(ipoin,:)
          endif

        enddo
      enddo
    enddo

 endif  ! end receiving info from central cube

!------- send info back from central cube to slices

! on chunk AB, send all the messages to slices
  if(ichunk == CHUNK_AB) then

   do imsg = 1,nb_msgs_theor_in_cube

! copy buffer in 2D array for each slice
   buffer_slices(:,:) = buffer_all_cube_from_slices(imsg,:,:)

! send buffers to slices
    ireceiver = sender_from_slices_to_cube(imsg)
    call MPI_SEND(buffer_slices,NDIM*npoin2D_cube_from_slices, &
              MPI_DOUBLE_PRECISION,ireceiver,itag,MPI_COMM_WORLD,ier)

   enddo
   endif

  endif   ! end of assembling forces with the central cube

  do i=1,nglob_crust_mantle
    accel_crust_mantle(1,i) = accel_crust_mantle(1,i)*rmass_crust_mantle(i) &
               + two_omega_earth*veloc_crust_mantle(2,i)
    accel_crust_mantle(2,i) = accel_crust_mantle(2,i)*rmass_crust_mantle(i) &
               - two_omega_earth*veloc_crust_mantle(1,i)
    accel_crust_mantle(3,i) = accel_crust_mantle(3,i)*rmass_crust_mantle(i)
  enddo

  if(OCEANS) then

!   initialize the updates
    updated_dof_ocean_load(:) = .false.

! for surface elements exactly at the top of the crust (ocean bottom)
    do ispec2D = 1,NSPEC2D_TOP(IREGION_CRUST_MANTLE)

      ispec = ibelm_top_crust_mantle(ispec2D)

! only for DOFs exactly at the top of the crust (ocean bottom)
      k = NGLLZ

      do j = 1,NGLLY
        do i = 1,NGLLX

! get global point number
          iglob = ibool_crust_mantle(i,j,k,ispec)

! only update once
          if(.not. updated_dof_ocean_load(iglob)) then

! get normal
            nx = normal_top_crust_mantle(1,i,j,ispec2D)
            ny = normal_top_crust_mantle(2,i,j,ispec2D)
            nz = normal_top_crust_mantle(3,i,j,ispec2D)

! make updated component of right-hand side
! we divide by rmass_crust_mantle() which is 1 / M
! we use the total force which includes the Coriolis term above
            force_normal_comp = (accel_crust_mantle(1,iglob)*nx + &
                 accel_crust_mantle(2,iglob)*ny + &
                 accel_crust_mantle(3,iglob)*nz) / rmass_crust_mantle(iglob)

            additional_term = (rmass_ocean_load(iglob) - rmass_crust_mantle(iglob)) * force_normal_comp

            accel_crust_mantle(1,iglob) = accel_crust_mantle(1,iglob) + additional_term * nx
            accel_crust_mantle(2,iglob) = accel_crust_mantle(2,iglob) + additional_term * ny
            accel_crust_mantle(3,iglob) = accel_crust_mantle(3,iglob) + additional_term * nz

!           done with this point
            updated_dof_ocean_load(iglob) = .true.

          endif

        enddo
      enddo
    enddo
  endif

  do i=1,nglob_crust_mantle
    veloc_crust_mantle(:,i) = veloc_crust_mantle(:,i) + deltatover2*accel_crust_mantle(:,i)
  enddo

  do i=1,nglob_inner_core
    accel_inner_core(1,i) = accel_inner_core(1,i)*rmass_inner_core(i) &
             + two_omega_earth*veloc_inner_core(2,i)
    accel_inner_core(2,i) = accel_inner_core(2,i)*rmass_inner_core(i) &
             - two_omega_earth*veloc_inner_core(1,i)
    accel_inner_core(3,i) = accel_inner_core(3,i)*rmass_inner_core(i)

    veloc_inner_core(:,i) = veloc_inner_core(:,i) + deltatover2*accel_inner_core(:,i)
  enddo

! write the seismograms with time shift

  do irec_local = 1,nrec_local

! get global number of that receiver
    irec = number_receiver_global(irec_local)

! perform the general interpolation using Lagrange polynomials
        uxd = ZERO
        uyd = ZERO
        uzd = ZERO

        do k = 1,NGLLZ
          do j = 1,NGLLY
            do i = 1,NGLLX

              iglob = ibool_crust_mantle(i,j,k,ispec_selected_rec(irec))

              hlagrange = hxir_store(irec_local,i)*hetar_store(irec_local,j)*hgammar_store(irec_local,k)

              uxd = uxd + dble(displ_crust_mantle(1,iglob))*hlagrange
              uyd = uyd + dble(displ_crust_mantle(2,iglob))*hlagrange
              uzd = uzd + dble(displ_crust_mantle(3,iglob))*hlagrange

            enddo
          enddo
        enddo

! store North, East and Vertical components

! distinguish between single and double precision for reals
      if(CUSTOM_REAL == SIZE_REAL) then
        seismograms(:,irec_local,it) = sngl(scale_displ*(nu(:,1,irec)*uxd + &
                          nu(:,2,irec)*uyd + nu(:,3,irec)*uzd))
      else
        seismograms(:,irec_local,it) = scale_displ*(nu(:,1,irec)*uxd + &
                          nu(:,2,irec)*uyd + nu(:,3,irec)*uzd)
      endif

  enddo

! write the current seismograms
  if(mod(it,NTSTEP_BETWEEN_OUTPUT_SEISMOS) == 0) &
      call write_seismograms(myrank,seismograms,number_receiver_global,station_name, &
          network_name,nrec,nrec_local,DT,NSTEP,t0,LOCAL_PATH,it_begin,it_end)

! save movie on surface
  if(MOVIE_SURFACE .and. mod(it,NTSTEP_BETWEEN_FRAMES) == 0) then

! save velocity here to avoid static offset on displacement for movies

! rescale non-dimensional velocity to right units
    scale_veloc = scale_displ / scale_t

! get coordinates of surface mesh and surface displacement
    ipoin = 0
    do ispec2D = 1,NSPEC2D_TOP(IREGION_CRUST_MANTLE)
      ispec = ibelm_top_crust_mantle(ispec2D)
      k = NGLLZ

! loop on all the points inside the element
      do j = 1,NGLLY
        do i = 1,NGLLX
          ipoin = ipoin + 1
          iglob = ibool_crust_mantle(i,j,k,ispec)
          store_val_x(ipoin) = xstore_crust_mantle(iglob)
          store_val_y(ipoin) = ystore_crust_mantle(iglob)
          store_val_z(ipoin) = zstore_crust_mantle(iglob)
          store_val_ux(ipoin) = veloc_crust_mantle(1,iglob)
          store_val_uy(ipoin) = veloc_crust_mantle(2,iglob)
          store_val_uz(ipoin) = veloc_crust_mantle(3,iglob)
        enddo
      enddo

    enddo

! gather info on master proc
    ispec = NGLLSQUARE*NSPEC2D_TOP(IREGION_CRUST_MANTLE)
    call MPI_GATHER(store_val_x,ispec,CUSTOM_MPI_TYPE,store_val_x_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_y,ispec,CUSTOM_MPI_TYPE,store_val_y_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_z,ispec,CUSTOM_MPI_TYPE,store_val_z_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_ux,ispec,CUSTOM_MPI_TYPE,store_val_ux_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_uy,ispec,CUSTOM_MPI_TYPE,store_val_uy_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_uz,ispec,CUSTOM_MPI_TYPE,store_val_uz_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)

! save movie data to disk in home directory
    if(myrank == 0) then
      write(outputname,"('OUTPUT_FILES/moviedata',i6.6)") it
      open(unit=IOUT,file=outputname,status='unknown',form='unformatted')
      write(IOUT) store_val_x_all
      write(IOUT) store_val_y_all
      write(IOUT) store_val_z_all
      write(IOUT) store_val_ux_all
      write(IOUT) store_val_uy_all
      write(IOUT) store_val_uz_all
      close(IOUT)
    endif

  endif

! save movie in full 3D mesh
  if(MOVIE_VOLUME .and. mod(it,NTSTEP_BETWEEN_FRAMES) == 0) then

! save velocity here to avoid static offset on displacement for movies

! rescale non-dimensional velocity to right units
    scale_veloc = scale_displ / scale_t

! save full snapshot data to local disk

!--- first region is the mantle/crust

! PvK Change output format to more compact and binary form
!    write(outputname,"('snapshot_full_mantle_proc',i4.4,'_it',i6.6,'.dat')") myrank,it
!    open(unit=IOUT,file=final_LOCAL_PATH(1:len_trim(final_LOCAL_PATH))//outputname,status='unknown')
    write(outputname,"('mantle_veloc_proc',i4.4,'_it',i6.6)") myrank,it
    open(unit=IOUT,file=final_LOCAL_PATH(1:len_trim(final_LOCAL_PATH))//outputname,status='unknown',form='unformatted')

    if (ifirst_movie) then
       write(outputname,"('mantle_topology_proc',i4.4)") myrank
       open(unit=IOUT_TOPOLOGY,file=final_LOCAL_PATH(1:len_trim(final_LOCAL_PATH))//outputname,status='unknown',form='unformatted')
       write(outputname,"('mantle_coord_proc',i4.4)") myrank
       open(unit=IOUT_COORD,file=final_LOCAL_PATH(1:len_trim(final_LOCAL_PATH))//outputname,status='unknown',form='unformatted')
    endif

! PvK 071803

    allocate(mask_poin(nglob_crust_mantle))
    allocate(indirect_poin(nglob_crust_mantle))

! count total number of points and define indirect addressing
    itotal_poin = 0
    mask_poin(:) = .false.
    indirect_poin(:) = 0
    do ispec=1,nspec_crust_mantle
      do k = 1,NGLLZ
        do j = 1,NGLLY
          do i = 1,NGLLX
            ipoin = ibool_crust_mantle(i,j,k,ispec)
            if(.not. mask_poin(ipoin)) then
              itotal_poin = itotal_poin + 1
              indirect_poin(ipoin) = itotal_poin
              mask_poin(ipoin) = .true.
            endif
          enddo
        enddo
      enddo
    enddo

! write number of elements and points
! PvK
    if (ifirst_movie) then
      write(IOUT_COORD) itotal_poin
      write(IOUT_TOPOLOGY) nspec_crust_mantle
    endif

! write coordinates of points, and velocity at these points
    mask_poin(:) = .false.
    do ispec=1,nspec_crust_mantle

    do k=1,NGLLZ
      do j=1,NGLLY
        do i=1,NGLLX

          tempx1l = 0._CUSTOM_REAL
          tempx2l = 0._CUSTOM_REAL
          tempx3l = 0._CUSTOM_REAL

          tempy1l = 0._CUSTOM_REAL
          tempy2l = 0._CUSTOM_REAL
          tempy3l = 0._CUSTOM_REAL

          tempz1l = 0._CUSTOM_REAL
          tempz2l = 0._CUSTOM_REAL
          tempz3l = 0._CUSTOM_REAL

          do l=1,NGLLX
            hp1 = hprime_xx(l,i)
            iglob = ibool_crust_mantle(l,j,k,ispec)
            tempx1l = tempx1l + veloc_crust_mantle(1,iglob)*hp1
            tempy1l = tempy1l + veloc_crust_mantle(2,iglob)*hp1
            tempz1l = tempz1l + veloc_crust_mantle(3,iglob)*hp1
          enddo

          do l=1,NGLLY
            hp2 = hprime_yy(l,j)
            iglob = ibool_crust_mantle(i,l,k,ispec)
            tempx2l = tempx2l + veloc_crust_mantle(1,iglob)*hp2
            tempy2l = tempy2l + veloc_crust_mantle(2,iglob)*hp2
            tempz2l = tempz2l + veloc_crust_mantle(3,iglob)*hp2
          enddo

          do l=1,NGLLZ
            hp3 = hprime_zz(l,k)
            iglob = ibool_crust_mantle(i,j,l,ispec)
            tempx3l = tempx3l + veloc_crust_mantle(1,iglob)*hp3
            tempy3l = tempy3l + veloc_crust_mantle(2,iglob)*hp3
            tempz3l = tempz3l + veloc_crust_mantle(3,iglob)*hp3
          enddo

!         get derivatives of ux, uy and uz with respect to x, y and z

          xixl = xix_crust_mantle(i,j,k,ispec)
          xiyl = xiy_crust_mantle(i,j,k,ispec)
          xizl = xiz_crust_mantle(i,j,k,ispec)
          etaxl = etax_crust_mantle(i,j,k,ispec)
          etayl = etay_crust_mantle(i,j,k,ispec)
          etazl = etaz_crust_mantle(i,j,k,ispec)
          gammaxl = gammax_crust_mantle(i,j,k,ispec)
          gammayl = gammay_crust_mantle(i,j,k,ispec)
          gammazl = gammaz_crust_mantle(i,j,k,ispec)

          dvxdxl(i,j,k) = xixl*tempx1l + etaxl*tempx2l + gammaxl*tempx3l
          dvxdyl(i,j,k) = xiyl*tempx1l + etayl*tempx2l + gammayl*tempx3l
          dvxdzl(i,j,k) = xizl*tempx1l + etazl*tempx2l + gammazl*tempx3l

          dvydxl(i,j,k) = xixl*tempy1l + etaxl*tempy2l + gammaxl*tempy3l
          dvydyl(i,j,k) = xiyl*tempy1l + etayl*tempy2l + gammayl*tempy3l
          dvydzl(i,j,k) = xizl*tempy1l + etazl*tempy2l + gammazl*tempy3l

          dvzdxl(i,j,k) = xixl*tempz1l + etaxl*tempz2l + gammaxl*tempz3l
          dvzdyl(i,j,k) = xiyl*tempz1l + etayl*tempz2l + gammayl*tempz3l
          dvzdzl(i,j,k) = xizl*tempz1l + etazl*tempz2l + gammazl*tempz3l

        enddo
      enddo
    enddo

      do k = 1,NGLLZ
        do j = 1,NGLLY
          do i = 1,NGLLX
            ipoin = ibool_crust_mantle(i,j,k,ispec)
            if(.not. mask_poin(ipoin)) then
! coordinates actually contain r theta phi, therefore convert back to x y z
              rval = xstore_crust_mantle(ipoin)
              thetaval = ystore_crust_mantle(ipoin)
              phival = zstore_crust_mantle(ipoin)
              call rthetaphi_2_xyz(xcoord,ycoord,zcoord,rval,thetaval,phival)
! compute div and curl of velocity
              div = (dvxdxl(i,j,k) + dvydyl(i,j,k) + dvzdzl(i,j,k)) * scale_veloc / R_EARTH
              curl_x = (dvzdyl(i,j,k) - dvydzl(i,j,k)) * scale_veloc / R_EARTH
              curl_y = (dvxdzl(i,j,k) - dvzdxl(i,j,k)) * scale_veloc / R_EARTH
              curl_z = (dvydxl(i,j,k) - dvxdyl(i,j,k)) * scale_veloc / R_EARTH
              write(IOUT,"(e13.6,1x,e13.6,1x,e13.6,1x,e13.6,1x,e13.6,1x,e13.6,1x,e13.6,1x,e13.6,1x,e13.6,1x,e13.6)") &
                            xcoord*R_EARTH,ycoord*R_EARTH,zcoord*R_EARTH, &
                            veloc_crust_mantle(1,ipoin)*scale_veloc, &
                            veloc_crust_mantle(2,ipoin)*scale_veloc, &
                            veloc_crust_mantle(3,ipoin)*scale_veloc, &
                            div,curl_x,curl_y,curl_z
              write(IOUT) real(veloc_crust_mantle(1,ipoin)*scale_veloc), &
                            real(veloc_crust_mantle(2,ipoin)*scale_veloc), &
                            real(veloc_crust_mantle(3,ipoin)*scale_veloc), &
                            real(div),real(curl_x),real(curl_y),real(curl_z)
              if (ifirst_movie) write(IOUT_COORD) real(xcoord*R_EARTH),real(ycoord*R_EARTH),real(zcoord*R_EARTH)
! PvK
              mask_poin(ipoin) = .true.
            endif
          enddo
        enddo
      enddo
    enddo

! write topology of elements
! PvK  Modified to more compact and binary format
    if (ifirst_movie) then
      do ispec=1,nspec_crust_mantle
         write(IOUT_TOPOLOGY) (((indirect_poin(ibool_crust_mantle(i,j,k,ispec)),i=1,NGLLX),j=1,NGLLY),k=1,NGLLZ)
      enddo
    endif

! PvK 071803 Close binary files
    close(IOUT)
    if (ifirst_movie) then
       close(IOUT_TOPOLOGY)
       close(IOUT_COORD)
    endif

    deallocate(mask_poin)
    deallocate(indirect_poin)

!--- second region is the outer core

! PvK Change output to more compact and binary format
!   write(outputname,"('snapshot_full_outer_core_proc',i4.4,'_it',i6.6,'.dat')") myrank,it
!   open(unit=IOUT,file=final_LOCAL_PATH(1:len_trim(final_LOCAL_PATH))//outputname,status='unknown')
if (ifirst_movie) then
       write(outputname,"('outer_core_topology_proc',i4.4)") myrank
       open(unit=IOUT_TOPOLOGY,file=final_LOCAL_PATH(1:len_trim(final_LOCAL_PATH))//outputname,status='unknown',form='unformatted')
       write(outputname,"('outer_core_coord_proc',i4.4)") myrank
       open(unit=IOUT_COORD,file=final_LOCAL_PATH(1:len_trim(final_LOCAL_PATH))//outputname,status='unknown',form='unformatted')
    endif

! PvK


    allocate(mask_poin(nglob_outer_core))
    allocate(indirect_poin(nglob_outer_core))

! count total number of points and define indirect addressing
    itotal_poin = 0
    mask_poin(:) = .false.
    indirect_poin(:) = 0
    do ispec=1,nspec_outer_core
      do k = 1,NGLLZ
        do j = 1,NGLLY
          do i = 1,NGLLX
            ipoin = ibool_outer_core(i,j,k,ispec)
            if(.not. mask_poin(ipoin)) then
              itotal_poin = itotal_poin + 1
              indirect_poin(ipoin) = itotal_poin
              mask_poin(ipoin) = .true.
            endif
          enddo
        enddo
      enddo
    enddo

! write number of elements and points
! PvK
!   write(IOUT,*) itotal_poin
!   write(IOUT,*) nspec_outer_core
    if (ifirst_movie) then
      write(IOUT_COORD) itotal_poin
      write(IOUT_TOPOLOGY) nspec_outer_core
    endif

! write coordinates of points, and velocity at these points
    mask_poin(:) = .false.
    do ispec=1,nspec_outer_core

! compute gradient of velocity potential to get velocity
    do k=1,NGLLZ
      do j=1,NGLLY
        do i=1,NGLLX

          tempx1l = 0._CUSTOM_REAL
          tempx2l = 0._CUSTOM_REAL
          tempx3l = 0._CUSTOM_REAL

          do l=1,NGLLX
            tempx1l = tempx1l + veloc_outer_core(ibool_outer_core(l,j,k,ispec)) * hprime_xx(l,i)
          enddo

          do l=1,NGLLY
            tempx2l = tempx2l + veloc_outer_core(ibool_outer_core(i,l,k,ispec)) * hprime_yy(l,j)
          enddo

          do l=1,NGLLZ
            tempx3l = tempx3l + veloc_outer_core(ibool_outer_core(i,j,l,ispec)) * hprime_zz(l,k)
          enddo

!         get derivatives of velocity potential with respect to x, y and z

          xixl = xix_outer_core(i,j,k,ispec)
          xiyl = xiy_outer_core(i,j,k,ispec)
          xizl = xiz_outer_core(i,j,k,ispec)
          etaxl = etax_outer_core(i,j,k,ispec)
          etayl = etay_outer_core(i,j,k,ispec)
          etazl = etaz_outer_core(i,j,k,ispec)
          gammaxl = gammax_outer_core(i,j,k,ispec)
          gammayl = gammay_outer_core(i,j,k,ispec)
          gammazl = gammaz_outer_core(i,j,k,ispec)

          dpotentialdxl(i,j,k) = xixl*tempx1l + etaxl*tempx2l + gammaxl*tempx3l
          dpotentialdyl(i,j,k) = xiyl*tempx1l + etayl*tempx2l + gammayl*tempx3l
          dpotentialdzl(i,j,k) = xizl*tempx1l + etazl*tempx2l + gammazl*tempx3l

        enddo
      enddo
    enddo

    do k=1,NGLLZ
      do j=1,NGLLY
        do i=1,NGLLX

          tempx1l = 0._CUSTOM_REAL
          tempx2l = 0._CUSTOM_REAL
          tempx3l = 0._CUSTOM_REAL

          tempy1l = 0._CUSTOM_REAL
          tempy2l = 0._CUSTOM_REAL
          tempy3l = 0._CUSTOM_REAL

          tempz1l = 0._CUSTOM_REAL
          tempz2l = 0._CUSTOM_REAL
          tempz3l = 0._CUSTOM_REAL

          do l=1,NGLLX
            hp1 = hprime_xx(l,i)
            tempx1l = tempx1l + dpotentialdxl(l,j,k)*hp1
            tempy1l = tempy1l + dpotentialdyl(l,j,k)*hp1
            tempz1l = tempz1l + dpotentialdzl(l,j,k)*hp1
          enddo

          do l=1,NGLLY
            hp2 = hprime_yy(l,j)
            tempx2l = tempx2l + dpotentialdxl(i,l,k)*hp2
            tempy2l = tempy2l + dpotentialdyl(i,l,k)*hp2
            tempz2l = tempz2l + dpotentialdzl(i,l,k)*hp2
          enddo

          do l=1,NGLLZ
            hp3 = hprime_zz(l,k)
            tempx3l = tempx3l + dpotentialdxl(i,j,l)*hp3
            tempy3l = tempy3l + dpotentialdyl(i,j,l)*hp3
            tempz3l = tempz3l + dpotentialdzl(i,j,l)*hp3
          enddo

!         get derivatives of ux, uy and uz with respect to x, y and z

          xixl = xix_outer_core(i,j,k,ispec)
          xiyl = xiy_outer_core(i,j,k,ispec)
          xizl = xiz_outer_core(i,j,k,ispec)
          etaxl = etax_outer_core(i,j,k,ispec)
          etayl = etay_outer_core(i,j,k,ispec)
          etazl = etaz_outer_core(i,j,k,ispec)
          gammaxl = gammax_outer_core(i,j,k,ispec)
          gammayl = gammay_outer_core(i,j,k,ispec)
          gammazl = gammaz_outer_core(i,j,k,ispec)

          dvxdxl(i,j,k) = xixl*tempx1l + etaxl*tempx2l + gammaxl*tempx3l
          dvydyl(i,j,k) = xiyl*tempy1l + etayl*tempy2l + gammayl*tempy3l
          dvzdzl(i,j,k) = xizl*tempz1l + etazl*tempz2l + gammazl*tempz3l

        enddo
      enddo
    enddo

      do k = 1,NGLLZ
        do j = 1,NGLLY
          do i = 1,NGLLX
            ipoin = ibool_outer_core(i,j,k,ispec)
            if(.not. mask_poin(ipoin)) then
! coordinates actually contain r theta phi, therefore convert back to x y z
              rval = xstore_outer_core(ipoin)
              thetaval = ystore_outer_core(ipoin)
              phival = zstore_outer_core(ipoin)
              call rthetaphi_2_xyz(xcoord,ycoord,zcoord,rval,thetaval,phival)
! compute div and curl of velocity
              div = (dvxdxl(i,j,k) + dvydyl(i,j,k) + dvzdzl(i,j,k)) * scale_veloc / R_EARTH
              curl_x = 0.
              curl_y = 0.
              curl_z = 0.

              write(IOUT) real(dpotentialdxl(i,j,k)*scale_veloc), &
                    real(dpotentialdyl(i,j,k)*scale_veloc), &
                    real(dpotentialdzl(i,j,k)*scale_veloc), &
                    real(div),real(curl_x),real(curl_y),real(curl_z)
              if (ifirst_movie) write(IOUT_COORD) real(xcoord*R_EARTH),real(ycoord*R_EARTH),real(zcoord*R_EARTH)
              mask_poin(ipoin) = .true.
            endif
          enddo
        enddo
      enddo
    enddo

! write topology of elements
! PvK Modified to more compact and binary format
    if (ifirst_movie) then
     do ispec=1,nspec_outer_core
        write(IOUT_TOPOLOGY) (((indirect_poin(ibool_outer_core(i,j,k,ispec)),i=1,NGLLX),j=1,NGLLY),k=1,NGLLZ)
     enddo
    endif

    close(IOUT)
    if (ifirst_movie) then
       close(IOUT_TOPOLOGY)
       close(IOUT_COORD)
    endif

    deallocate(mask_poin)
    deallocate(indirect_poin)

!--- third region is the inner core

! PvK Change output to more compact and binary format
!   write(outputname,"('snapshot_full_inner_core_proc',i4.4,'_it',i6.6,'.dat')") myrank,it
!   open(unit=IOUT,file=final_LOCAL_PATH(1:len_trim(final_LOCAL_PATH))//outputname,status='unknown')
    write(outputname,"('inner_core_veloc_proc',i4.4,'_it',i6.6)") myrank,it
    open(unit=IOUT,file=final_LOCAL_PATH(1:len_trim(final_LOCAL_PATH))//outputname,status='unknown',form='unformatted')

    if (ifirst_movie) then
       write(outputname,"('inner_core_topology_proc',i4.4)") myrank
       open(unit=IOUT_TOPOLOGY,file=final_LOCAL_PATH(1:len_trim(final_LOCAL_PATH))//outputname,status='unknown',form='unformatted')
       write(outputname,"('inner_core_coord_proc',i4.4)") myrank
       open(unit=IOUT_COORD,file=final_LOCAL_PATH(1:len_trim(final_LOCAL_PATH))//outputname,status='unknown',form='unformatted')
    endif

! PvK

    allocate(mask_poin(nglob_inner_core))
    allocate(indirect_poin(nglob_inner_core))

! count total number of points and define indirect addressing
    itotal_poin = 0
    itotal_spec = 0
    mask_poin(:) = .false.
    indirect_poin(:) = 0
    do ispec=1,nspec_inner_core
      if(idoubling_inner_core(ispec) /= IFLAG_IN_FICTITIOUS_CUBE) then
      itotal_spec = itotal_spec + 1
      do k = 1,NGLLZ
        do j = 1,NGLLY
          do i = 1,NGLLX
            ipoin = ibool_inner_core(i,j,k,ispec)
            if(.not. mask_poin(ipoin)) then
              itotal_poin = itotal_poin + 1
              indirect_poin(ipoin) = itotal_poin
              mask_poin(ipoin) = .true.
            endif
          enddo
        enddo
      enddo
      endif
    enddo

! write number of elements and points
! PvK
!   write(IOUT,*) itotal_poin
!   write(IOUT,*) itotal_spec
    if (ifirst_movie) then
      write(IOUT_COORD) itotal_poin
      write(IOUT_TOPOLOGY) itotal_spec
    endif

! write coordinates of points, and velocity at these points
    mask_poin(:) = .false.
    do ispec=1,nspec_inner_core
      if(idoubling_inner_core(ispec) /= IFLAG_IN_FICTITIOUS_CUBE) then

    do k=1,NGLLZ
      do j=1,NGLLY
        do i=1,NGLLX

          tempx1l = 0._CUSTOM_REAL
          tempx2l = 0._CUSTOM_REAL
          tempx3l = 0._CUSTOM_REAL

          tempy1l = 0._CUSTOM_REAL
          tempy2l = 0._CUSTOM_REAL
          tempy3l = 0._CUSTOM_REAL

          tempz1l = 0._CUSTOM_REAL
          tempz2l = 0._CUSTOM_REAL
          tempz3l = 0._CUSTOM_REAL

          do l=1,NGLLX
            hp1 = hprime_xx(l,i)
            iglob = ibool_inner_core(l,j,k,ispec)
            tempx1l = tempx1l + veloc_inner_core(1,iglob)*hp1
            tempy1l = tempy1l + veloc_inner_core(2,iglob)*hp1
            tempz1l = tempz1l + veloc_inner_core(3,iglob)*hp1
          enddo

          do l=1,NGLLY
            hp2 = hprime_yy(l,j)
            iglob = ibool_inner_core(i,l,k,ispec)
            tempx2l = tempx2l + veloc_inner_core(1,iglob)*hp2
            tempy2l = tempy2l + veloc_inner_core(2,iglob)*hp2
            tempz2l = tempz2l + veloc_inner_core(3,iglob)*hp2
          enddo

          do l=1,NGLLZ
            hp3 = hprime_zz(l,k)
            iglob = ibool_inner_core(i,j,l,ispec)
            tempx3l = tempx3l + veloc_inner_core(1,iglob)*hp3
            tempy3l = tempy3l + veloc_inner_core(2,iglob)*hp3
            tempz3l = tempz3l + veloc_inner_core(3,iglob)*hp3
          enddo

!         get derivatives of ux, uy and uz with respect to x, y and z

          xixl = xix_inner_core(i,j,k,ispec)
          xiyl = xiy_inner_core(i,j,k,ispec)
          xizl = xiz_inner_core(i,j,k,ispec)
          etaxl = etax_inner_core(i,j,k,ispec)
          etayl = etay_inner_core(i,j,k,ispec)
          etazl = etaz_inner_core(i,j,k,ispec)
          gammaxl = gammax_inner_core(i,j,k,ispec)
          gammayl = gammay_inner_core(i,j,k,ispec)
          gammazl = gammaz_inner_core(i,j,k,ispec)

          dvxdxl(i,j,k) = xixl*tempx1l + etaxl*tempx2l + gammaxl*tempx3l
          dvxdyl(i,j,k) = xiyl*tempx1l + etayl*tempx2l + gammayl*tempx3l
          dvxdzl(i,j,k) = xizl*tempx1l + etazl*tempx2l + gammazl*tempx3l

          dvydxl(i,j,k) = xixl*tempy1l + etaxl*tempy2l + gammaxl*tempy3l
          dvydyl(i,j,k) = xiyl*tempy1l + etayl*tempy2l + gammayl*tempy3l
          dvydzl(i,j,k) = xizl*tempy1l + etazl*tempy2l + gammazl*tempy3l

          dvzdxl(i,j,k) = xixl*tempz1l + etaxl*tempz2l + gammaxl*tempz3l
          dvzdyl(i,j,k) = xiyl*tempz1l + etayl*tempz2l + gammayl*tempz3l
          dvzdzl(i,j,k) = xizl*tempz1l + etazl*tempz2l + gammazl*tempz3l

        enddo
      enddo
    enddo

      do k = 1,NGLLZ
        do j = 1,NGLLY
          do i = 1,NGLLX
            ipoin = ibool_inner_core(i,j,k,ispec)
            if(.not. mask_poin(ipoin)) then
! coordinates actually contain r theta phi, therefore convert back to x y z
              rval = xstore_inner_core(ipoin)
              thetaval = ystore_inner_core(ipoin)
              phival = zstore_inner_core(ipoin)
              call rthetaphi_2_xyz(xcoord,ycoord,zcoord,rval,thetaval,phival)
! compute div and curl of velocity
              div = (dvxdxl(i,j,k) + dvydyl(i,j,k) + dvzdzl(i,j,k)) * scale_veloc / R_EARTH
              curl_x = (dvzdyl(i,j,k) - dvydzl(i,j,k)) * scale_veloc / R_EARTH
              curl_y = (dvxdzl(i,j,k) - dvzdxl(i,j,k)) * scale_veloc / R_EARTH
              curl_z = (dvydxl(i,j,k) - dvxdyl(i,j,k)) * scale_veloc / R_EARTH
              write(IOUT)   real(veloc_inner_core(1,ipoin)*scale_veloc), &
                            real(veloc_inner_core(2,ipoin)*scale_veloc), &
                            real(veloc_inner_core(3,ipoin)*scale_veloc), &
                            real(div),real(curl_x),real(curl_y),real(curl_z)
              if (ifirst_movie) write(IOUT_COORD) real(xcoord*R_EARTH),real(ycoord*R_EARTH),real(zcoord*R_EARTH)
              mask_poin(ipoin) = .true.
            endif
          enddo
        enddo
      enddo
      endif
    enddo

! write topology of elements
! PvK Modified to more compact and binary format
    if (ifirst_movie) then
     do ispec=1,nspec_inner_core
       if (idoubling_inner_core(ispec) /= IFLAG_IN_FICTITIOUS_CUBE) then
         write(IOUT_TOPOLOGY) (((indirect_poin(ibool_inner_core(i,j,k,ispec)),i=1,NGLLX),j=1,NGLLY),k=1,NGLLZ)
       endif
     enddo
    endif

    close(IOUT)
    if (ifirst_movie) then
       close(IOUT_TOPOLOGY)
       close(IOUT_COORD)
    endif

    deallocate(mask_poin)
    deallocate(indirect_poin)

! PvK After first movie snapshot has been written there is no more need to output topology and coordinates
    ifirst_movie=.false.

  endif

!---- end of time iteration loop
!
  enddo   ! end of main time loop

! write the final seismograms
  call write_seismograms(myrank,seismograms,number_receiver_global,station_name, &
          network_name,nrec,nrec_local,DT,NSTEP,t0,LOCAL_PATH,it_begin,it_end)

! save files to local disk or MT tape system if restart file
  if(NUMBER_OF_RUNS > 1 .and. NUMBER_OF_THIS_RUN < NUMBER_OF_RUNS) then
    write(outputname,"('dump_all_arrays',i4.4)") myrank
    open(unit=55,file=final_LOCAL_PATH(1:len_trim(final_LOCAL_PATH))//outputname,status='unknown',form='unformatted')
    write(55) displ_crust_mantle
    write(55) veloc_crust_mantle
    write(55) accel_crust_mantle
    write(55) displ_inner_core
    write(55) veloc_inner_core
    write(55) accel_inner_core
    write(55) displ_outer_core
    write(55) veloc_outer_core
    write(55) accel_outer_core
    write(55) R_memory_crust_mantle
    write(55) R_memory_inner_core
    write(55) epsilondev_crust_mantle
    write(55) epsilondev_inner_core
    write(55) A_array_rotation
    write(55) B_array_rotation
    close(55)
  endif

! close the main output file
  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'End of the simulation'
    write(IMAIN,*)
    close(IMAIN)
  endif

! synchronize all the processes to make sure everybody has finished
  call MPI_BARRIER(MPI_COMM_WORLD,ier)

! stop all the MPI processes, and exit
  call MPI_FINALIZE(ier)

  end program specfem3D

