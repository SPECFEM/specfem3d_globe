#!/usr/bin/env python


from pyre.applications import Script
from os.path import dirname, exists, isdir, join
import os, sys, stat, shutil, tarfile
from time import sleep


SPECFEM3D_GLOBE = dirname(__file__)


class Specfem3DGlobe(Script):


    name = "Specfem3DGlobe"


    import pyre.inventory
    import pyre.schedulers
    import pyre.launchers
    
    parFile        = pyre.inventory.str("par-file")
    cmtSolution    = pyre.inventory.str("cmt-solution")
    stations       = pyre.inventory.str("stations")
    configureArgs  = pyre.inventory.str("configure-args", default="FC=mpif90")

    scratchDir     = pyre.inventory.str("scratch-dir", default="/scratch")

    nodes          = pyre.inventory.int("nodes", default=1)
    scheduler      = pyre.schedulers.scheduler("scheduler", default="none")
    job            = pyre.schedulers.job("job")
    launchCommand  = pyre.inventory.str("launch-command", default="mpirun -np %(nodes)s")
    context        = pyre.inventory.str(
        name="context", default="login", validator=pyre.inventory.choice(["login", "launcher", "pre-compute", "post-compute"]))
    progressUrl = pyre.inventory.str("progress-url")



    def main(self, *args, **kwds):
        context = self.context
        if context == "login":
            self.onLoginNode(*args, **kwds)
        elif context == "launcher":
            self.onLauncherNode(*args, **kwds)
        elif context == "pre-compute":
            self.onPreCompute(*args, **kwds)
        elif context == "post-compute":
            self.onPostCompute(*args, **kwds)
        return


    def onLoginNode(self, *args, **kwds):
        # Redirect all output -- our journal output, and the output of
        # our children -- to a file.
        fd = os.open("output_build.txt", os.O_CREAT | os.O_WRONLY, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)
        os.dup2(fd, 1)
        os.dup2(fd, 2)
        os.close(fd)

        self.prepareFiles()
        self.build()
        pid = os.fork()
        if pid:
            self.monitorProgress(pid)
        else:
            self.schedule(*args, **kwds)
            self.processOutputFiles()
        return


    def onLauncherNode(self, *args, **kwds):
        
        launchCommand = self.launchCommand % {'nodes': self.nodes}
        launchCommand = launchCommand.split()

        wd = os.getcwd()
        myArgv = self.getArgv(*args, **kwds)

        # launch ourselves
        argv = launchCommand + [sys.executable, __file__] + myArgv + ["--context=pre-compute", "--nodes=%d" % self.nodes]
        status = os.spawnvp(os.P_WAIT, argv[0], argv)
        if status != 0:
            sys.exit("%s: exit %d" % (argv[0], status))

        # launch the mesher
        argv = launchCommand + [join(wd, "xmeshfem3D")]
        status = os.spawnvp(os.P_WAIT, argv[0], argv)
        if status != 0:
            sys.exit("%s: exit %d" % (argv[0], status))

        # launch the solver
        argv = launchCommand + [join(wd, "xspecfem3D")]
        status = os.spawnvp(os.P_WAIT, argv[0], argv)
        if status != 0:
            sys.exit("%s: exit %d" % (argv[0], status))

        # launch ourselves
        argv = launchCommand + [sys.executable, __file__] + myArgv + ["--context=post-compute", "--nodes=%d" % self.nodes]
        status = os.spawnvp(os.P_WAIT, argv[0], argv)
        if status != 0:
            sys.exit("%s: exit %d" % (argv[0], status))

        return


    def onPreCompute(self, *args, **kwds):
        makedirs(self.scratchDir)

    def onPostCompute(self, *args, **kwds):
        try:
            files = os.listdir(self.scratchDir)
            for file in files:
                try:
                    os.remove(join(self.scratchDir, file))
                except OSError:
                    pass
        except OSError:
            pass

        try:
            os.rmdir(self.scratchDir)
        except OSError:
            pass

        return


    def prepareFiles(self):
        
        self.mkdir("DATA")
        self.mkdir("OUTPUT_FILES")
        
        self.readAndCopyParFile()

        shutil.copyfile(self.cmtSolution, "DATA/CMTSOLUTION")
        shutil.copyfile(self.stations, "DATA/STATIONS")

        dataSrc = join(SPECFEM3D_GLOBE, "DATA")
        for name in os.listdir(dataSrc):
            src = join(dataSrc, name)
            dest = join("DATA", name)
            if exists(dest):
                continue
            os.symlink(src, dest)
        
        return


    def readAndCopyParFile(self):
        s = open(self.parFile, "r")
        d = open("DATA/Par_file", "w")
        for line in s:
            tokens = line.split()
            if len(tokens) >= 3:
                var = tokens[0]
                if var == "NCHUNKS":
                    NCHUNKS = int(tokens[2])
                elif var == "NPROC_XI":
                    NPROC_XI = int(tokens[2])
                elif var == "NPROC_ETA":
                    NPROC_ETA = int(tokens[2])
                elif var == "LOCAL_PATH":
                    print >>d, "LOCAL_PATH =", self.scratchDir
                    continue
            print >>d, line,
        self.nodes = NCHUNKS * NPROC_XI * NPROC_ETA
        return


    def build(self):
        
        # configure
        configure = join(SPECFEM3D_GLOBE, "configure")
        configureArgs = self.configureArgs.split()
        argv = [configure] + configureArgs
        print ' '.join(argv)
        status = os.spawnvp(os.P_WAIT, argv[0], argv)
        if status != 0:
            sys.exit("%s: exit %d" % (argv[0], status))

        # make
        self.mkdir("obj")
        argv = ['make']
        print ' '.join(argv)
        status = os.spawnvp(os.P_WAIT, argv[0], argv)
        if status != 0:
            sys.exit("%s: exit %d" % (argv[0], status))

        return


    def schedule(self, *args, **kwds):
        argv = self.getArgv(*args, **kwds)
        
        # initialize the job
        job = self.job
        job.nodes = self.nodes
        job.executable = sys.executable
        job.arguments = [__file__] + argv + ["--context=launcher", "--nodes=%d" % self.nodes]

        # schedule
        self.scheduler.schedule(job)

        return


    def mkdir(self, name):
        if not isdir(name):
            os.mkdir(name)
        return


    def processOutputFiles(self):

        archiveOut = open("specfem3dglobe.tar.gz", 'w')
        tgzOut = tarfile.open(archiveOut.name, 'w:gz', archiveOut)

        for name in os.listdir("OUTPUT_FILES"):
            pathname = join("OUTPUT_FILES", name)
            arcname = pathname
            tgzOut.add(pathname, arcname)

        tgzOut.close()
        archiveOut.close()

        for filename in ["output_mesher.txt", "output_solver.txt"]:
            pathname = join("OUTPUT_FILES", filename)
            if exists(pathname):
                shutil.copyfile(pathname, filename)

        return


    def monitorProgress(self, pid):
        progress = None
        wpid, status = os.waitpid(pid, os.WNOHANG)
        while wpid == 0:
            newProgress = self.checkProgress()
            if newProgress != progress:
                progress = newProgress
                self.postProgress(progress)
            sleep(60)
            wpid, status = os.waitpid(pid, os.WNOHANG)
        return


    def checkProgress(self):
        try:
            s = open("OUTPUT_FILES/output_solver.txt", 'r')
        except IOError:
            return None
        progress = 0.0
        for line in s:
            if line.startswith(" We have done"):
                progress = float(line.split()[3]) / 100.0
        return progress


    def postProgress(self, progress):
        import urllib, urlparse
        scheme, host, path = urlparse.urlparse(self.progressUrl)[0:3]
        fields = { 'progress': "%.2f" % progress }
        body = urllib.urlencode(fields)
        headers = {"Content-Type": "application/x-www-form-urlencoded",
                   "Accept": "text/plain"}
        import httplib
        if scheme == "http":
            conn = httplib.HTTPConnection(host)
        elif scheme == "https":
            conn = httplib.HTTPSConnection(host)
        else:
            assert False # not scheme in ["http", "https"]
        conn.request("POST", path, body, headers)
        response = conn.getresponse()
        data = response.read()
        conn.close()
        return data



def makedirs(name, mode=0777):
    """Like os.makedirs(), but multi-{thread,process} safe."""
    import os.path as path
    from os import curdir, mkdir
    head, tail = path.split(name)
    if not tail:
        head, tail = path.split(head)
    if head and tail and not path.exists(head):
        makedirs(head, mode)
        if tail == curdir:           # xxx/newdir/. exists if xxx/newdir exists
            return
    try:
        mkdir(name, mode)
    except OSError, error:
        # 17 == "File exists"
        if hasattr(error, 'errno') and error.errno == 17:
            pass
        else:
            raise
    return



if __name__ == "__main__":
    script = Specfem3DGlobe()
    script.run()


# end of file
